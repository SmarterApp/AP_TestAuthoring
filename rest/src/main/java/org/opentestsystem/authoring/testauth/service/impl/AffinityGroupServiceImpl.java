/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.service.impl;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.authoring.testauth.domain.AffinityGroup;
import org.opentestsystem.authoring.testauth.domain.AffinityGroupItemLocation;
import org.opentestsystem.authoring.testauth.domain.AffinityGroupValue;
import org.opentestsystem.authoring.testauth.domain.Item;
import org.opentestsystem.authoring.testauth.domain.ItemCountSummary;
import org.opentestsystem.authoring.testauth.domain.ItemLocation;
import org.opentestsystem.authoring.testauth.domain.ItemMoveResponse;
import org.opentestsystem.authoring.testauth.domain.Segment;
import org.opentestsystem.authoring.testauth.domain.ValidationResult;
import org.opentestsystem.authoring.testauth.domain.search.AffinityGroupSearchRequest;
import org.opentestsystem.authoring.testauth.persistence.AffinityGroupRepository;
import org.opentestsystem.authoring.testauth.service.AffinityGroupService;
import org.opentestsystem.authoring.testauth.service.ItemService;
import org.opentestsystem.authoring.testauth.service.PerformanceLevelService;
import org.opentestsystem.authoring.testauth.service.ScoringRuleService;
import org.opentestsystem.authoring.testauth.service.SegmentService;
import org.opentestsystem.authoring.testauth.service.impl.AffinityGroupHelper.AFFINITY_GROUP_ADD_DEFAULT_SEGMENT_VALUE_TRANSFORMER;
import org.opentestsystem.authoring.testauth.service.impl.AffinityGroupHelper.AFFINITY_GROUP_REMOVE_SEGMENT_VALUE_TRANSFORMER;
import org.opentestsystem.authoring.testauth.service.impl.AffinityGroupHelper.AFFINITY_GROUP_UPDATE_ISA_PARAMETERS_TRANSFORMER;
import org.opentestsystem.authoring.testauth.validation.AffinityGroupValidator;
import org.opentestsystem.authoring.testauth.validation.ValidationHelper;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.exception.RestException;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;
import org.springframework.validation.BeanPropertyBindingResult;
import org.springframework.validation.BindingResult;

import com.google.common.collect.Lists;

@Service
public class AffinityGroupServiceImpl extends AssessmentChildHelper implements AffinityGroupService {

    private static final String AFFINITY_GROUP_ITEM_MSG = "%s contains too %s %s items (%s), the %s defined by the affinty group is %s.";

    @Autowired
    private AffinityGroupRepository affinityGroupRepository;

    @Autowired
    private ItemService itemService;

    @Autowired
    private SegmentService segmentService;

    @Autowired
    private AffinityGroupValidator affinityGroupValidator;

    @Autowired
    private ScoringRuleService scoringRuleService;

    @Autowired
    private PerformanceLevelService performanceLevelService;

    @Override
    public AffinityGroup getAffinityGroup(final String affinityGroupId) {
        return this.affinityGroupRepository.findOne(affinityGroupId);
    }

    @Override
    public List<AffinityGroup> getAffinityGroupsByAssessment(final String assessmentId) {
        return this.affinityGroupRepository.findAllByAssessmentId(assessmentId);
    }

    @Override
    public SearchResponse<AffinityGroup> search(final Map<String, String[]> parameterMap) {
        final AffinityGroupSearchRequest searchRequest = new AffinityGroupSearchRequest(parameterMap);
        if (searchRequest.isValid()) {
            return this.affinityGroupRepository.search(searchRequest);
        }
        throw new RestException("affinityGroup.search.invalidsearchcriteria");
    }

    @Override
    public AffinityGroup saveNewAffinityGroup(AffinityGroup affinityGroup) {
        AffinityGroup savedGroup = null;
        if (affinityGroup != null) {
            checkForLockedAssessment(affinityGroup.getAssessmentId());

            // populate segment values with defaults (if user does not provide them)
            if (affinityGroup.getAffinityGroupValueMap() == null || affinityGroup.getAffinityGroupValueMap().isEmpty()) {
                affinityGroup.setAffinityGroupValueMap(new HashMap<String, AffinityGroupValue>());
                final List<Segment> segments = this.segmentService.findSegmentListByAssessmentId(affinityGroup.getAssessmentId());
                this.segmentService.loadReferenceData(segments);

                for (final Segment segment : segments) {
                    affinityGroup = AFFINITY_GROUP_ADD_DEFAULT_SEGMENT_VALUE_TRANSFORMER.getInstance(segment.getId(), segment.getItemSelectionAlgorithm()).apply(affinityGroup);
                }
            }

            // validate and save
            try {
                validateAffinityGroup(affinityGroup);
                savedGroup = this.affinityGroupRepository.save(affinityGroup);
            } catch (final DuplicateKeyException dke) {
                throw new LocalizedException("affinityGroup.already.exists", new String[] { }, dke);
            }
        }

        return savedGroup;
    }

    @Override
    public AffinityGroup updateExistingAffinityGroup(final AffinityGroup affinityGroup) {
        AffinityGroup savedGroup = null;
        if (affinityGroup != null) {
            checkForLockedAssessment(affinityGroup.getAssessmentId());
            if (StringUtils.isBlank(affinityGroup.getId())) {
                throw new LocalizedException("affinityGroup.id.required");
            }
            try {
                validateAffinityGroup(affinityGroup);
                savedGroup = this.affinityGroupRepository.save(affinityGroup);
            } catch (final DuplicateKeyException dke) {
                throw new LocalizedException("affinityGroup.already.exists", new String[] { }, dke);
            }
        }
        return savedGroup;
    }

    @Override
    public List<AffinityGroup> updateAffinityGroupList(final List<AffinityGroup> affinityGroups) {
        final List<AffinityGroup> savedAffinityGroups = Lists.newArrayList();
        if (!CollectionUtils.isEmpty(affinityGroups)) {
            checkForLockedAssessment(affinityGroups.get(0).getAssessmentId());
            try {
                savedAffinityGroups.addAll(this.affinityGroupRepository.save(affinityGroups));
            } catch (final DuplicateKeyException dke) {
                throw new LocalizedException("affinityGroup.listhasduplicates", dke);
            }
        }
        return savedAffinityGroups;
    }

    @Override
    public void removeAffinityGroup(final String affinityGroupId) {
        // TODO - what happens to items if you delete AffinityGroup segments?
        final AffinityGroup existingAffinityGroup = getAffinityGroup(affinityGroupId);
        if (existingAffinityGroup != null) {
            checkForLockedAssessment(existingAffinityGroup.getAssessmentId());
            this.scoringRuleService.removeByBlueprintReferenceId(existingAffinityGroup.getAssessmentId(), affinityGroupId);
            this.performanceLevelService.removeByReferenceId(affinityGroupId);
            this.itemService.removeByAffinityGroupId(affinityGroupId);
            this.affinityGroupRepository.delete(affinityGroupId);
        }
    }

    @Override
    public void removeAffinityGroupsByAssessment(final String assessmentId) {
        checkForLockedAssessment(assessmentId);
        this.affinityGroupRepository.delete(this.affinityGroupRepository.findAllByAssessmentId(assessmentId));
    }

    @Override
    public List<AffinityGroup> addAffinityGroupValueGroup(final String assessmentId, final String segmentId) {
        checkForLockedAssessment(assessmentId);
        final Segment segment = this.segmentService.getSegment(segmentId);

        final List<AffinityGroup> affinityGroupList = this.affinityGroupRepository.findAllByAssessmentId(assessmentId);
        final List<AffinityGroup> updatedAffinityGroupList = Lists.transform(affinityGroupList,
                AFFINITY_GROUP_ADD_DEFAULT_SEGMENT_VALUE_TRANSFORMER.getInstance(segmentId, segment == null ? null : segment.getItemSelectionAlgorithm()));
        return this.affinityGroupRepository.save(updatedAffinityGroupList);
    }

    @Override
    public List<AffinityGroup> removeAffinityGroupValueGroup(final String assessmentId, final String segmentId) {
        checkForLockedAssessment(assessmentId);
        final List<AffinityGroup> affinityGroupList = this.affinityGroupRepository.findAllByAssessmentId(assessmentId);
        if (!CollectionUtils.isEmpty(affinityGroupList)) {
            final List<AffinityGroup> updatedAffinityGroupList = Lists.transform(affinityGroupList, AFFINITY_GROUP_REMOVE_SEGMENT_VALUE_TRANSFORMER.getInstance(segmentId));
            return this.affinityGroupRepository.save(updatedAffinityGroupList);
        }
        return null;
    }

    @Override
    public List<AffinityGroup> updateAffinityGroupItemSelectionParameters(final String assessmentId, final String segmentId) {
        checkForLockedAssessment(assessmentId);
        final Segment segment = this.segmentService.getSegment(segmentId);

        final List<AffinityGroup> affinityGroupList = this.affinityGroupRepository.findAllByAssessmentId(assessmentId);
        final List<AffinityGroup> updatedAffinityGroupList = Lists.transform(affinityGroupList,
                AFFINITY_GROUP_UPDATE_ISA_PARAMETERS_TRANSFORMER.getInstance(segmentId, segment == null ? null : segment.getItemSelectionAlgorithm()));
        return this.affinityGroupRepository.save(updatedAffinityGroupList);
    }

    @Override
    public ItemMoveResponse attachItemsToAffinityGroup(final String affinityGroupId, final List<String> itemIdentifiers) {
        int itemsOmitted = 0;
        int itemsImpacted = 0;

        final AffinityGroup affinityGroup = this.getAffinityGroup(affinityGroupId);
        if (affinityGroup == null) {
            throw new LocalizedException("affinityGroup.id.invalid");
        }

        final ItemLocation affinityGroupLocation = new AffinityGroupItemLocation(affinityGroupId);
        for (final String identifier : itemIdentifiers) {
            final Item item = itemService.getItemByAssessmentIdAndTibIdentifier(affinityGroup.getAssessmentId(), identifier);
            if (item == null || itemService.hasLocation(item, affinityGroupLocation)) {
                itemsOmitted++;
            } else {
                itemsImpacted++;
                item.addItemLocation(affinityGroupLocation);
                itemService.saveItem(item);
            }
        }

        final ItemMoveResponse itemMoveResponse = new ItemMoveResponse();
        itemMoveResponse.setItemsImpacted(itemsImpacted);
        itemMoveResponse.setItemsOmitted(itemsOmitted);
        return itemMoveResponse;
    }

    @Override
    public ItemMoveResponse detachItemsFromAffinityGroup(final String affinityGroupId, final List<String> itemIdentifiers) {
        int itemsOmitted = 0;
        int itemsImpacted = 0;

        final AffinityGroup affinityGroup = this.getAffinityGroup(affinityGroupId);
        if (affinityGroup == null) {
            throw new LocalizedException("affinityGroup.id.invalid");
        }

        final ItemLocation affinityGroupLocation = new AffinityGroupItemLocation(affinityGroupId);
        for (final String identifier : itemIdentifiers) {
            final Item item = itemService.getItemByAssessmentIdAndTibIdentifier(affinityGroup.getAssessmentId(), identifier);
            if (item == null || !itemService.hasLocation(item, affinityGroupLocation)) {
                itemsOmitted++;
            } else {
                itemsImpacted++;
                item.removeItemLocation(affinityGroupLocation);
                itemService.saveItem(item);
            }
        }

        final ItemMoveResponse itemMoveResponse = new ItemMoveResponse();
        itemMoveResponse.setItemsImpacted(itemsImpacted);
        itemMoveResponse.setItemsOmitted(itemsOmitted);
        return itemMoveResponse;
    }

    private void validateAffinityGroup(final AffinityGroup affinityGroup) {
        final BindingResult bindingResult = new BeanPropertyBindingResult(affinityGroup, "affinityGroup");
        this.affinityGroupValidator.validate(affinityGroup, bindingResult);
        if (bindingResult.hasErrors()) {
            throw ValidationHelper.convertErrorsToConstraintException(affinityGroup, bindingResult);
        }
    }

    @Override
    public List<ValidationResult<AffinityGroup>> validateAffinityGroups(final String assessmentId) {
        final List<ValidationResult<AffinityGroup>> validationList = Lists.newArrayList();
        final Map<String, ItemCountSummary> affinityGroupItemCounts = this.itemService.getAffinityGroupItemCounts(assessmentId);

        final List<AffinityGroup> affinityGroups = this.getAffinityGroupsByAssessment(assessmentId);
        for (final AffinityGroup affinityGroup : affinityGroups) {
            if (affinityGroup.isActive()) {
                final ItemCountSummary itemCountSummary = affinityGroupItemCounts.get(affinityGroup.getId());

                if (itemCountSummary.getOpCount() < affinityGroup.getMasterAffinityGroupValue().getOperationalItemMinValue()) {
                    validationList.add(new ValidationResult<AffinityGroup>(affinityGroup, String.format(AFFINITY_GROUP_ITEM_MSG,
                            affinityGroup.getGroupName(), "few", "OP", itemCountSummary.getOpCount(), "minimum", affinityGroup.getMasterAffinityGroupValue().getOperationalItemMinValue())));
                }
                if (itemCountSummary.getOpCount() > affinityGroup.getMasterAffinityGroupValue().getOperationalItemMaxValue()) {
                    validationList.add(new ValidationResult<AffinityGroup>(affinityGroup, String.format(AFFINITY_GROUP_ITEM_MSG,
                            affinityGroup.getGroupName(), "many", "OP", itemCountSummary.getOpCount(), "maximum", affinityGroup.getMasterAffinityGroupValue().getOperationalItemMaxValue())));
                }
                if (itemCountSummary.getFtCount() < affinityGroup.getMasterAffinityGroupValue().getFieldTestItemMinValue()) {
                    validationList.add(new ValidationResult<AffinityGroup>(affinityGroup, String.format(AFFINITY_GROUP_ITEM_MSG,
                            affinityGroup.getGroupName(), "few", "FT", itemCountSummary.getFtCount(), "minimum", affinityGroup.getMasterAffinityGroupValue().getFieldTestItemMinValue())));

                }
                if (itemCountSummary.getFtCount() > affinityGroup.getMasterAffinityGroupValue().getFieldTestItemMaxValue()) {
                    validationList.add(new ValidationResult<AffinityGroup>(affinityGroup, String.format(AFFINITY_GROUP_ITEM_MSG,
                            affinityGroup.getGroupName(), "many", "FT", itemCountSummary.getFtCount(), "maximum", affinityGroup.getMasterAffinityGroupValue().getFieldTestItemMaxValue())));
                }
            }
        }

        return validationList;
    }
}
