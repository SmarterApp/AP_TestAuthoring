/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.rest;

import static org.junit.Assert.assertTrue;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.put;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import java.io.IOException;
import java.lang.annotation.Annotation;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import javax.validation.ConstraintViolation;
import javax.validation.ConstraintViolationException;

import org.apache.commons.lang.StringUtils;
import org.junit.After;
import org.junit.Before;
import org.junit.runner.RunWith;
import org.mockito.Mockito;
import org.opentestsystem.authoring.testspecbank.client.init.TestSpecBankClientContextInitializer;
import org.opentestsystem.shared.exception.RestException;
import org.opentestsystem.shared.mna.client.listener.ClientSpringConfigurator;
import org.opentestsystem.shared.progman.client.domain.Tenant;
import org.opentestsystem.shared.progman.init.InitSpringPropertyConfigLoad;
import org.opentestsystem.shared.security.domain.SbacUser;
import org.opentestsystem.shared.security.service.UserService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.annotation.Transient;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.http.MediaType;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;
import org.springframework.test.web.servlet.ResultMatcher;
import org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;

import uk.co.jemos.podam.api.PodamFactoryImpl;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;

@WebAppConfiguration
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = { "classpath:test-rest-context.xml" },
        initializers = { InitSpringPropertyConfigLoad.class, ClientSpringConfigurator.class, TestSpecBankClientContextInitializer.class })
@ActiveProfiles({ "progman.client.impl.null", "progman.proploc.classpath", "mna.client.null" })
public abstract class AbstractRestEmbeddedMongoTest {
    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractRestEmbeddedMongoTest.class);

    protected static final PodamFactoryImpl PODAM_FACTORY = new PodamFactoryImpl();

    protected boolean setUpMocks = true;

    static {
        final List<Class<? extends Annotation>> annotationsToExclude = Lists.newArrayList();
        annotationsToExclude.add(Transient.class);
        PODAM_FACTORY.setExcludeAnnotations(annotationsToExclude);
    }

    protected MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @Autowired
    private WebApplicationContext webApplicationContext;

    @Autowired
    protected MongoTemplate mongoTemplate;

    @Autowired
    protected UserService userService;

    @Before
    public void setUp() {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.webApplicationContext).build();
        // Map<String, SbacRole> roleMap = new HashMap<String, SbacRole>();
        if (this.setUpMocks) {
            final SbacUser mockUser = Mockito.mock(SbacUser.class);
            Mockito.when(mockUser.hasPermissionForTenant(Mockito.anyString(), Mockito.anyString())).thenReturn(true);
            Mockito.when(mockUser.hasPermission(Mockito.anyString())).thenReturn(true);
            Mockito.when(this.userService.getCurrentUser()).thenReturn(mockUser);
        }
    }

    @After
    public void dropCollections() {
        final Query all = new Query();
        for (final String collectionName : this.mongoTemplate.getCollectionNames()) {
            if (!"system.indexes".equals(collectionName)) {
                this.mongoTemplate.remove(all, collectionName);
            }
        }
    }

    protected byte[] getJsonContent(final Map<String, Object> params) {
        byte[] bytes = null;
        try {
            bytes = this.objectMapper.writeValueAsBytes(params);
        } catch (final Exception e) {
            LOGGER.error(e.getMessage());
            throw new RestException("unit.test.error", e);
        }
        return bytes;
    }

    protected byte[] getJsonContentFromList(final List<Map<String, Object>> params) {
        byte[] bytes = null;
        try {
            bytes = this.objectMapper.writeValueAsBytes(params);
        } catch (final Exception e) {
            LOGGER.error(e.getMessage());
            throw new RestException("unit.test.error", e);
        }
        return bytes;
    }

    protected byte[] getJsonContentFromSimpleList(final List<Object> params) {
        byte[] bytes = null;
        try {
            bytes = this.objectMapper.writeValueAsBytes(params);
        } catch (final Exception e) {
            LOGGER.error(e.getMessage());
            throw new RestException("unit.test.error", e);
        }
        return bytes;
    }

    protected <T> T callGETRestService(final String uri, final Class<T> responseObjectType, final ResultMatcher expectedResult) {
        return callGETRestService(uri, responseObjectType, expectedResult, null);
    }

    @SuppressWarnings("unchecked")
    protected Map<String, List<String>> callInvalidGETRequest(final String uri) {
        Map<String, Object> propertyMap = Maps.newHashMap();
        Map<String, List<String>> messages = null;
        try {
            final MvcResult result = this.mockMvc.perform(get(uri).accept(MediaType.APPLICATION_JSON)).andExpect(status().isBadRequest()).andReturn();
            final String response = result.getResponse().getContentAsString();
            propertyMap = this.objectMapper.readValue(response, Map.class);
            messages = (Map<String, List<String>>) propertyMap.get("messages");
        } catch (final Exception e) {
            e.printStackTrace();
            throw new RestException("error int callInvalidGETRequest " + uri, e);
        }
        return messages;
    }

    protected <T> T callGETRestService(final String uri, final Class<T> responseObjectType, final ResultMatcher expectedResult, final Map<String, String> params) {
        T object = null;
        try {
            MockHttpServletRequestBuilder get = get(uri);
            if (params != null) {
                for (final Entry<String, String> entry : params.entrySet()) {
                    get = get.param(entry.getKey(), entry.getValue());
                }
            }

            final MvcResult result = this.mockMvc.perform(get.accept(MediaType.APPLICATION_JSON)).andExpect(expectedResult).andReturn();
            final String responseGet = result.getResponse().getContentAsString();
            if (responseGet != null && responseGet.length() > 1) {
                object = this.objectMapper.readValue(responseGet, responseObjectType);
            }
        } catch (final Exception e) {
            throw new RestException("error int callGETRestService " + uri, e);
        }
        return object;
    }

    protected <T> T callGETRestService(final String uri, final Class<T> responseObjectType) {
        return callGETRestService(uri, responseObjectType, status().isOk());
    }

    protected <T> T callGETRestService(final String uri, final Class<T> responseObjectType, final Map<String, String> params) {
        return callGETRestService(uri, responseObjectType, status().isOk(), params);
    }

    protected <T> T callPOSTRestService(final String uri, final Map<String, Object> jsonParams, final Class<T> responseObjectType) {
        T object = null;
        try {
            final MvcResult result = this.mockMvc.perform(post(uri).accept(MediaType.ALL).contentType(MediaType.APPLICATION_JSON)
                    .content(getJsonContent(jsonParams))).andExpect(status().isCreated()).andReturn();
            final String responseGet = result.getResponse().getContentAsString();
            object = this.objectMapper.readValue(responseGet, responseObjectType);
        } catch (final Exception e) {
            e.printStackTrace();
            throw new RestException("error int callPOSTRestService " + uri, e);
        }
        return object;
    }

    @SuppressWarnings("unchecked")
    protected Map<String, List<String>> callPOSTWithBadData(final String uri, final Map<String, Object> jsonParams) {
        Map<String, Object> propertyMap = Maps.newHashMap();
        Map<String, List<String>> messages = null;
        try {
            final MvcResult result = this.mockMvc.perform(post(uri).accept(MediaType.ALL).contentType(MediaType.APPLICATION_JSON)
                    .content(getJsonContent(jsonParams))).andExpect(status().isBadRequest()).andReturn();
            final String response = result.getResponse().getContentAsString();
            propertyMap = this.objectMapper.readValue(response, Map.class);
            messages = (Map<String, List<String>>) propertyMap.get("messages");
        } catch (final Exception e) {
            e.printStackTrace();
            throw new RestException("error int callPOSTRestService " + uri, e);
        }
        return messages;
    }

    @SuppressWarnings("unchecked")
    protected Map<String, List<String>> callPUTWithBadData(final String uri, final Map<String, Object> jsonParams) {
        Map<String, Object> propertyMap = Maps.newHashMap();
        Map<String, List<String>> messages = null;
        try {
            final MvcResult result = this.mockMvc.perform(put(uri).accept(MediaType.ALL).contentType(MediaType.APPLICATION_JSON)
                    .content(getJsonContent(jsonParams))).andExpect(status().isBadRequest()).andReturn();
            final String response = result.getResponse().getContentAsString();
            propertyMap = this.objectMapper.readValue(response, Map.class);
            messages = (Map<String, List<String>>) propertyMap.get("messages");
        } catch (final Exception e) {
            e.printStackTrace();
            throw new RestException("error int callPOSTRestService " + uri, e);
        }
        return messages;
    }

    protected void callDeleteRestService(final String uri) {
        try {
            this.mockMvc.perform(delete(uri).accept(MediaType.ALL)).andExpect(status().isNoContent()).andReturn();
        } catch (final Exception e) {
            e.printStackTrace();
            throw new RestException("error int callDeleteRestService " + uri, e);
        }
    }

    protected <T> T callPUTRestService(final String uri, final Map<String, Object> jsonParams, final Class<T> responseObjectType) {
        return callPUTRestService(uri, jsonParams, responseObjectType, status().isOk());
    }

    protected <T> T callPUTRestService(final String uri, final Map<String, Object> jsonParams, final Class<T> responseObjectType, final ResultMatcher expectedResult) {
        T object = null;
        try {
            final MvcResult result = this.mockMvc.perform(put(uri).accept(MediaType.ALL).contentType(MediaType.APPLICATION_JSON)
                    .content(getJsonContent(jsonParams))).andExpect(expectedResult).andReturn();
            final String responseGet = result.getResponse().getContentAsString();
            object = this.objectMapper.readValue(responseGet, responseObjectType);
        } catch (final Exception e) {
            e.printStackTrace();
            throw new RestException("error int callPUTRestService " + uri, e);
        }
        return object;
    }

    protected <T> T callPUTRestServiceWithList(final String uri, final List<Map<String, Object>> jsonParamsList, final Class<T> responseObjectType) {
        T object = null;
        try {
            final MvcResult result = this.mockMvc.perform(put(uri).accept(MediaType.ALL).contentType(MediaType.APPLICATION_JSON)
                    .content(getJsonContentFromList(jsonParamsList))).andExpect(status().isOk()).andReturn();
            final String responseGet = result.getResponse().getContentAsString();
            object = this.objectMapper.readValue(responseGet, responseObjectType);
        } catch (final Exception e) {
            e.printStackTrace();
            throw new RestException("error int callPUTRestService " + uri, e);
        }
        return object;
    }

    protected <T> T callPUTRestServiceWithSimpleList(final String uri, final List<Object> jsonList, final Class<T> responseObjectType) {
        T object = null;
        try {
            final MvcResult result = this.mockMvc.perform(put(uri).accept(MediaType.ALL).contentType(MediaType.APPLICATION_JSON)
                    .content(getJsonContentFromSimpleList(jsonList))).andExpect(status().isOk()).andReturn();
            final String responseGet = result.getResponse().getContentAsString();
            object = this.objectMapper.readValue(responseGet, responseObjectType);
        } catch (final Exception e) {
            e.printStackTrace();
            throw new RestException("error int callPUTRestService " + uri, e);
        }
        return object;
    }

    protected String buildQueryString(final Map<String, String> params) {
        final StringBuilder sb = new StringBuilder();
        sb.append('?');
        boolean first = true;
        for (final Entry<String, String> arg : params.entrySet()) {
            if (!first) {
                sb.append('&');
            }
            sb.append(arg.getKey()).append('=').append(arg.getValue());
            first = false;
        }
        return sb.toString();
    }

    @SuppressWarnings("unchecked")
    protected List<Map<String, Object>> buildParamList(final Map<String, Object>... params) {
        return Arrays.asList(params);
    }

    @SuppressWarnings("unchecked")
    protected Map<String, Object> buildParamObject(final Object o) {
        Map<String, Object> params = null;
        try {
            final String objectAsJson = this.objectMapper.writeValueAsString(o);
            params = this.objectMapper.readValue(objectAsJson, Map.class);
        } catch (final IOException e) {
            e.printStackTrace();
        }
        return params;
    }

    protected void assertFieldLevelErrorMessageReturned(final Map<String, List<String>> errorMessages, final String fieldName, final String compareMessage) {
        boolean found = false;
        final List<String> fieldMessages = errorMessages.get(fieldName);
        if (fieldMessages != null) {
            for (final String message : fieldMessages) {
                if (compareMessage.equalsIgnoreCase(message)) {
                    found = true;
                    break;
                }
            }
        }
        assertTrue("unable to find error message in response:" + compareMessage + " for field:" + fieldName, found);
    }

    protected void assertFieldLevelErrorMessageContains(final Map<String, List<String>> errorMessages, final String fieldName, final String compareMessage) {
        boolean found = false;
        final List<String> fieldMessages = errorMessages.get(fieldName);
        if (fieldMessages != null) {
            for (final String message : fieldMessages) {
                if (message.contains(compareMessage)) {
                    found = true;
                    break;
                }
            }
        }
        assertTrue("unable to find error message in response:" + compareMessage + " for field:" + fieldName, found);
    }

    protected void assertApplicationErrorMessageReturned(final Map<String, List<String>> errorMessages, final String expectedError) {
        boolean found = false;
        final List<String> applicationErrors = errorMessages.get("applicationErrors");
        if (applicationErrors != null) {
            for (final String message : applicationErrors) {
                if (message.contains(expectedError)) {
                    found = true;
                    break;
                }
            }
        }
        assertTrue("unable to find application error message in response:" + expectedError, found);
    }

    protected Tenant buildTenant(final String id, final String name, final String description) {
        final Tenant tenant = new Tenant();
        tenant.setId(id);
        tenant.setName(name);
        tenant.setDescription(description);
        return tenant;
    }

    protected List<ConstraintViolation<?>> getConstraintViolation(final ConstraintViolationException e, final String messageCode) {
        final List<ConstraintViolation<?>> cvs = Lists.newArrayList();
        for (final ConstraintViolation<?> cv : e.getConstraintViolations()) {
            if (StringUtils.equals(cv.getMessageTemplate(), messageCode)) {
                cvs.add(cv);
            }
        }
        return cvs;
    }
}
