/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.integration;

import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.not;
import static org.hamcrest.CoreMatchers.notNullValue;
import static org.hamcrest.CoreMatchers.nullValue;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.Assert.fail;

import java.util.ArrayList;
import java.util.List;

import org.junit.Test;
import org.opentestsystem.authoring.testauth.domain.AffinityGroup;
import org.opentestsystem.authoring.testauth.domain.Assessment;
import org.opentestsystem.authoring.testauth.domain.DomainFactory;
import org.opentestsystem.authoring.testauth.domain.ItemMoveResponse;
import org.opentestsystem.authoring.testauth.domain.Segment;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.search.domain.SearchResponse;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;

public class AffinityGroupServiceTest extends AbstractAssessmentServiceTest {

    @Test
    public void removeAffinityGroup() {
        // TODO - assert number of items in affinity group
        final AffinityGroup group1 = addAffinityGroup(this.savedAssessment, "groupA");

        assertNumberOfAffinityGroupsInAssessment(this.savedAssessment, 1);
        assertNumberOfItemsInSegment(this.savedAdaptiveSegment, 0);

        addAdaptiveItem(this.savedAdaptiveSegment.getId(), "APIP_5000", group1.getId());
        addAdaptiveItem(this.savedAdaptiveSegment.getId(), "APIP_5001", group1.getId());
        addAdaptiveItem(this.savedAdaptiveSegment.getId(), "APIP_5002", group1.getId());

        assertNumberOfAffinityGroupsInAssessment(this.savedAssessment, 1);
        assertNumberOfItemsInSegment(this.savedAdaptiveSegment, 3);

        this.affinityGroupService.removeAffinityGroup(group1.getId());

        assertNumberOfAffinityGroupsInAssessment(this.savedAssessment, 0);
        assertNumberOfItemsInSegment(this.savedAdaptiveSegment, 3);
    }

    @Test
    public void addNewAffinityGroup() {
        AffinityGroup affinityGroup = DomainFactory.manufactureValidAffinityGroup(savedAssessment.getId());
        affinityGroup.setId(null);
        affinityGroup.setGroupName("groupA");
        affinityGroup.setAffinityGroupValueMap(null); // will be populated by service

        affinityGroup = this.affinityGroupService.saveNewAffinityGroup(affinityGroup);
        assertThat(affinityGroup, is(not(nullValue())));
        assertThat(affinityGroup.getAffinityGroupValueMap().size(), is(6));
    }

    @Test
    public void updateExistingAffinityGroup() {
        final AffinityGroup group1 = addAffinityGroup(this.savedAssessment, "groupA");
        group1.getAffinityGroupValueMap().get(this.savedAdaptiveSegment.getId()).setFieldTestItemMaxValue(4);
        final AffinityGroup updatedGrp = this.affinityGroupService.updateExistingAffinityGroup(group1);

        assertThat(updatedGrp.getAffinityGroupValueMap().get(savedAdaptiveSegment.getId()).getFieldTestItemMaxValue(), is(4));
        assertThat(updatedGrp.getAffinityGroupValueMap().size(), is(6));
    }

    @Test
    public void verifyDisinctAffinityGroupNameSegment() {
        addAffinityGroup(this.savedAssessment, "groupA");
        try {
            addAffinityGroup(this.savedAssessment, "groupA");
            fail("should thow duplicate key exception");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("affinityGroup.already.exists"));
        }
    }

    @Test
    public void verifyGroupWithSameNameDifferentSegmentFails() {
        addAffinityGroup(this.savedAssessment, "groupA");

        try {
            addAffinityGroup(this.savedAssessment, "groupA");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("affinityGroup.already.exists"));
        }
        assertNumberOfAffinityGroupsInAssessment(this.savedAssessment, 1);
    }

    @Test
    public void testCantRemoveIfAssessmentLocked() {
        final AffinityGroup group1 = addAffinityGroup(this.savedAssessment, "groupA");

        this.savedAssessment.setLocked(true);
        this.assessmentRepository.save(this.savedAssessment);

        try {
            this.affinityGroupService.removeAffinityGroup(group1.getId());
            fail("should thow locked exception");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("cannot.be.altered.assessment.locked"));
        }
    }

    @Test
    public void testCantAddIfAssessmentLocked() {
        this.savedAssessment.setLocked(true);
        this.assessmentRepository.save(this.savedAssessment);

        try {
            addAffinityGroup(this.savedAssessment, "groupA");
            fail("should thow locked exception");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("cannot.be.altered.assessment.locked"));
        }
    }

    @Test
    public void testCantRemoveAllGroupsIfAssessmentLocked() {
        addAffinityGroup(this.savedAssessment, "groupA");

        this.savedAssessment.setLocked(true);
        this.assessmentRepository.save(this.savedAssessment);

        try {
            this.affinityGroupService.removeAffinityGroupsByAssessment(this.savedAssessment.getId());
            fail("should thow locked exception");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("cannot.be.altered.assessment.locked"));
        }
    }

    @Test
    public void verifySegmentAddNoCloning() {
        final AffinityGroup affinityGroup1 = DomainFactory.manufactureValidAffinityGroup(savedAssessment.getId());
        final AffinityGroup affinityGroup2 = DomainFactory.manufactureValidAffinityGroup(savedAssessment.getId());
        final AffinityGroup affinityGroup3 = DomainFactory.manufactureValidAffinityGroup(savedAssessment.getId());
        assertThat(saveAffinityGroupList(ImmutableList.of(affinityGroup1, affinityGroup2, affinityGroup3)).size(), is(3));
        assertThat(this.affinityGroupService.getAffinityGroupsByAssessment(this.savedAssessment.getId()).size(), is(3));
        final SearchResponse<Segment> segmentSearchResponse = this.segmentService.searchSegments(ImmutableMap.of("assessmentId", new String[] { this.savedAssessment.getId() }));
        final String segmentId = segmentSearchResponse.getSearchResults().get(0).getId();
        final List<AffinityGroup> affinityGroupList = this.affinityGroupService.addAffinityGroupValueGroup(this.savedAssessment.getId(), segmentId);
        // verify affinityGroup got the addition
        assertThat(affinityGroupList.get(0).getAffinityGroupValueMap().get(segmentId), is(notNullValue()));
    }

    @Test
    public void addAffinityGroupValueGroupLockedAssessmentTest() {
        final AffinityGroup affinityGroup1 = DomainFactory.manufactureValidAffinityGroup(savedAssessment.getId());
        final AffinityGroup affinityGroup2 = DomainFactory.manufactureValidAffinityGroup(savedAssessment.getId());
        final AffinityGroup affinityGroup3 = DomainFactory.manufactureValidAffinityGroup(savedAssessment.getId());
        assertThat(saveAffinityGroupList(ImmutableList.of(affinityGroup1, affinityGroup2, affinityGroup3)).size(), is(3));
        assertThat(this.affinityGroupService.getAffinityGroupsByAssessment(this.savedAssessment.getId()).size(), is(3));
        final SearchResponse<Segment> segmentSearchResponse = this.segmentService.searchSegments(ImmutableMap.of("assessmentId", new String[] { this.savedAssessment.getId() }));
        final String segmentId = segmentSearchResponse.getSearchResults().get(0).getId();

        final Assessment retrievedAssessment = this.assessmentRepository.findOne(this.savedAssessment.getId());
        retrievedAssessment.setLocked(true);
        final Assessment reSavedAssessment = this.assessmentRepository.save(retrievedAssessment);
        assertThat(reSavedAssessment.isLocked(), is(true));

        try {
            this.affinityGroupService.addAffinityGroupValueGroup(this.savedAssessment.getId(), segmentId);
            fail("exception should be thrown when trying to save affinityGroup data for an already locked assessment");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("cannot.be.altered.assessment.locked"));
        }
    }

    @Test
    public void verifySegmentRemove() {
        final AffinityGroup affinityGroup1 = DomainFactory.manufactureValidAffinityGroup(savedAssessment.getId());
        final AffinityGroup affinityGroup2 = DomainFactory.manufactureValidAffinityGroup(savedAssessment.getId());
        final AffinityGroup affinityGroup3 = DomainFactory.manufactureValidAffinityGroup(savedAssessment.getId());
        assertThat(saveAffinityGroupList(ImmutableList.of(affinityGroup1, affinityGroup2, affinityGroup3)).size(), is(3));
        assertThat(this.affinityGroupService.getAffinityGroupsByAssessment(this.savedAssessment.getId()).size(), is(3));
        final SearchResponse<Segment> segmentSearchResponse = this.segmentService.searchSegments(ImmutableMap.of("assessmentId", new String[] { this.savedAssessment.getId() }));
        final String segmentId = segmentSearchResponse.getSearchResults().get(0).getId();
        final List<AffinityGroup> affinityGroupList = this.affinityGroupService.addAffinityGroupValueGroup(this.savedAssessment.getId(), segmentId);
        // verify affinityGroup got the addition
        assertThat(affinityGroupList.get(0).getAffinityGroupValueMap().get(segmentId), is(notNullValue()));
        final List<AffinityGroup> updatedAffinityGroupList = this.affinityGroupService.removeAffinityGroupValueGroup(this.savedAssessment.getId(), segmentId);
        // verify affinityGroup no longer has the previous addition
        assertThat(updatedAffinityGroupList.get(0).getAffinityGroupValueMap().get(segmentId), is(nullValue()));
    }

    @Test
    public void removeAffinityGroupValueGroupLockedAssessmentTest() {
        final AffinityGroup affinityGroup1 = DomainFactory.manufactureValidAffinityGroup(savedAssessment.getId());
        final AffinityGroup affinityGroup2 = DomainFactory.manufactureValidAffinityGroup(savedAssessment.getId());
        final AffinityGroup affinityGroup3 = DomainFactory.manufactureValidAffinityGroup(savedAssessment.getId());
        assertThat(saveAffinityGroupList(ImmutableList.of(affinityGroup1, affinityGroup2, affinityGroup3)).size(), is(3));
        assertThat(this.affinityGroupService.getAffinityGroupsByAssessment(this.savedAssessment.getId()).size(), is(3));
        final SearchResponse<Segment> segmentSearchResponse = this.segmentService.searchSegments(ImmutableMap.of("assessmentId", new String[] { this.savedAssessment.getId() }));
        final String segmentId = segmentSearchResponse.getSearchResults().get(0).getId();
        final List<AffinityGroup> affinityGroupList = this.affinityGroupService.addAffinityGroupValueGroup(this.savedAssessment.getId(), segmentId);
        // verify affinityGroup got the addition
        assertThat(affinityGroupList.get(0).getAffinityGroupValueMap().get(segmentId), is(notNullValue()));

        final Assessment retrievedAssessment = this.assessmentRepository.findOne(this.savedAssessment.getId());
        retrievedAssessment.setLocked(true);
        final Assessment reSavedAssessment = this.assessmentRepository.save(retrievedAssessment);
        assertThat(reSavedAssessment.isLocked(), is(true));

        try {
            this.affinityGroupService.removeAffinityGroupValueGroup(this.savedAssessment.getId(), segmentId);
            fail("exception should be thrown when trying to save affinityGroup data for an already locked assessment");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("cannot.be.altered.assessment.locked"));
        }
    }

    @Test
    public void attachItemsToAffinityGroupTest() {
        final AffinityGroup groupA = addAffinityGroup(this.savedAssessment, "groupA");
        final AffinityGroup groupB = addAffinityGroup(this.savedAssessment, "groupB");

        addAdaptiveItem(this.savedAdaptiveSegment.getId(), "APIP_5000", "NO_GROUP");
        addAdaptiveItem(this.savedAdaptiveSegment.getId(), "APIP_5001", "NO_GROUP");
        addAdaptiveItem(this.savedAdaptiveSegment.getId(), "APIP_5002", "NO_GROUP");

        assertNumberOfAffinityGroupsInAssessment(this.savedAssessment, 2);
        assertNumberOfItemsInAffinityGroup(groupA, 0);
        assertNumberOfItemsInAffinityGroup(groupB, 0);
        assertNumberOfItemsInSegment(this.savedAdaptiveSegment, 3);

        final ItemMoveResponse response = affinityGroupService.attachItemsToAffinityGroup(groupA.getId(), ImmutableList.of("APIP_5000", "APIP_5001", "APIP_5002"));
        assertThat(response.getItemsImpacted(), is(3));
        assertThat(response.getItemsOmitted(), is(0));
        assertNumberOfAffinityGroupsInAssessment(this.savedAssessment, 2);
        assertNumberOfItemsInAffinityGroup(groupA, 3);
        assertNumberOfItemsInAffinityGroup(groupB, 0);
        assertNumberOfItemsInSegment(this.savedAdaptiveSegment, 3);
    }

    @Test
    public void attachItemsToAffinityGroupWithInvalidGroupIdTest() {
        try {
            affinityGroupService.attachItemsToAffinityGroup("invalid-id", ImmutableList.of("APIP_5000", "APIP_5001", "APIP_5002"));
            fail("exception should be thrown");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("affinityGroup.id.invalid"));
        }
    }

    @Test
    public void attachItemsToAffinityGroupWithMissingItemsTest() {
        final AffinityGroup groupA = addAffinityGroup(this.savedAssessment, "groupA");
        final AffinityGroup groupB = addAffinityGroup(this.savedAssessment, "groupB");

        assertNumberOfAffinityGroupsInAssessment(this.savedAssessment, 2);
        assertNumberOfItemsInAffinityGroup(groupA, 0);
        assertNumberOfItemsInAffinityGroup(groupB, 0);
        assertNumberOfItemsInSegment(this.savedAdaptiveSegment, 0);

        final ItemMoveResponse response = affinityGroupService.attachItemsToAffinityGroup(groupA.getId(), ImmutableList.of("APIP_5000", "APIP_5001", "APIP_5002"));
        assertThat(response.getItemsImpacted(), is(0));
        assertThat(response.getItemsOmitted(), is(3));
        assertNumberOfAffinityGroupsInAssessment(this.savedAssessment, 2);
        assertNumberOfItemsInAffinityGroup(groupA, 0);
        assertNumberOfItemsInAffinityGroup(groupB, 0);
        assertNumberOfItemsInSegment(this.savedAdaptiveSegment, 0);
    }

    @Test
    public void attachItemsToAffinityGroupWithAlreadyAttachedItemsTest() {
        final AffinityGroup groupA = addAffinityGroup(this.savedAssessment, "groupA");
        final AffinityGroup groupB = addAffinityGroup(this.savedAssessment, "groupB");

        addAdaptiveItem(this.savedAdaptiveSegment.getId(), "APIP_5000", "NO_GROUP");
        addAdaptiveItem(this.savedAdaptiveSegment.getId(), "APIP_5001", "NO_GROUP");
        addAdaptiveItem(this.savedAdaptiveSegment.getId(), "APIP_5002", "NO_GROUP");

        assertNumberOfAffinityGroupsInAssessment(this.savedAssessment, 2);
        assertNumberOfItemsInAffinityGroup(groupA, 0);
        assertNumberOfItemsInAffinityGroup(groupB, 0);
        assertNumberOfItemsInSegment(this.savedAdaptiveSegment, 3);

        ItemMoveResponse response = affinityGroupService.attachItemsToAffinityGroup(groupA.getId(), ImmutableList.of("APIP_5000"));
        assertThat(response.getItemsImpacted(), is(1));
        assertThat(response.getItemsOmitted(), is(0));
        assertNumberOfAffinityGroupsInAssessment(this.savedAssessment, 2);
        assertNumberOfItemsInAffinityGroup(groupA, 1);
        assertNumberOfItemsInAffinityGroup(groupB, 0);
        assertNumberOfItemsInSegment(this.savedAdaptiveSegment, 3);

        response = affinityGroupService.attachItemsToAffinityGroup(groupA.getId(), ImmutableList.of("APIP_5000", "APIP_5001", "APIP_5002"));
        assertThat(response.getItemsImpacted(), is(2));
        assertThat(response.getItemsOmitted(), is(1));
        assertNumberOfAffinityGroupsInAssessment(this.savedAssessment, 2);
        assertNumberOfItemsInAffinityGroup(groupA, 3);
        assertNumberOfItemsInAffinityGroup(groupB, 0);
        assertNumberOfItemsInSegment(this.savedAdaptiveSegment, 3);
    }

    @Test
    public void detachItemsFromAffinityGroupTest() {
        final AffinityGroup groupA = addAffinityGroup(this.savedAssessment, "groupA");
        final AffinityGroup groupB = addAffinityGroup(this.savedAssessment, "groupB");

        addAdaptiveItem(this.savedAdaptiveSegment.getId(), "APIP_5000", "NO_GROUP");
        addAdaptiveItem(this.savedAdaptiveSegment.getId(), "APIP_5001", "NO_GROUP");
        addAdaptiveItem(this.savedAdaptiveSegment.getId(), "APIP_5002", "NO_GROUP");
        affinityGroupService.attachItemsToAffinityGroup(groupA.getId(), ImmutableList.of("APIP_5000", "APIP_5001", "APIP_5002"));
        affinityGroupService.attachItemsToAffinityGroup(groupB.getId(), ImmutableList.of("APIP_5000", "APIP_5001", "APIP_5002"));

        assertNumberOfAffinityGroupsInAssessment(this.savedAssessment, 2);
        assertNumberOfItemsInAffinityGroup(groupA, 3);
        assertNumberOfItemsInAffinityGroup(groupB, 3);
        assertNumberOfItemsInSegment(this.savedAdaptiveSegment, 3);

        final ItemMoveResponse response = affinityGroupService.detachItemsFromAffinityGroup(groupB.getId(), ImmutableList.of("APIP_5000", "APIP_5001", "APIP_5002"));
        assertThat(response.getItemsImpacted(), is(3));
        assertThat(response.getItemsOmitted(), is(0));
        assertNumberOfAffinityGroupsInAssessment(this.savedAssessment, 2);
        assertNumberOfItemsInAffinityGroup(groupA, 3);
        assertNumberOfItemsInAffinityGroup(groupB, 0);
        assertNumberOfItemsInSegment(this.savedAdaptiveSegment, 3);
    }

    @Test
    public void detachItemsFromAffinityGroupWithInvalidGroupIdTest() {
        try {
            affinityGroupService.detachItemsFromAffinityGroup("invalid-id", ImmutableList.of("APIP_5000", "APIP_5001", "APIP_5002"));
            fail("exception should be thrown");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("affinityGroup.id.invalid"));
        }
    }

    @Test
    public void detachItemsFromAffinityGroupWithMissingItemsTest() {
        final AffinityGroup groupA = addAffinityGroup(this.savedAssessment, "groupA");
        final AffinityGroup groupB = addAffinityGroup(this.savedAssessment, "groupB");

        final ItemMoveResponse response = affinityGroupService.detachItemsFromAffinityGroup(groupB.getId(), ImmutableList.of("APIP_5000", "APIP_5001", "APIP_5002"));
        assertThat(response.getItemsImpacted(), is(0));
        assertThat(response.getItemsOmitted(), is(3));
        assertNumberOfAffinityGroupsInAssessment(this.savedAssessment, 2);
        assertNumberOfItemsInAffinityGroup(groupA, 0);
        assertNumberOfItemsInAffinityGroup(groupB, 0);
        assertNumberOfItemsInSegment(this.savedAdaptiveSegment, 0);
    }

    @Test
    public void detachItemsFromAffinityGroupWithAlreadyDetachedItemsTest() {
        final AffinityGroup groupA = addAffinityGroup(this.savedAssessment, "groupA");
        final AffinityGroup groupB = addAffinityGroup(this.savedAssessment, "groupB");

        addAdaptiveItem(this.savedAdaptiveSegment.getId(), "APIP_5000", "NO_GROUP");
        addAdaptiveItem(this.savedAdaptiveSegment.getId(), "APIP_5001", "NO_GROUP");
        addAdaptiveItem(this.savedAdaptiveSegment.getId(), "APIP_5002", "NO_GROUP");
        affinityGroupService.attachItemsToAffinityGroup(groupA.getId(), ImmutableList.of("APIP_5000", "APIP_5001", "APIP_5002"));
        affinityGroupService.attachItemsToAffinityGroup(groupB.getId(), ImmutableList.of("APIP_5000", "APIP_5001", "APIP_5002"));

        assertNumberOfAffinityGroupsInAssessment(this.savedAssessment, 2);
        assertNumberOfItemsInAffinityGroup(groupA, 3);
        assertNumberOfItemsInAffinityGroup(groupB, 3);
        assertNumberOfItemsInSegment(this.savedAdaptiveSegment, 3);

        ItemMoveResponse response = affinityGroupService.detachItemsFromAffinityGroup(groupB.getId(), ImmutableList.of("APIP_5000"));
        assertThat(response.getItemsImpacted(), is(1));
        assertThat(response.getItemsOmitted(), is(0));
        assertNumberOfAffinityGroupsInAssessment(this.savedAssessment, 2);
        assertNumberOfItemsInAffinityGroup(groupA, 3);
        assertNumberOfItemsInAffinityGroup(groupB, 2);
        assertNumberOfItemsInSegment(this.savedAdaptiveSegment, 3);

        response = affinityGroupService.detachItemsFromAffinityGroup(groupB.getId(), ImmutableList.of("APIP_5000", "APIP_5001", "APIP_5002"));
        assertThat(response.getItemsImpacted(), is(2));
        assertThat(response.getItemsOmitted(), is(1));
        assertNumberOfAffinityGroupsInAssessment(this.savedAssessment, 2);
        assertNumberOfItemsInAffinityGroup(groupA, 3);
        assertNumberOfItemsInAffinityGroup(groupB, 0);
        assertNumberOfItemsInSegment(this.savedAdaptiveSegment, 3);
    }

    @Test
    public void saveAffinityGroupListWithNullInputWorks() {
        this.affinityGroupService.updateAffinityGroupList(null);
        assertThat(this.affinityGroupRepository.findAll().size(), is(0));
    }

    @Test
    public void saveAffinityGroupListWithEmptyInputWorks() {
        this.affinityGroupService.updateAffinityGroupList(new ArrayList<AffinityGroup>());
        assertThat(this.affinityGroupRepository.findAll().size(), is(0));
    }

    private List<AffinityGroup> saveAffinityGroupList(final List<AffinityGroup> affinityGroupList) {
        final List<AffinityGroup> savedGroups = new ArrayList<AffinityGroup>();
        for (final AffinityGroup group : affinityGroupList) {
            savedGroups.add(affinityGroupService.saveNewAffinityGroup(group));
        }
        return savedGroups;
    }

}
