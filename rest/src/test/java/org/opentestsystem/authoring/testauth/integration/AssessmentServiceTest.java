/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.integration;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.not;
import static org.hamcrest.CoreMatchers.notNullValue;
import static org.hamcrest.CoreMatchers.nullValue;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.when;

import java.util.List;
import java.util.Map;

import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.authoring.testauth.config.TestAuthUtil;
import org.opentestsystem.authoring.testauth.domain.AdaptiveItemLocation;
import org.opentestsystem.authoring.testauth.domain.Assessment;
import org.opentestsystem.authoring.testauth.domain.BlueprintElement;
import org.opentestsystem.authoring.testauth.domain.BlueprintReferenceType;
import org.opentestsystem.authoring.testauth.domain.ComputationRule;
import org.opentestsystem.authoring.testauth.domain.ComputationRuleMultiplicityType;
import org.opentestsystem.authoring.testauth.domain.ComputationRuleParameter;
import org.opentestsystem.authoring.testauth.domain.ComputationRuleType;
import org.opentestsystem.authoring.testauth.domain.ConversionTableType;
import org.opentestsystem.authoring.testauth.domain.DomainFactory;
import org.opentestsystem.authoring.testauth.domain.FixedFormItemLocation;
import org.opentestsystem.authoring.testauth.domain.Form;
import org.opentestsystem.authoring.testauth.domain.FormPartition;
import org.opentestsystem.authoring.testauth.domain.Item;
import org.opentestsystem.authoring.testauth.domain.ItemLocation;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionAlgorithm;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionAlgorithmType;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionPurpose;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionType;
import org.opentestsystem.authoring.testauth.domain.PerformanceLevel;
import org.opentestsystem.authoring.testauth.domain.Publication;
import org.opentestsystem.authoring.testauth.domain.PublishingRecord;
import org.opentestsystem.authoring.testauth.domain.ReportingMeasure;
import org.opentestsystem.authoring.testauth.domain.ScoringRule;
import org.opentestsystem.authoring.testauth.domain.ScoringRuleParameter;
import org.opentestsystem.authoring.testauth.domain.Segment;
import org.opentestsystem.authoring.testauth.domain.Subject;
import org.opentestsystem.authoring.testauth.rest.AbstractRestEmbeddedMongoTest;
import org.opentestsystem.authoring.testauth.service.AssessmentService;
import org.opentestsystem.authoring.testauth.service.BlueprintElementService;
import org.opentestsystem.authoring.testauth.service.ComputationRuleService;
import org.opentestsystem.authoring.testauth.service.FormPartitionService;
import org.opentestsystem.authoring.testauth.service.FormService;
import org.opentestsystem.authoring.testauth.service.ItemSelectionAlgorithmService;
import org.opentestsystem.authoring.testauth.service.ItemService;
import org.opentestsystem.authoring.testauth.service.PerformanceLevelService;
import org.opentestsystem.authoring.testauth.service.PublicationService;
import org.opentestsystem.authoring.testauth.service.PublishingRecordService;
import org.opentestsystem.authoring.testauth.service.ReportingMeasureService;
import org.opentestsystem.authoring.testauth.service.ScoringRuleService;
import org.opentestsystem.authoring.testauth.service.SegmentService;
import org.opentestsystem.authoring.testauth.service.SubjectService;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.progman.client.ProgManClient;
import org.opentestsystem.shared.progman.client.domain.Tenant;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.springframework.beans.factory.annotation.Autowired;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;

public class AssessmentServiceTest extends AbstractRestEmbeddedMongoTest {

    @Autowired
    private AssessmentService assessmentService;

    @Autowired
    private ItemSelectionAlgorithmService itemSelectionAlgorithmService;

    @Autowired
    private SegmentService segmentService;

    @Autowired
    private ItemService itemService;

    @Autowired
    private PublicationService publicationService;

    @Autowired
    private SubjectService subjectService;

    @Autowired
    private BlueprintElementService blueprintElementService;

    @Autowired
    private ComputationRuleService computationRuleService;

    @Autowired
    private ScoringRuleService scoringRuleService;

    @Autowired
    private FormService formService;

    @Autowired
    private FormPartitionService formPartitionService;

    @Autowired
    private PerformanceLevelService performanceLevelService;

    @Autowired
    private ReportingMeasureService reportingMeasureService;

    @Autowired
    private PublishingRecordService publishingRecordService;

    @Autowired
    private ProgManClient progManClient; // mocked client

    private Publication savedPublication;
    private Subject savedSubject;

    @Before
    public void setupTestData() {
        this.savedSubject = this.subjectService.saveSubject(DomainFactory.manufactureValidSubject("ABB"));
        final Publication publication = DomainFactory.manufactureValidPublication(savedSubject.getTenantId(), ImmutableSet.of(savedSubject));

        publication.setCoreStandardsPublisherKey("csPublisherKey");
        this.savedPublication = this.publicationService.savePublication(publication);
    }

    @Test
    public void saveNewAssessmentTest() {
        final Assessment assessmentToSave = DomainFactory.manufactureValidAssessment(this.savedSubject, this.savedPublication);
        final Assessment savedAssessment = this.assessmentService.saveAssessment(assessmentToSave);
        assertThat(savedAssessment, is(notNullValue()));
        final Assessment retrievedAssessment = this.assessmentService.getAssessment(savedAssessment.getId());
        assertThat(retrievedAssessment, is(notNullValue()));

        final SearchResponse<Segment> searchResponse = this.segmentService.searchSegments(ImmutableMap.of("assessmentId", new String[] { savedAssessment.getId() }));
        assertThat(searchResponse.getReturnCount(), is(0)); // no new segment should be saved for new assessments
    }

    @Test
    public void saveExistingAssessmentTest() {
        final Assessment assessmentToSave = DomainFactory.manufactureValidAssessment(this.savedSubject, this.savedPublication);
        final Assessment savedAssessment = this.assessmentService.saveAssessment(assessmentToSave);

        final Assessment resavedAssessment = this.assessmentService.updateAssessment(savedAssessment);
        assertThat(resavedAssessment, is(notNullValue()));
        final Assessment retrievedAssessment = this.assessmentService.getAssessment(resavedAssessment.getId());
        assertThat(retrievedAssessment, is(notNullValue()));

        final SearchResponse<Segment> searchResponse = this.segmentService.searchSegments(ImmutableMap.of("assessmentId", new String[] { resavedAssessment.getId() }));
        assertThat(searchResponse.getReturnCount(), is(0)); // no new segment should be saved for pre-existing assessments
    }

    @Test
    public void saveAssessmentWithMultipleGradesTest() {
        final Assessment assessmentToSave = DomainFactory.manufactureValidAssessment(this.savedSubject, this.savedPublication);
        assessmentToSave.setGrade(new String[] { "5", "10", "4", "1" });
        final Assessment savedAssessment = this.assessmentService.saveAssessment(assessmentToSave);

        assertThat(savedAssessment, is(notNullValue()));
        assertThat(savedAssessment.getGrade(), is(equalTo(new String[] { "1", "10", "4", "5" })));
        assertThat(savedAssessment.getName().contains("1_10_4_5"), is(true));
    }

    @Test
    public void searchAssessments() {
        final Assessment assessmentToSave = DomainFactory.manufactureValidAssessment(this.savedSubject, this.savedPublication);
        assessmentToSave.setTenantId("1");
        final Assessment savedAssessment = this.assessmentService.saveAssessment(assessmentToSave);
        assertThat(savedAssessment, is(not(nullValue())));

        final Assessment assessmentToSave2 = DomainFactory.manufactureValidAssessment(this.savedSubject, this.savedPublication);
        assessmentToSave2.setTenantId("2");
        final Assessment savedAssessment2 = this.assessmentService.saveAssessment(assessmentToSave2);
        assertThat(savedAssessment2, is(not(nullValue())));

        final Map<String, String[]> params = ImmutableMap.of("label", new String[] { savedAssessment.getLabel() }, "tenantId", new String[] { savedAssessment.getTenantId() });
        final SearchResponse<Assessment> searchResponse = this.assessmentService.searchAssessments(params);
        assertThat(searchResponse.getReturnCount(), is(1));
        assertThat(searchResponse.getSearchResults().size(), is(1));
    }

    @Test
    public void checkForPublicationInUseByAssessment() {
        final Assessment assessmentToSave = DomainFactory.manufactureValidAssessment(this.savedSubject, this.savedPublication);
        assessmentToSave.setTenantId("1");
        final Assessment savedAssessment = this.assessmentService.saveAssessment(assessmentToSave);
        assertThat(savedAssessment, is(not(nullValue())));

        final Assessment assessmentToSave2 = DomainFactory.manufactureValidAssessment(this.savedSubject, this.savedPublication);
        assessmentToSave2.setTenantId("2");
        final Assessment savedAssessment2 = this.assessmentService.saveAssessment(assessmentToSave2);
        assertThat(savedAssessment2, is(not(nullValue())));

        Map<String, String[]> params = ImmutableMap.of("publicationId", new String[] { savedAssessment.getPublicationId() }, "tenantId", new String[] { savedAssessment.getTenantId() });
        final SearchResponse<Assessment> searchResponse = this.assessmentService.searchAssessments(params);
        assertThat(searchResponse.getReturnCount(), is(1));
        assertThat(searchResponse.getSearchResults().size(), is(1));

        params = ImmutableMap.of("publicationId", new String[] { "fresh.publication.id" }, "tenantId", new String[] { savedAssessment.getTenantId() });
        final SearchResponse<Assessment> freshSearchResponse = this.assessmentService.searchAssessments(params);
        assertThat(freshSearchResponse.getReturnCount(), is(0));
        assertThat(freshSearchResponse.getSearchResults().size(), is(0));
    }

    @Test
    public void removeAssessmentTest() {
        final Assessment assessmentToSave = DomainFactory.manufactureValidAssessment(this.savedSubject, this.savedPublication);
        final Assessment savedAssessment = this.assessmentService.saveAssessment(assessmentToSave);
        assertThat(savedAssessment, is(notNullValue()));

        final ItemSelectionAlgorithm algorithmToSave = DomainFactory.manufactureValidItemSelectionAlgorithm(ItemSelectionPurpose.SCALAR, ItemSelectionType.BOOLEAN);
        algorithmToSave.setItemSelectionAlgorithmType(ItemSelectionAlgorithmType.ADAPTIVE);
        final ItemSelectionAlgorithm savedAlgorithm = this.itemSelectionAlgorithmService.createItemSelectionAlgorithm(algorithmToSave);
        final Segment segmentToSave = DomainFactory.manufactureValidSegment(savedAssessment.getId(), savedAlgorithm, 1);
        this.segmentService.createSegment(segmentToSave);

        final SearchResponse<Segment> segmentSearchResponse = this.segmentService.searchSegments(ImmutableMap.of("assessmentId", new String[] { savedAssessment.getId() }));
        assertThat(segmentSearchResponse.getSearchResults().size(), is(1));

        this.assessmentService.removeAssessment(savedAssessment.getId());

        final Assessment retrievedAssessment = this.assessmentService.getAssessment(savedAssessment.getId());
        assertThat(retrievedAssessment, is(nullValue()));

        final SearchResponse<Segment> segmentSearchResponse2 = this.segmentService.searchSegments(ImmutableMap.of("assessmentId", new String[] { savedAssessment.getId() }));
        assertThat(segmentSearchResponse2.getSearchResults().size(), is(0));
    }

    @Test
    public void removePublishedAssessmentTest() {
        final Assessment assessmentToSave = DomainFactory.manufactureValidAssessment(this.savedSubject, this.savedPublication);
        final Assessment savedAssessment = this.assessmentService.saveAssessment(assessmentToSave);
        assertThat(savedAssessment, is(notNullValue()));

        saveGoodMinimalSegmentAndItemData(savedAssessment);
        saveGoodMinimalBlueprintData(savedAssessment);

        final Tenant tenant1 = buildTenant("id1", "tenant1", "description1");
        when(this.progManClient.getTenantById(savedAssessment.getTenantId())).thenReturn(tenant1);
        PublishingRecord publishingRecord = this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(savedAssessment.getId());
        publishingRecord = this.publishingRecordService.savePublishingRecord(publishingRecord, false);
        this.publishingRecordService.savePublishingRecord(publishingRecord, false);

        try {
            this.assessmentService.removeAssessment(savedAssessment.getId());
            fail("exception should be thrown when trying to remove a locked assessment");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is(notNullValue()));
        }
    }

    @Test
    public void saveExistingPublishedAssessmentTest() {
        final Assessment assessmentToSave = DomainFactory.manufactureValidAssessment(this.savedSubject, this.savedPublication);
        final Assessment savedAssessment = this.assessmentService.saveAssessment(assessmentToSave);
        assertThat(savedAssessment, is(notNullValue()));

        saveGoodMinimalSegmentAndItemData(savedAssessment);
        saveGoodMinimalBlueprintData(savedAssessment);

        final Tenant tenant1 = buildTenant("id1", "tenant1", "description1");
        when(this.progManClient.getTenantById(savedAssessment.getTenantId())).thenReturn(tenant1);

        assertThat(savedAssessment, is(notNullValue()));
        PublishingRecord publishingRecord = this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(savedAssessment.getId());
        publishingRecord = this.publishingRecordService.savePublishingRecord(publishingRecord, false);
        this.publishingRecordService.savePublishingRecord(publishingRecord, false);

        final Assessment reresavedAssessment = this.assessmentService.getAssessment(savedAssessment.getId());
        assertThat(reresavedAssessment.isLocked(), is(true));
        reresavedAssessment.setLabel("newLabel");
        try {
            this.assessmentService.updateAssessment(reresavedAssessment);
            fail("exception should be thrown when trying to save an already locked assessment");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("assessment.published.cannot.be.altered"));
        }
    }

    @Test
    public void copyExistingPublishedAssessmentTest() {
        final Assessment assessmentToSave = DomainFactory.manufactureValidAssessment(this.savedSubject, this.savedPublication);
        final Assessment savedAssessment = this.assessmentService.saveAssessment(assessmentToSave);
        assertThat(savedAssessment, is(notNullValue()));

        saveGoodMinimalSegmentAndItemData(savedAssessment);
        buildValidFixedFormData(savedAssessment);
        saveGoodMinimalBlueprintData(savedAssessment);
        final ScoringRule scoringRule = saveGoodMinimalScoringRuleData(savedAssessment);
        saveGoodMinimalPerformanceLevelData(savedAssessment);
        saveGoodMinimalReportingMeasureData(scoringRule, savedAssessment);

        final Tenant tenant1 = buildTenant("id1", "tenant1", "description1");
        when(this.progManClient.getTenantById(savedAssessment.getTenantId())).thenReturn(tenant1);

        assertThat(savedAssessment, is(notNullValue()));

        final Assessment copiedAssessment = this.assessmentService.copyAssessment(savedAssessment.getId());
        assertThat(copiedAssessment, is(notNullValue()));
    }

    private void saveGoodMinimalSegmentAndItemData(final Assessment savedAssessment) {
        final ItemSelectionAlgorithm algorithmToSave = DomainFactory.manufactureValidItemSelectionAlgorithm(ItemSelectionPurpose.SCALAR, ItemSelectionType.BOOLEAN);
        algorithmToSave.setItemSelectionAlgorithmType(ItemSelectionAlgorithmType.ADAPTIVE);
        final ItemSelectionAlgorithm savedAlgorithm = this.itemSelectionAlgorithmService.createItemSelectionAlgorithm(algorithmToSave);
        final Segment savedSegment = this.segmentService.createSegment(DomainFactory.manufactureValidSegment(savedAssessment.getId(), savedAlgorithm, 1));
        buildItemsForSegment(savedAssessment, 12, savedSegment.getId());
    }

    private ScoringRule saveGoodMinimalScoringRuleData(final Assessment savedAssessment) {
        final ComputationRule computationRule = new ComputationRule();
        computationRule.setConversionTableType(ConversionTableType.NONE);
        computationRule.setName("name");
        computationRule.setVersion("1.0");
        final ComputationRuleParameter computationRuleParameter = new ComputationRuleParameter();
        computationRuleParameter.setParameterName("parameterName");
        computationRuleParameter.setComputationRuleType(ComputationRuleType.STRING);
        computationRuleParameter.setDefaultValue("defaultValue");
        computationRuleParameter.setComputationRuleMultiplicityType(ComputationRuleMultiplicityType.SCALAR);
        computationRuleParameter.setPosition(1);
        computationRule.setParameters(ImmutableList.of(computationRuleParameter));
        final ComputationRule savedComputationRule = this.computationRuleService.createComputationRule(computationRule);
        final ScoringRule scoringRule = new ScoringRule();
        scoringRule.setAssessmentId(savedAssessment.getId());
        scoringRule.setLabel("label");
        scoringRule.setOrder(1);
        scoringRule.setComputationRuleId(savedComputationRule.getId());
        scoringRule.setBlueprintReferenceType(BlueprintReferenceType.SEGMENT);
        final Segment savedSegment = this.segmentService.searchSegments(TestAuthUtil.searchParamsByAssessmentIdSmall(savedAssessment.getId())).getSearchResults().get(0);
        scoringRule.setBlueprintReferenceId(savedSegment.getId());
        final ScoringRuleParameter scoringRuleParameter = new ScoringRuleParameter();
        scoringRuleParameter.setComputationRuleParameterName(computationRuleParameter.getParameterName());
        scoringRuleParameter.setComputationRuleParameterMultiplicity(ComputationRuleMultiplicityType.SCALAR);
        scoringRuleParameter.setScalarValue("scalarValue");
        scoringRule.setParameters(ImmutableList.of(scoringRuleParameter));
        return this.scoringRuleService.saveScoringRule(null, scoringRule);
    }

    private void saveGoodMinimalBlueprintData(final Assessment savedAssessment) {
        final List<Segment> segments = this.segmentService.findSegmentListByAssessmentId(savedAssessment.getId());
        this.segmentService.loadReferenceData(segments);
        final BlueprintElement bpe = DomainFactory.manufactureValidBlueprintElement(savedAssessment.getId(), segments);
        bpe.setGrade(savedAssessment.getGrade()[0]);
        bpe.setLevel("1");
        bpe.setStandardKey("CC-ELA-v1");
        bpe.setTextDescription("textDescription");
        bpe.setActive(true);
        this.blueprintElementService.saveBlueprintElement(null, bpe);
    }

    private void saveGoodMinimalPerformanceLevelData(final Assessment savedAssessment) {
        final PerformanceLevel performanceLevel = DomainFactory.manufactureValidPerformanceLevel(savedAssessment.getId());
        this.performanceLevelService.savePerformanceLevel(null, performanceLevel);
    }

    private void saveGoodMinimalReportingMeasureData(final ScoringRule scoringRule, final Assessment savedAssessment) {
        final ReportingMeasure reportingMeasure = manufactureValidReportingMeasure(savedAssessment.getId(), scoringRule);
        this.reportingMeasureService.saveReportingMeasure(null, reportingMeasure);
    }

    private void buildValidFixedFormData(final Assessment savedAssessment) {
        final ItemSelectionAlgorithm algorithm = DomainFactory.manufactureValidItemSelectionAlgorithm(ItemSelectionPurpose.SCALAR, ItemSelectionType.BOOLEAN);
        algorithm.setItemSelectionAlgorithmType(ItemSelectionAlgorithmType.FIXEDFORM);
        final ItemSelectionAlgorithm savedAlgorithm2 = this.itemSelectionAlgorithmService.createItemSelectionAlgorithm(algorithm);

        final Segment savedSegment2 = this.segmentService.createSegment(DomainFactory.manufactureValidSegment(savedAssessment.getId(), savedAlgorithm2, 2));
        final Segment savedSegment3 = this.segmentService.createSegment(DomainFactory.manufactureValidSegment(savedAssessment.getId(), savedAlgorithm2, 3));

        final Form savedForm = this.formService.saveForm(null, DomainFactory.manufactureValidForm(savedAssessment.getId()));

        final FormPartition savedFormPartition = this.formPartitionService.saveFormPartition(null,
                DomainFactory.manufactureValidFormPartition(savedAssessment.getId(), "partition1", savedForm.getId(), savedSegment2.getId()));
        final FormPartition savedFormPartition2 = this.formPartitionService.saveFormPartition(null,
                DomainFactory.manufactureValidFormPartition(savedAssessment.getId(), "partition2", savedForm.getId(), savedSegment3.getId()));

        buildItemsForPartition(savedAssessment, 12, savedFormPartition.getId(), savedFormPartition2.getId());
    }

    private void buildItemsForPartition(final Assessment savedAssessment, final int itemsToBuild, final String... partitionIdList) {
        for (int i = 0; i < itemsToBuild; i++) {
            final Item item = DomainFactory.manufactureValidItem(savedAssessment.getId());
            item.setId(null);
            final List<ItemLocation> itemLocationList = Lists.newArrayList();
            for (final String partitionId : partitionIdList) {
                itemLocationList.add(new FixedFormItemLocation(partitionId, null, i + 1, 1));
            }
            item.setItemLocation(itemLocationList);
            this.itemService.saveItem(item);
        }
    }

    private void buildItemsForSegment(final Assessment savedAssessment, final int itemsToBuild, final String... segmentIdList) {
        for (int i = 0; i < itemsToBuild; i++) {
            final Item item = DomainFactory.manufactureValidItem(savedAssessment.getId());
            item.setId(null);
            final List<ItemLocation> itemLocationList = Lists.newArrayList();
            for (final String segmentId : segmentIdList) {
                itemLocationList.add(new AdaptiveItemLocation(segmentId, null, 0, 0));
            }
            item.setItemLocation(itemLocationList);
            this.itemService.saveItem(item);
        }
    }

    private ReportingMeasure manufactureValidReportingMeasure(final String assessmentId, final ScoringRule scoringRule) {
        final ReportingMeasure reportingMeasure = new ReportingMeasure();
        reportingMeasure.setId(null);
        reportingMeasure.setBlueprintReferenceType(scoringRule.getBlueprintReferenceType());
        reportingMeasure.setBlueprintReferenceId(scoringRule.getBlueprintReferenceId());
        reportingMeasure.setAssessmentId(assessmentId);
        reportingMeasure.setScoringRuleIdList(Lists.newArrayList(scoringRule.getId()));
        return reportingMeasure;
    }
}
