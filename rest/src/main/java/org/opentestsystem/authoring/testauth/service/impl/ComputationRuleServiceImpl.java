/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.service.impl;

import java.util.Map;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.opentestsystem.authoring.testauth.domain.ComputationRule;
import org.opentestsystem.authoring.testauth.domain.search.ComputationRuleSearchRequest;
import org.opentestsystem.authoring.testauth.persistence.ComputationRuleRepository;
import org.opentestsystem.authoring.testauth.persistence.ScoringRuleRepository;
import org.opentestsystem.authoring.testauth.service.ComputationRuleService;
import org.opentestsystem.authoring.testauth.service.ScoringRuleService;
import org.opentestsystem.authoring.testauth.validation.ComputationRuleValidator;
import org.opentestsystem.authoring.testauth.validation.ValidationHelper;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.exception.RestException;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.stereotype.Service;
import org.springframework.validation.BeanPropertyBindingResult;
import org.springframework.validation.BindingResult;

@Service
public class ComputationRuleServiceImpl implements ComputationRuleService {

    private static final Logger LOGGER = LoggerFactory.getLogger(ComputationRuleServiceImpl.class);

    @Autowired
    private transient ComputationRuleValidator computationRuleValidator;

    @Autowired
    private transient ComputationRuleRepository computationRuleRepository;

    @Autowired
    private transient ScoringRuleService scoringRuleService;

    @Autowired
    private transient ScoringRuleRepository scoringRuleRepository;

    @Override
    public ComputationRule createComputationRule(final ComputationRule computationRule) {
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("Saving computationRule");
        }
        if (computationRule == null || StringUtils.isNotEmpty(computationRule.getId())) {
            throw new LocalizedException("computationRule.invalid.id");
        }

        validateComputationRule(computationRule);

        ComputationRule savedComputationRule = null;
        try {
            savedComputationRule = this.computationRuleRepository.save(computationRule);
        } catch (final DuplicateKeyException dke) {
            throw new LocalizedException("computationRule.already.exists", new String[] { computationRule.getName(), computationRule.getVersion() }, dke);
        }
        return savedComputationRule;
    }

    @Override
    public ComputationRule updateComputationRule(final ComputationRule computationRule) {
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("Updating computationRule");
        }
        if (computationRule == null || StringUtils.isEmpty(computationRule.getId())) {
            throw new LocalizedException("computationRule.invalid.id");
        }

        verifyUpdateAllowed(computationRule.getId());

        validateComputationRule(computationRule);

        ComputationRule savedComputationRule = null;
        try {
            savedComputationRule = this.computationRuleRepository.save(computationRule);
        } catch (final DuplicateKeyException dke) {
            throw new LocalizedException("computationRule.already.exists", new String[] { computationRule.getName(), computationRule.getVersion() }, dke);
        }
        return savedComputationRule;
    }

    private void validateComputationRule(final ComputationRule computationRule) {
        final BindingResult bindingResult = new BeanPropertyBindingResult(computationRule, "computationRule");
        this.computationRuleValidator.validate(computationRule, bindingResult);
        if (bindingResult.hasErrors()) {
            throw ValidationHelper.convertErrorsToConstraintException(computationRule, bindingResult);
        }
    }

    @Override
    public ComputationRule getComputationRule(final String computationRuleId) {
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("Finding computationRule for Id: " + computationRuleId);
        }
        final ComputationRule computationRule = this.computationRuleRepository.findOne(computationRuleId);
        if (computationRule != null) {
            computationRule.setCanEdit(verifyCanEdit(computationRule.getId()));
        }
        return computationRule;
    }

    @Override
    public void removeComputationRule(final String computationRuleId) {
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("Removing computationRule with Id:" + computationRuleId);
        }
        if (computationRuleId != null) {
            verifyUpdateAllowed(computationRuleId);
        }
        this.computationRuleRepository.delete(computationRuleId);
    }

    @Override
    public SearchResponse<ComputationRule> searchComputationRules(final Map<String, String[]> parameterMap) {
        final ComputationRuleSearchRequest searchRequest = new ComputationRuleSearchRequest(parameterMap);
        if (searchRequest.isValid()) {
            final SearchResponse<ComputationRule> searchResponse = this.computationRuleRepository.search(searchRequest);
            for (final ComputationRule computationRule : searchResponse.getSearchResults()) {
                computationRule.setCanEdit(verifyCanEdit(computationRule.getId()));
            }
            return searchResponse;
        }
        throw new RestException("computationRule.search.invalidSearchCriteria");
    }

    private void verifyUpdateAllowed(final String computationRuleId) {
        if (!verifyCanEdit(computationRuleId)) {
            throw new LocalizedException("computationRule.cannot.be.altered");
        }
    }

    private boolean verifyCanEdit(final String computationRuleId) {
        return CollectionUtils.isEmpty(this.scoringRuleService.getScoringRulesByComputationRuleId(computationRuleId));
    }
}
