/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.integration;

import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.MatcherAssert.assertThat;

import org.junit.Test;
import org.opentestsystem.authoring.testauth.domain.Assessment;
import org.opentestsystem.authoring.testauth.domain.Publication;
import org.opentestsystem.authoring.testauth.domain.Subject;
import org.opentestsystem.authoring.testauth.persistence.AssessmentCounterRepository;
import org.opentestsystem.authoring.testauth.rest.AbstractRestEmbeddedMongoTest;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.util.ReflectionUtils;

public class AssessmentCounterRepositoryTest extends AbstractRestEmbeddedMongoTest {

    @Autowired
    private AssessmentCounterRepository assessmentCounterRepository;

    @Test
    public void findAndUpdateNextAssessmentNameSequenceTest() {
        final Assessment assessment1 = PODAM_FACTORY.manufacturePojo(Assessment.class);
        assessment1.setPublication(PODAM_FACTORY.manufacturePojo(Publication.class));
        assessment1.setSubject(PODAM_FACTORY.manufacturePojo(Subject.class));
        final Assessment assessment2 = PODAM_FACTORY.manufacturePojo(Assessment.class);
        assessment2.setPublication(PODAM_FACTORY.manufacturePojo(Publication.class));
        assessment2.setSubject(PODAM_FACTORY.manufacturePojo(Subject.class));
        final Assessment assessment3 = PODAM_FACTORY.manufacturePojo(Assessment.class);
        assessment3.setPublication(PODAM_FACTORY.manufacturePojo(Publication.class));
        assessment3.setSubject(PODAM_FACTORY.manufacturePojo(Subject.class));

        assertThat(this.assessmentCounterRepository.findAndUpdateNextAssessmentNameSequence(assessment1), is(1L));
        assertThat(this.assessmentCounterRepository.findAndUpdateNextAssessmentNameSequence(assessment1), is(2L));
        assertThat(this.assessmentCounterRepository.findAndUpdateNextAssessmentNameSequence(assessment2), is(1L));
        assertThat(this.assessmentCounterRepository.findAndUpdateNextAssessmentNameSequence(assessment3), is(1L));
        assertThat(this.assessmentCounterRepository.findAndUpdateNextAssessmentNameSequence(assessment1), is(3L));
        assertThat(this.assessmentCounterRepository.findAndUpdateNextAssessmentNameSequence(assessment2), is(2L));
        assertThat(this.assessmentCounterRepository.findAndUpdateNextAssessmentNameSequence(assessment2), is(3L));
        assertThat(this.assessmentCounterRepository.findAndUpdateNextAssessmentNameSequence(assessment3), is(2L));
    }

    @Test
    public void findAndUpdateNextAssessmentNameSequenceWithVariousFieldsTest() {
        final Assessment assessment = PODAM_FACTORY.manufacturePojo(Assessment.class);
        assessment.setPublication(PODAM_FACTORY.manufacturePojo(Publication.class));
        assessment.setSubject(PODAM_FACTORY.manufacturePojo(Subject.class));
        final Publication pubCopy = new Publication();
        final Subject subCopy = new Subject();
        final Assessment assessmentCopy = new Assessment();

        ReflectionUtils.shallowCopyFieldState(assessment.getPublication(), pubCopy);
        ReflectionUtils.shallowCopyFieldState(assessment.getSubject(), subCopy);
        ReflectionUtils.shallowCopyFieldState(assessment, assessmentCopy);
        assessmentCopy.setPublication(pubCopy);
        assessmentCopy.setSubject(subCopy);

        // sequence should be incremented each time since we are not changing any sequence key fields
        assertThat(this.assessmentCounterRepository.findAndUpdateNextAssessmentNameSequence(assessment), is(1L));
        assertThat(this.assessmentCounterRepository.findAndUpdateNextAssessmentNameSequence(assessment), is(2L));

        assessment.setAdministration("new-administration");
        assessment.setLabel("new-label");
        assertThat(this.assessmentCounterRepository.findAndUpdateNextAssessmentNameSequence(assessment), is(3L));

        assessment.setGrade(new String[] { "4", "8" });
        assertThat(this.assessmentCounterRepository.findAndUpdateNextAssessmentNameSequence(assessment), is(4L));

        // a new sequence should be created in DB for the new tenant ID
        assessment.setTenantId("new-tenant-id");
        assertThat(this.assessmentCounterRepository.findAndUpdateNextAssessmentNameSequence(assessment), is(1L));
        assessment.setTenantId(assessmentCopy.getTenantId());

        // a new sequence should be created in DB for the new publisher
        assessment.getPublication().setCoreStandardsPublisherKey("new-publisher-key");
        assertThat(this.assessmentCounterRepository.findAndUpdateNextAssessmentNameSequence(assessment), is(1L));
        assessment.getPublication().setCoreStandardsPublisherKey(assessmentCopy.getPublication().getCoreStandardsPublisherKey());

        // a new sequence should be created in DB for the new subject
        assessment.getSubject().setAbbreviation("AB1");
        assertThat(this.assessmentCounterRepository.findAndUpdateNextAssessmentNameSequence(assessment), is(1L));
        assessment.getSubject().setAbbreviation(assessmentCopy.getSubject().getAbbreviation());

        // the old sequence should be used for our original sequence key
        assertThat(this.assessmentCounterRepository.findAndUpdateNextAssessmentNameSequence(assessment), is(5L));
    }

}
