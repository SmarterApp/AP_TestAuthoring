/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.service.impl;

import static org.opentestsystem.authoring.testauth.config.TestAuthUtil.paramArray;
import static org.opentestsystem.authoring.testauth.publish.PublisherUtil.validateConversionListFile;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.authoring.testauth.domain.AffinityGroup;
import org.opentestsystem.authoring.testauth.domain.Assessment;
import org.opentestsystem.authoring.testauth.domain.BlueprintDenotationType;
import org.opentestsystem.authoring.testauth.domain.BlueprintElement;
import org.opentestsystem.authoring.testauth.domain.BlueprintReferenceType;
import org.opentestsystem.authoring.testauth.domain.ConversionTableType;
import org.opentestsystem.authoring.testauth.domain.CoreStandardPublicationPayloadElement;
import org.opentestsystem.authoring.testauth.domain.CoreStandardPublicationResponse;
import org.opentestsystem.authoring.testauth.domain.Publication;
import org.opentestsystem.authoring.testauth.domain.ScoringRule;
import org.opentestsystem.authoring.testauth.domain.Segment;
import org.opentestsystem.authoring.testauth.domain.search.ScoringRuleSearchRequest;
import org.opentestsystem.authoring.testauth.persistence.AssessmentRepository;
import org.opentestsystem.authoring.testauth.persistence.BlueprintElementRepository;
import org.opentestsystem.authoring.testauth.persistence.GridFsRepository;
import org.opentestsystem.authoring.testauth.persistence.PublicationRepository;
import org.opentestsystem.authoring.testauth.persistence.ScoringRuleRepository;
import org.opentestsystem.authoring.testauth.publish.SharedPublisherHelper;
import org.opentestsystem.authoring.testauth.publish.domain.ScoringRuleData;
import org.opentestsystem.authoring.testauth.publish.domain.TestComputationRule;
import org.opentestsystem.authoring.testauth.service.AffinityGroupService;
import org.opentestsystem.authoring.testauth.service.BlueprintElementService;
import org.opentestsystem.authoring.testauth.service.ComputationRuleService;
import org.opentestsystem.authoring.testauth.service.CoreStandardsService;
import org.opentestsystem.authoring.testauth.service.SegmentService;
import org.opentestsystem.authoring.testauth.validation.ScoringRuleValidator;
import org.opentestsystem.authoring.testauth.validation.ValidationHelper;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.validation.BeanPropertyBindingResult;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;

import com.google.common.base.Function;
import com.google.common.base.Predicate;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.mongodb.gridfs.GridFSDBFile;

@Component
public final class ScoringRuleHelper {

    private static final String BPREF_ID_NOT_FOUND = "blueprintReferenceId.notfound";
    private static final String BPREF_NOT_ACTIVE = "scoringRule.blueprintReferenceId.not.active";
    private static final String BPREF_ASSESSMENTID_MISMATCH = "scoringRule.blueprintReferenceId.assessmentId.mismatch";
    private static final String BP_DENOTATION_REQUIRED = "scoringRule.blueprintDenotationType.required";
    @Autowired
    private transient ScoringRuleRepository scoringRuleRepository;

    @Autowired
    private transient ScoringRuleValidator scoringRuleValidator;

    @Autowired
    private transient ComputationRuleService computationRuleService;

    @Autowired
    private transient AssessmentRepository assessmentRepository;

    @Autowired
    private transient PublicationRepository publicationRepository;

    @Autowired
    private transient SegmentService segmentService;

    @Autowired
    private transient AffinityGroupService affinityGroupService;

    @Autowired
    private transient BlueprintElementRepository blueprintElementRepository;

    @Autowired
    private transient BlueprintElementService blueprintElementService;

    @Autowired
    private transient GridFsRepository gridFsRepository;

    @Autowired
    private transient SharedPublisherHelper sharedPublisherHelper;

    @Autowired
    private transient CoreStandardsService coreStandardsService;

    protected void populateBlueprintReferenceName(final ScoringRule scoringRule) {
        if (scoringRule != null) {
            String blueprintReferenceName = null;
            switch (scoringRule.getBlueprintReferenceType()) {
            case TEST:
                final Assessment assessment = this.assessmentRepository.findOne(scoringRule.getBlueprintReferenceId());
                if (assessment != null) {
                    blueprintReferenceName = assessment.getName();
                }
                break;
            case SEGMENT:
                final Assessment assessment2 = this.assessmentRepository.findOne(scoringRule.getAssessmentId());
                if (assessment2 != null) {
                    final Segment segment = this.segmentService.getSegment(scoringRule.getBlueprintReferenceId());
                    if (segment != null) {
                        blueprintReferenceName = segment.getPosition() + " - " + segment.getLabel();
                    }
                }
                break;
            case AFFINITY_GROUP:
                final AffinityGroup affinityGroup = this.affinityGroupService.getAffinityGroup(scoringRule.getBlueprintReferenceId());
                if (affinityGroup != null) {
                    blueprintReferenceName = affinityGroup.getGroupName();
                }
                break;
            case STANDARD:
                if (scoringRule.getBlueprintDenotationType() == BlueprintDenotationType.STANDARD_KEY) {
                    final BlueprintElement blueprintElement = this.blueprintElementService.getBlueprintElement(scoringRule.getBlueprintReferenceId());
                    if (blueprintElement != null) {
                        blueprintReferenceName = blueprintElement.getStandardKey() + " - Grade " + blueprintElement.getGrade();
                    }
                } else if (scoringRule.getBlueprintDenotationType() == BlueprintDenotationType.LEVEL) {
                    final Assessment assessment3 = this.assessmentRepository.findOne(scoringRule.getAssessmentId());
                    if (assessment3 != null) {
                        final Publication publication = this.publicationRepository.findOne(assessment3.getPublicationId());
                        final CoreStandardPublicationResponse response = this.coreStandardsService.getCoreStandardsCategoriesForPublication(publication.getCoreStandardsPublicationKey());
                        for (final CoreStandardPublicationPayloadElement element : response.getPayload()) {
                            if (StringUtils.equals(element.getTreeLevel(), scoringRule.getBlueprintReferenceId())) {
                                blueprintReferenceName = scoringRule.getBlueprintReferenceId() + " - " + element.getName();
                                break;
                            }
                        }
                    }
                } else if (scoringRule.getBlueprintDenotationType() == BlueprintDenotationType.LEAF_NODES) {
                    blueprintReferenceName = BlueprintDenotationType.LEAF_NODES.getTitle();
                }
                break;
            default:
                // do nothing, cannot enter here if prior validation passed
                break;
            }
            scoringRule.setBlueprintReferenceName(blueprintReferenceName);
        }
    }

    protected void validateScoringRule(final ScoringRule scoringRule) {
        populateComputationRule(scoringRule);
        final BindingResult bindingResult = new BeanPropertyBindingResult(scoringRule, "scoringRule");
        this.scoringRuleValidator.validate(scoringRule, bindingResult);
        if (!bindingResult.hasErrors()) {
            switch (scoringRule.getBlueprintReferenceType()) {
            case TEST:
                if (!StringUtils.equals(scoringRule.getBlueprintReferenceId(), scoringRule.getAssessmentId())) {
                    formatReferenceIdMessage(bindingResult, scoringRule, BPREF_ID_NOT_FOUND);
                }
                scoringRule.setBlueprintDenotationType(null);
                break;
            case SEGMENT:
                final Segment segment = scoringRule.getBlueprintReferenceId() == null ? null : this.segmentService.getSegment(scoringRule.getBlueprintReferenceId());
                if (segment == null || !StringUtils.equals(segment.getAssessmentId(), scoringRule.getAssessmentId())) {
                    formatReferenceIdMessage(bindingResult, scoringRule, BPREF_ID_NOT_FOUND);
                } else if (!StringUtils.equals(segment.getAssessmentId(), scoringRule.getAssessmentId())) {
                    formatReferenceIdMessage(bindingResult, scoringRule, BPREF_ASSESSMENTID_MISMATCH);
                }
                scoringRule.setBlueprintDenotationType(null);
                break;
            case AFFINITY_GROUP:
                final AffinityGroup affinityGroup = scoringRule.getBlueprintReferenceId() == null ? null : this.affinityGroupService.getAffinityGroup(scoringRule.getBlueprintReferenceId());
                if (affinityGroup == null) {
                    formatReferenceIdMessage(bindingResult, scoringRule, BPREF_ID_NOT_FOUND);
                } else if (!affinityGroup.isActive()) {
                    formatReferenceIdMessage(bindingResult, scoringRule, BPREF_NOT_ACTIVE);
                } else if (!StringUtils.equals(affinityGroup.getAssessmentId(), scoringRule.getAssessmentId())) {
                    formatReferenceIdMessage(bindingResult, scoringRule, BPREF_ASSESSMENTID_MISMATCH);
                }
                scoringRule.setBlueprintDenotationType(null);
                break;
            case STANDARD:
                if (scoringRule.getBlueprintDenotationType() == null) {
                    // missing denotation type message
                    bindingResult.addError(buildFieldError("blueprintDenotationType", BP_DENOTATION_REQUIRED,
                            paramArray(scoringRule.getBlueprintReferenceType().name(), scoringRule.getBlueprintReferenceType().getTitle())));
                } else {
                    if (scoringRule.getBlueprintDenotationType() == BlueprintDenotationType.STANDARD_KEY) {
                        // ensure ID is actual active BP Element
                        final BlueprintElement blueprintElement = scoringRule.getBlueprintReferenceId() == null ? null :
                                this.blueprintElementService.getBlueprintElement(scoringRule.getBlueprintReferenceId());
                        if (blueprintElement == null) {
                            formatReferenceIdMessage(bindingResult, scoringRule, BPREF_ID_NOT_FOUND);
                        } else if (!blueprintElement.isActive()) {
                            formatReferenceIdMessage(bindingResult, scoringRule, BPREF_NOT_ACTIVE);
                        } else if (!StringUtils.equals(blueprintElement.getAssessmentId(), scoringRule.getAssessmentId())) {
                            formatReferenceIdMessage(bindingResult, scoringRule, BPREF_ASSESSMENTID_MISMATCH);
                        }
                    } else if (scoringRule.getBlueprintDenotationType() == BlueprintDenotationType.LEVEL) {
                        // ensure level choice is valid
                        if (!findDistinctActiveBlueprintLevelsByAssessmentId(scoringRule.getAssessmentId()).keySet().contains(scoringRule.getBlueprintReferenceId())) {
                            formatReferenceIdMessage(bindingResult, scoringRule, "scoringRule.blueprintReferenceId.level.invalid");
                        }
                    } else if (scoringRule.getBlueprintDenotationType() == BlueprintDenotationType.LEAF_NODES) {
                        // ensure ID field is empty/null
                        if (scoringRule.getBlueprintReferenceId() != null) {
                            formatReferenceIdMessage(bindingResult, scoringRule, "scoringRule.blueprintReferenceId.notempty");
                        }
                    } else {
                        bindingResult.addError(buildFieldError("blueprintDenotationType", BP_DENOTATION_REQUIRED,
                                paramArray(scoringRule.getBlueprintReferenceType().name(), scoringRule.getBlueprintReferenceType().getTitle())));
                    }
                }
                break;
            default:
                // do nothing, cannot enter here if prior validation passed
                break;
            }

            validateFileIdsExist(bindingResult, scoringRule);

            validateOrderValue(bindingResult, scoringRule);
            if (scoringRule.getComputationRule().getConversionTableType() == ConversionTableType.VALUE_STANDARD_ERROR) {
                validateConversionTableFileLengthsMatch(bindingResult, scoringRule);
            }
        }
        if (bindingResult.hasErrors()) {
            throw ValidationHelper.convertErrorsToConstraintException(scoringRule, bindingResult);
        }
    }

    private void formatReferenceIdMessage(final BindingResult bindingResult, final ScoringRule scoringRule, final String messageKey) {
        bindingResult.addError(buildFieldError("blueprintReferenceId", messageKey, scoringRule.getBlueprintReferenceType().getTitle()));
    }

    private void validateOrderValue(final BindingResult bindingResult, final ScoringRule scoringRule) {
        final ScoringRuleSearchRequest searchRequest = new ScoringRuleSearchRequest(
                ImmutableMap.of("assessmentId", paramArray(scoringRule.getAssessmentId()), "pageSize", paramArray("5000")));
        if (searchRequest.isValid()) {
            final SearchResponse<ScoringRule> searchResponse = this.scoringRuleRepository.search(searchRequest);
            final int sizeToCompare = scoringRule.getId() == null ? searchResponse.getSearchResults().size() + 1 : searchResponse.getSearchResults().size();
            if (sizeToCompare < scoringRule.getOrder()) {
                bindingResult.addError(buildFieldError("order", "scoringRule.order.exceed", String.valueOf(sizeToCompare)));
            }
        }
    }

    private void validateFileIdsExist(final BindingResult bindingResult, final ScoringRule scoringRule) {
        if (scoringRule != null && scoringRule.getValueConversionTableGridFsId() != null) {
            final GridFSDBFile gridFSDBFile = this.gridFsRepository.getById(scoringRule.getValueConversionTableGridFsId());
            if (gridFSDBFile == null) {
                bindingResult.addError(buildFieldError("valueConversionTableGridFsId", "scoringRule.valueConversionTableGridFsId.required"));
            }
        }
        if (scoringRule != null && scoringRule.getStandardErrorConversionTableGridFsId() != null) {
            final GridFSDBFile gridFSDBFile = this.gridFsRepository.getById(scoringRule.getStandardErrorConversionTableGridFsId());
            if (gridFSDBFile == null) {
                bindingResult.addError(buildFieldError("standardErrorConversionTableGridFsId", "scoringRule.standardErrorConversionTableGridFsId.required"));
            }
        }
    }

    private void validateConversionTableFileLengthsMatch(final BindingResult bindingResult, final ScoringRule scoringRule) {
        if (scoringRule != null && scoringRule.getValueConversionTableGridFsId() != null && scoringRule.getStandardErrorConversionTableGridFsId() != null) {
            final GridFSDBFile valueFile = this.gridFsRepository.getById(scoringRule.getValueConversionTableGridFsId());
            final ByteArrayOutputStream valueBaos = new ByteArrayOutputStream();
            try {
                valueFile.writeTo(valueBaos);
            } catch (final IOException e) {
                bindingResult.addError(buildFieldError("valueConversionTableGridFsId", "scoringRule.valueConversionTableGridFsId.required"));
            }
            final int valueListSize = validateConversionListFile(valueBaos.toByteArray(), scoringRule.getLabel(), "VALUE", false).size();

            final GridFSDBFile errorFile = this.gridFsRepository.getById(scoringRule.getStandardErrorConversionTableGridFsId());
            final ByteArrayOutputStream errorBaos = new ByteArrayOutputStream();
            try {
                errorFile.writeTo(errorBaos);
            } catch (final IOException e) {
                bindingResult.addError(buildFieldError("standardErrorConversionTableGridFsId", "scoringRule.standardErrorConversionTableGridFsId.required"));
            }
            final int errorListSize = validateConversionListFile(errorBaos.toByteArray(), scoringRule.getLabel(), "STANDARD_ERROR", false).size();

            if (valueListSize != errorListSize) {
                bindingResult.addError(buildFieldError("standardErrorConversionTableGridFsId", "scoringRule.standardErrorConversionTableGridFsId.length",
                        paramArray(String.valueOf(valueListSize), String.valueOf(errorListSize))));
            }
        }
    }

    private FieldError buildFieldError(final String fieldName, final String messageKey, final String... messageArgs) {
        return new FieldError("scoringRule", fieldName, null, false, paramArray(messageKey), messageArgs, messageKey);
    }

    protected void populateComputationRule(final ScoringRule scoringRule) {
        if (scoringRule != null && scoringRule.getComputationRuleId() != null) {
            scoringRule.setComputationRule(this.computationRuleService.getComputationRule(scoringRule.getComputationRuleId()));
        }
    }

    protected Map<String, String> findDistinctActiveBlueprintLevelsByAssessmentId(final String assessmentId) {
        final Map<String, String> scoringRuleLevelChoices = Maps.newHashMap();
        final List<String> bpLevels = Lists.newArrayList(this.blueprintElementRepository.findDistinctActiveLevelsByAssessmentId(assessmentId));

        final Assessment assessment = this.assessmentRepository.findOne(assessmentId);
        if (assessment != null) {
            final Publication publication = this.publicationRepository.findOne(assessment.getPublicationId());
            final CoreStandardPublicationResponse response = this.coreStandardsService.getCoreStandardsCategoriesForPublication(publication.getCoreStandardsPublicationKey());
            for (final CoreStandardPublicationPayloadElement element : response.getPayload()) {
                if (bpLevels.contains(element.getTreeLevel())) {
                    scoringRuleLevelChoices.put(element.getTreeLevel(), element.getTreeLevel() + " - " + element.getName());
                }
            }
        }
        return scoringRuleLevelChoices;
    }

    protected List<BlueprintElement> findBlueprintElementsMissingScoringRule(final String assessmentId) {
        final Assessment assessment = this.assessmentRepository.findOne(assessmentId);
        final List<Segment> segmentList = this.sharedPublisherHelper.retrieveSegmentList(assessmentId);
        final List<BlueprintElement> blueprintElementList = this.sharedPublisherHelper.getActiveBlueprintElements(assessmentId);
        final List<AffinityGroup> affinityGroupList = this.sharedPublisherHelper.getActiveAffinityGroups(assessmentId);
        final Map<BlueprintReferenceType, Map<String, String>> blueprintReferenceMap =
                this.sharedPublisherHelper.buildBlueprintReferenceMap(assessment, segmentList, blueprintElementList, affinityGroupList);
        final List<ScoringRule> scoringRuleList = this.sharedPublisherHelper.retrieveScoringRules(assessmentId);
        final ScoringRuleData scoringRuleData = this.sharedPublisherHelper.setupScoringRuleData(assessmentId, blueprintReferenceMap, scoringRuleList, blueprintElementList, false);
        final List<String> blueprintElementStandardKeysCoveredByScoringRule = Lists.transform(scoringRuleData.getComputationRuleList(), COMPRULE_BPE_ID_TRANSFORMER);

        final Map<String, BlueprintElement> bpElementMap = Maps.uniqueIndex(blueprintElementList, BPELEMENT_STANDARD_KEY_TRANSFORMER);

        final List<BlueprintElement> blueprintElementsNotCoveredByScoringRule =
                Lists.newArrayList(Maps.filterEntries(bpElementMap, BPE_WITHOUT_SCORULE_FILTER.getInstance(blueprintElementStandardKeysCoveredByScoringRule)).values());
        return blueprintElementsNotCoveredByScoringRule;
    }

    private static final Function<TestComputationRule, String> COMPRULE_BPE_ID_TRANSFORMER = new Function<TestComputationRule, String>() {
        @Override
        public String apply(final TestComputationRule testComputationRule) {
            return testComputationRule.getBpElementId();
        }
    };

    private static final Function<BlueprintElement, String> BPELEMENT_STANDARD_KEY_TRANSFORMER = new Function<BlueprintElement, String>() {
        @Override
        public String apply(final BlueprintElement blueprintElement) {
            return blueprintElement.getStandardKey();
        }
    };

    private static final class BPE_WITHOUT_SCORULE_FILTER implements Predicate<Map.Entry<String, BlueprintElement>> {
        private final List<String> blueprintElementStandardKeysCoveredByScoringRule;

        public static BPE_WITHOUT_SCORULE_FILTER getInstance(final List<String> blueprintElementStandardKeysCoveredByScoringRule) {
            return new BPE_WITHOUT_SCORULE_FILTER(blueprintElementStandardKeysCoveredByScoringRule);
        }

        private BPE_WITHOUT_SCORULE_FILTER(final List<String> blueprintElementStandardKeysCoveredByScoringRule) {
            this.blueprintElementStandardKeysCoveredByScoringRule = blueprintElementStandardKeysCoveredByScoringRule;
        }

        @Override
        public boolean apply(final Map.Entry<String, BlueprintElement> bpElemententry) {
            return bpElemententry != null && StringUtils.isNotBlank(bpElemententry.getKey()) && !this.blueprintElementStandardKeysCoveredByScoringRule.contains(bpElemententry.getKey());
        }
    }
}
