/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.integration;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.not;
import static org.hamcrest.CoreMatchers.notNullValue;
import static org.hamcrest.CoreMatchers.nullValue;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import java.nio.charset.Charset;
import java.util.List;
import java.util.Map;

import javax.validation.ConstraintViolationException;

import org.apache.commons.lang.RandomStringUtils;
import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.authoring.testauth.domain.AdaptiveItemLocation;
import org.opentestsystem.authoring.testauth.domain.AffinityGroup;
import org.opentestsystem.authoring.testauth.domain.Assessment;
import org.opentestsystem.authoring.testauth.domain.BlueprintDenotationType;
import org.opentestsystem.authoring.testauth.domain.BlueprintElement;
import org.opentestsystem.authoring.testauth.domain.BlueprintReferenceType;
import org.opentestsystem.authoring.testauth.domain.ComputationRule;
import org.opentestsystem.authoring.testauth.domain.ComputationRuleMultiplicityType;
import org.opentestsystem.authoring.testauth.domain.ComputationRuleParameter;
import org.opentestsystem.authoring.testauth.domain.ComputationRuleType;
import org.opentestsystem.authoring.testauth.domain.ConversionTableType;
import org.opentestsystem.authoring.testauth.domain.CoreStandardPublicationPayloadElement;
import org.opentestsystem.authoring.testauth.domain.CoreStandardPublicationResponse;
import org.opentestsystem.authoring.testauth.domain.DictionaryIndexType;
import org.opentestsystem.authoring.testauth.domain.DomainFactory;
import org.opentestsystem.authoring.testauth.domain.Item;
import org.opentestsystem.authoring.testauth.domain.ItemLocation;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionAlgorithm;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionAlgorithmType;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionPurpose;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionType;
import org.opentestsystem.authoring.testauth.domain.Publication;
import org.opentestsystem.authoring.testauth.domain.PublishingRecord;
import org.opentestsystem.authoring.testauth.domain.ScoringRule;
import org.opentestsystem.authoring.testauth.domain.ScoringRuleDictionaryElement;
import org.opentestsystem.authoring.testauth.domain.ScoringRuleParameter;
import org.opentestsystem.authoring.testauth.domain.Segment;
import org.opentestsystem.authoring.testauth.domain.Subject;
import org.opentestsystem.authoring.testauth.persistence.GridFsRepository;
import org.opentestsystem.authoring.testauth.rest.AbstractRestEmbeddedMongoTest;
import org.opentestsystem.authoring.testauth.service.AffinityGroupService;
import org.opentestsystem.authoring.testauth.service.AssessmentService;
import org.opentestsystem.authoring.testauth.service.BlueprintElementService;
import org.opentestsystem.authoring.testauth.service.ComputationRuleService;
import org.opentestsystem.authoring.testauth.service.CoreStandardsService;
import org.opentestsystem.authoring.testauth.service.ItemSelectionAlgorithmService;
import org.opentestsystem.authoring.testauth.service.ItemService;
import org.opentestsystem.authoring.testauth.service.PublicationService;
import org.opentestsystem.authoring.testauth.service.PublishingRecordService;
import org.opentestsystem.authoring.testauth.service.ScoringRuleService;
import org.opentestsystem.authoring.testauth.service.SegmentService;
import org.opentestsystem.authoring.testauth.service.SubjectService;
import org.opentestsystem.authoring.testauth.service.impl.ScoringRuleHelper;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.progman.client.ProgManClient;
import org.opentestsystem.shared.progman.client.domain.Tenant;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.util.ReflectionTestUtils;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.mongodb.DBObject;
import com.mongodb.gridfs.GridFSFile;

public class ScoringRuleServiceTest extends AbstractRestEmbeddedMongoTest {

    private static final String VALUE_FILE = "RANGE_NAME,START_VALUE\n"
            + "yugo,0\n"
            + "escort,30\n"
            + "camry,65\n"
            + "maserati,88";
    private static final String ERROR_FILE = "STANDARD_KEY,ERROR_MESSAGE\n"
            + "CC-ELA-v1|11-12|L,Not only was your answer wrong...it was about as far from correct as one could possibly conceive. Go home.\n"
            + "CC-ELA-v1|8|L,That was almost the correct answer.\n"
            + "CC-ELA-v1|1,Aww that was very good.\n"
            + "CC-ELA-v1|4,BUY MOXIE!";

    @Autowired
    private ScoringRuleService scoringRuleService;

    @Autowired
    private transient GridFsRepository gridFsRepository;

    @Autowired
    private ComputationRuleService computationRuleService;

    @Autowired
    private SegmentService segmentService;

    @Autowired
    private ItemService itemService;

    @Autowired
    private AffinityGroupService affinityGroupService;

    @Autowired
    private BlueprintElementService blueprintElementService;

    @Autowired
    private PublicationService publicationService;

    @Autowired
    private SubjectService subjectService;

    @Autowired
    private AssessmentService assessmentService;

    @Autowired
    private ItemSelectionAlgorithmService itemSelectionAlgorithmService;

    @Autowired
    private PublishingRecordService publishingRecordService;

    @Autowired
    private ProgManClient progManClient; // mocked client

    private CoreStandardsService coreStandardsService;

    @Autowired
    private ScoringRuleHelper scoringRuleHelper;

    private ComputationRule savedComputationRule;
    private Assessment savedAssessment;
    private ItemSelectionAlgorithm savedAlgorithm;
    private Segment savedSegment;
    private AffinityGroup savedAffinityGroup;
    private BlueprintElement savedBlueprintElement;
    private GridFSFile valueFile;
    private GridFSFile standardErrorFile;

    @Before
    public void setupTestData() {
        final ComputationRule computationRule = PODAM_FACTORY.manufacturePojo(ComputationRule.class);
        computationRule.setId(null);
        computationRule.setConversionTableType(ConversionTableType.VALUE_STANDARD_ERROR);
        computationRule.getParameters().clear();
        computationRule.setVersion("1.0");
        final ComputationRuleParameter computationRuleParameter = new ComputationRuleParameter();
        computationRuleParameter.setParameterName("parameter1");
        computationRuleParameter.setComputationRuleType(ComputationRuleType.INTEGER);
        computationRuleParameter.setDefaultValue("1");
        computationRuleParameter.setMinimumValue("1");
        computationRuleParameter.setMaximumValue("999");
        computationRuleParameter.setComputationRuleMultiplicityType(ComputationRuleMultiplicityType.DICTIONARY);
        computationRuleParameter.setDictionaryIndexType(DictionaryIndexType.STRING);
        computationRuleParameter.setPosition(1);
        computationRule.getParameters().add(computationRuleParameter);
        final ComputationRuleParameter computationRuleParameter2 = new ComputationRuleParameter();
        computationRuleParameter2.setParameterName("parameter2");
        computationRuleParameter2.setComputationRuleType(ComputationRuleType.STRING);
        computationRuleParameter2.setDefaultValue("Q");
        computationRuleParameter2.setComputationRuleMultiplicityType(ComputationRuleMultiplicityType.SCALAR);
        computationRuleParameter2.setPosition(2);
        computationRule.getParameters().add(computationRuleParameter2);
        final ComputationRuleParameter computationRuleParameter3 = new ComputationRuleParameter();
        computationRuleParameter3.setParameterName("parameter3");
        computationRuleParameter3.setComputationRuleType(ComputationRuleType.FLOAT);
        computationRuleParameter3.setDefaultValue("1.01");
        computationRuleParameter3.setMinimumValue("1.00");
        computationRuleParameter3.setMaximumValue("99.99");
        computationRuleParameter3.setComputationRuleMultiplicityType(ComputationRuleMultiplicityType.DICTIONARY);
        computationRuleParameter3.setDictionaryIndexType(DictionaryIndexType.INTEGER);
        computationRuleParameter3.setPosition(3);
        computationRule.getParameters().add(computationRuleParameter3);
        final ComputationRuleParameter computationRuleParameter4 = new ComputationRuleParameter();
        computationRuleParameter4.setParameterName("parameter4");
        computationRuleParameter4.setComputationRuleType(ComputationRuleType.INTEGER);
        computationRuleParameter4.setDefaultValue("15");
        computationRuleParameter4.setMinimumValue("10");
        computationRuleParameter4.setMaximumValue("20");
        computationRuleParameter4.setComputationRuleMultiplicityType(ComputationRuleMultiplicityType.SCALAR);
        computationRuleParameter4.setPosition(4);
        computationRule.getParameters().add(computationRuleParameter4);
        final ComputationRuleParameter computationRuleParameter5 = new ComputationRuleParameter();
        computationRuleParameter5.setParameterName("parameter5");
        computationRuleParameter5.setComputationRuleType(ComputationRuleType.BOOLEAN);
        computationRuleParameter5.setDefaultValue("true");
        computationRuleParameter5.setComputationRuleMultiplicityType(ComputationRuleMultiplicityType.DICTIONARY);
        computationRuleParameter5.setDictionaryIndexType(DictionaryIndexType.INTEGER);
        computationRuleParameter5.setPosition(5);
        computationRule.getParameters().add(computationRuleParameter5);
        final ComputationRuleParameter computationRuleParameter6 = new ComputationRuleParameter();
        computationRuleParameter6.setParameterName("parameter6");
        computationRuleParameter6.setComputationRuleType(ComputationRuleType.BOOLEAN);
        computationRuleParameter6.setDefaultValue("false");
        computationRuleParameter6.setComputationRuleMultiplicityType(ComputationRuleMultiplicityType.SCALAR);
        computationRuleParameter6.setPosition(6);
        computationRule.getParameters().add(computationRuleParameter6);
        this.savedComputationRule = this.computationRuleService.createComputationRule(computationRule);

        final Subject savedSubject = this.subjectService.saveSubject(DomainFactory.manufactureValidSubject("ABB"));
        final Publication savedPublication = this.publicationService.savePublication(DomainFactory.manufactureValidPublication(savedSubject.getTenantId(), ImmutableSet.of(savedSubject)));

        this.savedAssessment = this.assessmentService.saveAssessment(DomainFactory.manufactureValidAssessment(savedSubject, savedPublication));

        final ItemSelectionAlgorithm algorithm = DomainFactory.manufactureValidItemSelectionAlgorithm(ItemSelectionPurpose.SCALAR, ItemSelectionType.BOOLEAN);
        algorithm.setItemSelectionAlgorithmType(ItemSelectionAlgorithmType.ADAPTIVE);
        this.savedAlgorithm = this.itemSelectionAlgorithmService.createItemSelectionAlgorithm(algorithm);

        final Segment segmentToSave = DomainFactory.manufactureValidSegment(this.savedAssessment.getId(), this.savedAlgorithm, 1);
        this.savedSegment = this.segmentService.createSegment(segmentToSave);
        saveGoodMinimalItemData();

        final AffinityGroup affinityGroupToSave = DomainFactory.manufactureValidAffinityGroup(this.savedAssessment.getId());
        this.savedAffinityGroup = this.affinityGroupService.saveNewAffinityGroup(affinityGroupToSave);

        final BlueprintElement blueprintElementToSave = DomainFactory.manufactureValidBlueprintElement(this.savedAssessment.getId(), ImmutableList.of(this.savedSegment));
        blueprintElementToSave.setGrade(this.savedAssessment.getGrade()[0]);
        this.savedBlueprintElement = this.blueprintElementService.saveBlueprintElement(null, blueprintElementToSave);

        final DBObject metadata = null;
        this.valueFile = this.gridFsRepository.save(VALUE_FILE.getBytes(Charset.forName("UTF-8")), "valueConversionTable", "plain/text", metadata);
        this.standardErrorFile = this.gridFsRepository.save(ERROR_FILE.getBytes(Charset.forName("UTF-8")), "standardErrorConversionTable", "plain/text", metadata);

        this.coreStandardsService = mock(CoreStandardsService.class);
        ReflectionTestUtils.setField(this.scoringRuleHelper, "coreStandardsService", this.coreStandardsService);
        ReflectionTestUtils.setField(this.scoringRuleService, "scoringRuleHelper", this.scoringRuleHelper);
    }

    @Test
    public void saveNewScoringRuleTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();
        final ScoringRule savedScoringRule = this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
        assertThat(savedScoringRule, is(notNullValue()));
        final ScoringRule retrievedScoringRule = this.scoringRuleService.getScoringRule(savedScoringRule.getId());
        assertThat(retrievedScoringRule, is(notNullValue()));
    }

    @Test
    public void saveExistingScoringRuleTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();
        final ScoringRule savedScoringRule = this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
        assertThat(savedScoringRule, is(notNullValue()));
        final ScoringRule retrievedScoringRule = this.scoringRuleService.getScoringRule(savedScoringRule.getId());
        assertThat(retrievedScoringRule, is(notNullValue()));
        retrievedScoringRule.setLabel("changedLabel");
        final ScoringRule resavedScoringRule = this.scoringRuleService.saveScoringRule(retrievedScoringRule.getId(),
                retrievedScoringRule);
        assertThat(resavedScoringRule, is(notNullValue()));
        assertThat(resavedScoringRule.getLabel(), is(equalTo("changedLabel")));
    }

    @Test
    public void saveScoringRuleListTest() {
        final List<ScoringRule> scoringRuleListToSave = manufactureValidScoringRule(2);
        final ScoringRule savedScoringRule = this.scoringRuleService.saveScoringRule(null, scoringRuleListToSave.get(0));
        final ScoringRule savedScoringRule2 = this.scoringRuleService.saveScoringRule(null, scoringRuleListToSave.get(1));
        final List<ScoringRule> updatedScoringRuleListToSave = Lists.newArrayList(savedScoringRule, savedScoringRule2);

        final List<ScoringRule> savedScoringRuleList = this.scoringRuleService.saveScoringRuleList(updatedScoringRuleListToSave, true);
        assertThat(savedScoringRuleList, is(notNullValue()));
        final ScoringRule retrievedScoringRule = this.scoringRuleService.getScoringRule(savedScoringRuleList.get(0).getId());
        assertThat(retrievedScoringRule, is(notNullValue()));
    }

    @Test
    public void saveNonUniqueScoringRuleTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();
        final ScoringRule savedScoringRule = this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
        assertThat(savedScoringRule, is(notNullValue()));

        final ScoringRule newScoringRule = manufactureValidScoringRule();
        newScoringRule.setAssessmentId(savedScoringRule.getAssessmentId());

        try {
            this.scoringRuleService.saveScoringRule(null, newScoringRule);
            fail("should have thrown exception");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("scoringRule.already.exists.order"));
        }

        newScoringRule.setOrder(newScoringRule.getOrder() + 1);
        try {
            this.scoringRuleService.saveScoringRule(null, newScoringRule);
            fail("should have thrown exception");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("scoringRule.already.exists.label"));
        }
    }

    @Test
    public void saveScoringRuleWithoutParametersTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();
        scoringRuleToSave.getParameters().clear();

        final ScoringRule savedScoringRule = this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
        assertThat(savedScoringRule, is(notNullValue()));
        final ScoringRule retrievedScoringRule = this.scoringRuleService.getScoringRule(savedScoringRule.getId());
        assertThat(retrievedScoringRule, is(notNullValue()));
        final List<ScoringRuleParameter> emptyList = Lists.newArrayList();
        assertThat(retrievedScoringRule.getParameters(), is(emptyList));
    }

    @Test
    public void saveScoringRuleWithMissingFieldsTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        scoringRuleToSave.setId(null);
        scoringRuleToSave.setAssessmentId(""); // NotBlank
        scoringRuleToSave.setOrder(null); // NotNull
        scoringRuleToSave.setComputationRuleId(""); // NotBlank
        scoringRuleToSave.setBlueprintReferenceType(null); // NotNull
        scoringRuleToSave.setBlueprintReferenceId(""); // NotBlank

        try {
            this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(4));
            assertThat(getConstraintViolation(e, "NotBlank").size(), is(2));
            assertThat(getConstraintViolation(e, "NotNull").size(), is(2));
        }
    }

    @Test
    public void saveBlueprintScoringRuleWithMissingDenotationTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        scoringRuleToSave.setBlueprintDenotationType(null);
        scoringRuleToSave.setBlueprintReferenceType(BlueprintReferenceType.STANDARD);
        scoringRuleToSave.setBlueprintReferenceId(this.savedBlueprintElement.getId());

        try {
            this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "scoringRule.blueprintDenotationType.required").size(), is(1));
        }
    }

    @Test
    public void saveBlueprintLeafNodesScoringRuleWithInvalidDataTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        scoringRuleToSave.setBlueprintDenotationType(BlueprintDenotationType.LEAF_NODES);
        scoringRuleToSave.setBlueprintReferenceType(BlueprintReferenceType.STANDARD);
        scoringRuleToSave.setBlueprintReferenceId(this.savedBlueprintElement.getId());

        try {
            this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "scoringRule.blueprintReferenceId.notempty").size(), is(1));
        }
    }

    @Test
    public void saveBlueprintLevelScoringRuleWithInvalidLevelTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        scoringRuleToSave.setBlueprintDenotationType(BlueprintDenotationType.LEVEL);
        scoringRuleToSave.setBlueprintReferenceType(BlueprintReferenceType.STANDARD);
        scoringRuleToSave.setBlueprintReferenceId(this.savedBlueprintElement.getId());

        final CoreStandardPublicationPayloadElement coreStandard1 = PODAM_FACTORY.manufacturePojo(CoreStandardPublicationPayloadElement.class);
        coreStandard1.setTreeLevel("1");
        final CoreStandardPublicationResponse csResponse = new CoreStandardPublicationResponse();
        csResponse.setPayload(ImmutableList.of(coreStandard1));
        when(this.coreStandardsService.getCoreStandardsCategoriesForPublication(this.savedAssessment.getPublication().getCoreStandardsPublicationKey())).thenReturn(csResponse);

        try {
            this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "scoringRule.blueprintReferenceId.level.invalid").size(), is(1));
        }
    }

    @Test
    public void findDistinctActiveBlueprintLevelsByAssessmentIdAndCheckForMissingScoringRuleTest() {
        final List<BlueprintElement> beforeBpElementList = this.scoringRuleService.findBlueprintElementsMissingScoringRule(this.savedAssessment.getId());
        assertThat(beforeBpElementList.size(), is(1));

        final CoreStandardPublicationPayloadElement coreStandard1 = PODAM_FACTORY.manufacturePojo(CoreStandardPublicationPayloadElement.class);
        coreStandard1.setTreeLevel(beforeBpElementList.get(0).getLevel());
        final CoreStandardPublicationResponse csResponse = new CoreStandardPublicationResponse();
        csResponse.setPayload(ImmutableList.of(coreStandard1));
        when(this.coreStandardsService.getCoreStandardsCategoriesForPublication(this.savedAssessment.getPublication().getCoreStandardsPublicationKey())).thenReturn(csResponse);

        final Map<String, String> levelList = this.scoringRuleService.findDistinctActiveBlueprintLevelsByAssessmentId(this.savedAssessment.getId());
        assertThat(levelList.size(), is(1));

        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        scoringRuleToSave.setBlueprintDenotationType(BlueprintDenotationType.LEVEL);
        scoringRuleToSave.setBlueprintReferenceType(BlueprintReferenceType.STANDARD);
        scoringRuleToSave.setBlueprintReferenceId(levelList.keySet().iterator().next());
        this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);

        final List<BlueprintElement> afterBpElementList = this.scoringRuleService.findBlueprintElementsMissingScoringRule(this.savedAssessment.getId());
        assertThat(afterBpElementList.size(), is(0));
    }

    @Test
    public void saveScoringRuleWithMissingRuleParameterForFunctionParameterTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        final List<ScoringRuleDictionaryElement> dictionaryValue = Lists.newArrayList();
        scoringRuleToSave.getParameters().get(0).setDictionaryValue(dictionaryValue);

        try {
            this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "scoringRule.parameters.dictionaryValue.required").size(), is(1));
        }
    }

    @Test
    public void saveScoringRuleWithUnparseableIntegerParametersTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        scoringRuleToSave.getParameters().get(0).getDictionaryValue().get(0).setValue("24.99");

        try {
            this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "scoringRule.parameters.dictionaryValue.value.parseable.number").size(), is(1));
        }
    }

    @Test
    public void saveScoringRuleWithMissingStringParameterTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        scoringRuleToSave.getParameters().get(0).getDictionaryValue().get(0).setValue("");

        try {
            this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "scoringRule.parameters.dictionaryValue.value.required").size(), is(1));
        }
    }

    @Test
    public void saveScoringRuleWithUnparseableFloatParametersTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        final List<ScoringRuleDictionaryElement> dictionaryValue3 = Lists.newArrayList(ImmutableList.of(
                new ScoringRuleDictionaryElement("1", "24.99"),
                new ScoringRuleDictionaryElement("2", "1.3a4"),
                new ScoringRuleDictionaryElement("3", "74.99"),
                new ScoringRuleDictionaryElement("4", "91.3a4")));
        scoringRuleToSave.getParameters().get(2).setDictionaryValue(dictionaryValue3);

        try {
            this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(2));
            assertThat(getConstraintViolation(e, "scoringRule.parameters.dictionaryValue.value.parseable.number").size(), is(2));
        }
    }

    @Test
    public void saveScoringRuleWithFloatParametersOutOfRangeTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        final List<ScoringRuleDictionaryElement> dictionaryValue3 = Lists.newArrayList(ImmutableList.of(
                new ScoringRuleDictionaryElement("1", "24.99"),
                new ScoringRuleDictionaryElement("2", "1.34"),
                new ScoringRuleDictionaryElement("3", "74.99"),
                new ScoringRuleDictionaryElement("4", "291.34")));
        scoringRuleToSave.getParameters().get(2).setDictionaryValue(dictionaryValue3);

        try {
            this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "scoringRule.parameters.dictionaryValue.value.number.outofrange").size(), is(1));
        }
    }

    @Test
    public void saveScoringRuleWithEmptyFloatParameterTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        final List<ScoringRuleDictionaryElement> dictionaryValue3 = Lists.newArrayList(ImmutableList.of(
                new ScoringRuleDictionaryElement("1", ""),
                new ScoringRuleDictionaryElement("2", "1.34"),
                new ScoringRuleDictionaryElement("3", "74.99"),
                new ScoringRuleDictionaryElement("4", "")));
        scoringRuleToSave.getParameters().get(2).setDictionaryValue(dictionaryValue3);

        try {
            this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(2));
            assertThat(getConstraintViolation(e, "scoringRule.parameters.dictionaryValue.value.required").size(), is(2));
        }
    }

    @Test
    public void saveScoringRuleWithUnparseableDictionaryValueKeyTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        final List<ScoringRuleDictionaryElement> dictionaryValue3 = Lists.newArrayList(ImmutableList.of(
                new ScoringRuleDictionaryElement("a1", "24.99"),
                new ScoringRuleDictionaryElement("b2", "1.34"),
                new ScoringRuleDictionaryElement("c3", "74.99"),
                new ScoringRuleDictionaryElement("d4", "91.34")));
        scoringRuleToSave.getParameters().get(2).setDictionaryValue(dictionaryValue3);

        try {
            this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(4));
            assertThat(getConstraintViolation(e, "scoringRule.parameters.dictionaryValue.key.invalid").size(), is(4));
        }
    }

    @Test
    public void saveScoringRuleWithUnparseableScalarValueTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        scoringRuleToSave.getParameters().get(3).setScalarValue("aaa");

        try {
            this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "scoringRule.parameters.scalarValue.parseable.number").size(), is(1));
        }
    }

    @Test
    public void saveScoringRuleWithScalarValueOutOfRangeTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        scoringRuleToSave.getParameters().get(3).setScalarValue("30");

        try {
            this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "scoringRule.parameters.scalarValue.number.outofrange").size(), is(1));
        }
    }

    @Test
    public void saveScoringRuleWithScalarValueRequiredTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        scoringRuleToSave.getParameters().get(1).setScalarValue("");

        try {
            this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "scoringRule.parameters.scalarValue.required").size(), is(1));
        }
    }

    @Test
    public void saveScoringRuleWithReferenceIdNotMatchingAssessmentIdTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        scoringRuleToSave.setBlueprintReferenceType(BlueprintReferenceType.TEST);
        scoringRuleToSave.setBlueprintReferenceId(RandomStringUtils.random(25));

        try {
            this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "blueprintReferenceId.notfound").size(), is(1));
        }
    }

    @Test
    public void saveScoringRuleWithReferenceIdMatchingAssessmentIdTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        scoringRuleToSave.setBlueprintReferenceType(BlueprintReferenceType.TEST);
        scoringRuleToSave.setBlueprintReferenceId(this.savedAssessment.getId());

        final ScoringRule savedScoringRule = this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
        assertThat(savedScoringRule, is(notNullValue()));
        final ScoringRule retrievedScoringRule = this.scoringRuleService.getScoringRule(savedScoringRule.getId());
        assertThat(retrievedScoringRule, is(notNullValue()));
    }

    @Test
    public void saveScoringRuleWithReferenceIdNotFoundSegmentIdTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        scoringRuleToSave.setBlueprintReferenceType(BlueprintReferenceType.SEGMENT);
        scoringRuleToSave.setBlueprintReferenceId(RandomStringUtils.random(25));

        try {
            this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "blueprintReferenceId.notfound").size(), is(1));
        }
    }

    @Test
    public void saveScoringRuleWithReferenceIdNotFoundAffinityGroupIdTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        scoringRuleToSave.setBlueprintReferenceType(BlueprintReferenceType.AFFINITY_GROUP);
        scoringRuleToSave.setBlueprintReferenceId(RandomStringUtils.random(25));

        try {
            this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "blueprintReferenceId.notfound").size(), is(1));
        }
    }

    @Test
    public void saveScoringRuleWithReferenceIdFoundAffinityGroupIdTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        scoringRuleToSave.setBlueprintReferenceType(BlueprintReferenceType.AFFINITY_GROUP);
        scoringRuleToSave.setBlueprintReferenceId(this.savedAffinityGroup.getId());

        final ScoringRule savedScoringRule = this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
        assertThat(savedScoringRule, is(notNullValue()));
        final ScoringRule retrievedScoringRule = this.scoringRuleService.getScoringRule(savedScoringRule.getId());
        assertThat(retrievedScoringRule, is(notNullValue()));
    }

    @Test
    public void saveScoringRuleWithReferenceIdNotFoundBlueprintElementIdTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        scoringRuleToSave.setBlueprintDenotationType(BlueprintDenotationType.STANDARD_KEY);
        scoringRuleToSave.setBlueprintReferenceType(BlueprintReferenceType.STANDARD);
        scoringRuleToSave.setBlueprintReferenceId(RandomStringUtils.random(25));

        try {
            this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "blueprintReferenceId.notfound").size(), is(1));
        }
    }

    @Test
    public void saveScoringRuleWithReferenceIdFoundBlueprintElementIdTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        scoringRuleToSave.setBlueprintDenotationType(BlueprintDenotationType.STANDARD_KEY);
        scoringRuleToSave.setBlueprintReferenceType(BlueprintReferenceType.STANDARD);
        scoringRuleToSave.setBlueprintReferenceId(this.savedBlueprintElement.getId());

        final ScoringRule savedScoringRule = this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
        assertThat(savedScoringRule, is(notNullValue()));
        final ScoringRule retrievedScoringRule = this.scoringRuleService.getScoringRule(savedScoringRule.getId());
        assertThat(retrievedScoringRule, is(notNullValue()));
    }

    @Test
    public void saveScoringRuleWithBlankDictionaryValueKeyTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        final List<ScoringRuleDictionaryElement> dictionaryValue3 = Lists.newArrayList(ImmutableList.of(
                new ScoringRuleDictionaryElement(" ", "24.99")));
        scoringRuleToSave.getParameters().get(2).setDictionaryValue(dictionaryValue3);

        try {
            this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "scoringRule.parameters.dictionaryValue.key.required").size(), is(1));
        }
    }

    @Test
    public void saveScoringRuleWithMissingValueConversionTableTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        scoringRuleToSave.setValueConversionTableGridFsId(null);

        try {
            this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "scoringRule.valueConversionTableGridFsId.required").size(), is(1));
        }
    }

    @Test
    public void saveScoringRuleWithMissingStandardErrorConversionTableTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        scoringRuleToSave.setStandardErrorConversionTableGridFsId(null);

        try {
            this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "scoringRule.standardErrorConversionTableGridFsId.required").size(), is(1));
        }
    }

    @Test
    public void saveScoringRuleWithOrderTooLargeTest() {
        final List<ScoringRule> scoringRuleToSaveList = manufactureValidScoringRule(2);

        final ScoringRule savedScoringRule = this.scoringRuleService.saveScoringRule(null, scoringRuleToSaveList.get(0));
        assertThat(savedScoringRule, is(notNullValue()));
        scoringRuleToSaveList.get(1).setOrder(3);

        try {
            this.scoringRuleService.saveScoringRule(null, scoringRuleToSaveList.get(1));
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "scoringRule.order.exceed").size(), is(1));
        }

        scoringRuleToSaveList.get(1).setOrder(2);
        final ScoringRule savedScoringRule2 = this.scoringRuleService.saveScoringRule(null, scoringRuleToSaveList.get(1));
        assertThat(savedScoringRule2, is(notNullValue()));
    }

    @Test
    public void removeScoringRuleTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        final ScoringRule savedScoringRule = this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
        assertThat(savedScoringRule, is(notNullValue()));
        final ScoringRule retrievedScoringRule = this.scoringRuleService.getScoringRule(savedScoringRule.getId());
        assertThat(retrievedScoringRule, is(notNullValue()));

        this.scoringRuleService.removeScoringRule(retrievedScoringRule.getId());
        final ScoringRule reRetrievedScoringRule = this.scoringRuleService.getScoringRule(savedScoringRule.getId());
        assertThat(reRetrievedScoringRule, is(nullValue()));
    }

    @Test
    public void removeScoringRuleByAssessmentIdLockedAssessmentTest() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        final ScoringRule savedScoringRule = this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
        assertThat(savedScoringRule, is(notNullValue()));
        final ScoringRule retrievedScoringRule = this.scoringRuleService.getScoringRule(savedScoringRule.getId());
        assertThat(retrievedScoringRule, is(notNullValue()));

        final Tenant tenant1 = buildTenant("id1", "tenant1", "description1");
        when(this.progManClient.getTenantById(this.savedAssessment.getTenantId())).thenReturn(tenant1);
        PublishingRecord publishingRecord = this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(this.savedAssessment.getId());
        publishingRecord = this.publishingRecordService.savePublishingRecord(publishingRecord, false);
        this.publishingRecordService.savePublishingRecord(publishingRecord, false);

        try {
            this.scoringRuleService.removeScoringRule(retrievedScoringRule.getId());
            fail("exception should be thrown when trying to remove scoring rule data for an already locked assessment");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("cannot.be.altered.assessment.locked"));
        }
    }

    @Test
    public void getScoringRule() {
        final ScoringRule scoringRuleToSave = manufactureValidScoringRule();

        final ScoringRule savedScoringRule = this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
        assertThat(savedScoringRule, is(not(nullValue())));

        assertThat(this.scoringRuleService.getScoringRule(savedScoringRule.getId()), is(not(nullValue())));
        assertThat(this.scoringRuleService.getScoringRule("invalid-id"), is(nullValue()));
    }

    @Test
    public void searchScoringRules() {
        final List<ScoringRule> scoringRuleList = manufactureValidScoringRule(2);
        final ScoringRule scoringRuleToSave = scoringRuleList.get(0);

        final ScoringRule savedScoringRule = this.scoringRuleService.saveScoringRule(null, scoringRuleToSave);
        assertThat(savedScoringRule, is(not(nullValue())));

        final ScoringRule scoringRuleToSave2 = scoringRuleList.get(1);
        scoringRuleToSave2.setId(null);
        final ScoringRule savedScoringRule2 = this.scoringRuleService.saveScoringRule(null, scoringRuleToSave2);
        assertThat(savedScoringRule2, is(not(nullValue())));

        final Map<String, String[]> params = ImmutableMap.of("label", new String[] { savedScoringRule.getLabel() });
        final SearchResponse<ScoringRule> searchResponse = this.scoringRuleService.searchScoringRules(params);
        assertThat(searchResponse.getReturnCount(), is(1));
        assertThat(searchResponse.getSearchResults().size(), is(1));
    }

    private ScoringRule manufactureValidScoringRule() {
        return manufactureValidScoringRule(1).get(0);
    }

    private List<ScoringRule> manufactureValidScoringRule(final int i) {
        final List<ScoringRule> scoringRuleList = Lists.newArrayList();
        for (int j = 1; j < i + 1; j++) {
            final ScoringRule scoringRule = PODAM_FACTORY.manufacturePojo(ScoringRule.class);
            scoringRule.setId(null);
            scoringRule.setAssessmentId(this.savedAssessment.getId());
            scoringRule.setLabel("label" + j);
            scoringRule.setOrder(Integer.valueOf(j));
            scoringRule.setBlueprintReferenceType(BlueprintReferenceType.SEGMENT);
            scoringRule.setBlueprintDenotationType(null);
            scoringRule.setBlueprintReferenceId(this.savedSegment.getId());
            scoringRule.setComputationRule(null);
            scoringRule.setComputationRuleId(this.savedComputationRule.getId());
            scoringRule.setValueConversionTableGridFsId(this.valueFile.getId().toString());
            scoringRule.setStandardErrorConversionTableGridFsId(this.standardErrorFile.getId().toString());
            scoringRule.getParameters().clear();
            scoringRule.getParameters().add(manufactureValidScoringRuleParameter("parameter1", false, false));
            scoringRule.getParameters().add(new ScoringRuleParameter("parameter2", ComputationRuleMultiplicityType.SCALAR, "soleString"));
            scoringRule.getParameters().add(manufactureValidScoringRuleParameter("parameter3", true, false));
            scoringRule.getParameters().add(new ScoringRuleParameter("parameter4", ComputationRuleMultiplicityType.SCALAR, "11"));
            scoringRule.getParameters().add(manufactureValidScoringRuleParameter("parameter5", true, true));
            scoringRule.getParameters().add(new ScoringRuleParameter("parameter6", ComputationRuleMultiplicityType.SCALAR, "true"));
            scoringRuleList.add(scoringRule);
        }
        return scoringRuleList;
    }

    private ScoringRuleParameter manufactureValidScoringRuleParameter(final String parameterName, final boolean isIntegerKeyAndFloatVal, final boolean isBoolean) {
        final List<ScoringRuleDictionaryElement> scoringRuleDictionaryElementList = Lists.newArrayList();
        for (int ii = 0; ii < 5; ii++) {
            final String val = String.valueOf(ii + 1);
            scoringRuleDictionaryElementList.add(new ScoringRuleDictionaryElement(isIntegerKeyAndFloatVal ? val : "parameterValueKey" + val, isBoolean ? "true" : isIntegerKeyAndFloatVal ? val + ".99"
                    : val));
        }
        return new ScoringRuleParameter(parameterName, ComputationRuleMultiplicityType.DICTIONARY, scoringRuleDictionaryElementList);
    }

    private void saveGoodMinimalItemData() {
        final Item item = DomainFactory.manufactureValidItem(this.savedAssessment.getId());
        item.setId(null);
        final List<ItemLocation> itemLocationList = Lists.newArrayList();
        itemLocationList.add(new AdaptiveItemLocation(this.savedSegment.getId(), null, 0, 0));
        item.setItemLocation(itemLocationList);
        this.itemService.saveItem(item);
    }
}
