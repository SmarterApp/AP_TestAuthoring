/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.service.impl;

import static org.opentestsystem.authoring.testauth.config.TestAuthUtil.paramArray;

import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.authoring.testauth.domain.BlueprintElement;
import org.opentestsystem.authoring.testauth.domain.Form;
import org.opentestsystem.authoring.testauth.domain.FormPartition;
import org.opentestsystem.authoring.testauth.domain.ItemCountSummary;
import org.opentestsystem.authoring.testauth.domain.ValidationResult;
import org.opentestsystem.authoring.testauth.domain.search.FormSearchRequest;
import org.opentestsystem.authoring.testauth.domain.search.ItemSearchRequest;
import org.opentestsystem.authoring.testauth.persistence.FormRepository;
import org.opentestsystem.authoring.testauth.service.FormPartitionService;
import org.opentestsystem.authoring.testauth.service.FormService;
import org.opentestsystem.authoring.testauth.service.ItemService;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.exception.RestException;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.stereotype.Service;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;

@Service
public class FormServiceImpl extends AssessmentChildHelper implements FormService {

    private static final String FORM_PARTITION_ITEM_COUNT_MSG = "Partition: %s contains too %s %s items (%s).  The %s defined by the segment is %s.";
    private static final String BLUEPRINT_ITEM_COUNT_MSG = "Partition: %s contains too %s %s items (%s) for standard %s (grade %s).  The %s defined by the blueprint is %s.";

    @Autowired
    private transient FormRepository formRepository;

    @Autowired
    private transient FormPartitionService formPartitionService;

    @Autowired
    private transient ItemService itemService;

    @Override
    public Form saveForm(final String formId, final Form form) {
        // updating correct form?
        if (formId != null && (form == null || StringUtils.isEmpty(form.getId()) || !formId.equals(form.getId()))) {
            throw new LocalizedException("form.invalid.id");
        }

        checkForLockedAssessment(form.getAssessmentId());

        // save form
        Form savedForm = null;
        try {
            savedForm = this.formRepository.save(form);
        } catch (final DuplicateKeyException dke) {
            throw new LocalizedException("form.already.exists", new String[] { form.getAssessmentId(), form.getName() }, dke);
        }
        return savedForm;
    }

    @Override
    public void removeForm(final String formId) {
        final Form form = this.formRepository.findOne(formId);
        if (formId == null || form == null) {
            throw new LocalizedException("form.invalid.id");
        }

        checkForLockedAssessment(form.getAssessmentId());
        // remove form partitions associated with it
        this.formPartitionService.removeFormPartitionsByFormId(formId);
        this.formRepository.delete(formId);
    }

    @Override
    public void removeFormsByAssessmentId(final String assessmentId) {
        this.formRepository.delete(this.formRepository.findAllByAssessmentId(assessmentId));
    }

    @Override
    public Form getForm(final String formId) {
        final Form form = this.formRepository.findOne(formId);
        populateReferenceData(form);
        return form;
    }

    @Override
    public List<Form> getFormsByAssessmentId(final String assessmentId) {
        return this.formRepository.findAllByAssessmentId(assessmentId);
    }

    @Override
    public SearchResponse<Form> searchForms(final Map<String, String[]> requestMap) {
        final FormSearchRequest searchRequest = new FormSearchRequest(requestMap);
        if (searchRequest.isValid()) {
            final SearchResponse<Form> searchResponse = this.formRepository.search(searchRequest);
            return searchResponse;
        } else {
            throw new RestException("form.search.invalidSearchCriteria");
        }
    }

    @Override
    public void populateReferenceData(final List<Form> forms) {
        for (final Form form : forms) {
            populateReferenceData(form);
        }
    }

    @Override
    public void populateReferenceData(final Form form) {
        if (form != null && form.getId() != null) {
            form.setPartitions(this.formPartitionService.getFormPartitionsByFormId(form.getId()));
        }
    }

    @Override
    public List<Form> saveFormList(final List<Form> formList) {
        return this.formRepository.save(formList);
    }

    @Override
    public List<ValidationResult<FormPartition>> validateForms(final String assessmentId) {
        final List<ValidationResult<FormPartition>> validationList = Lists.newArrayList();

        final Map<String, Map<BlueprintElement, ItemCountSummary>> standardCounts = itemService.getFormPartitionStandardItemCounts(assessmentId);
        final List<FormPartition> formPartitionList = this.formPartitionService.getFormPartitionsByAssessmentId(assessmentId);

        for (final FormPartition formPartition : formPartitionList) {
            this.formPartitionService.populateReferenceData(formPartition);
            final long opItemCount = this.itemService.searchItems(new ItemSearchRequest(ImmutableMap.of("formPartitionId", paramArray(formPartition.getId()), 
                                                                                                        "fieldTestItem", paramArray("false"),
                                                                                                        "associatedItem", paramArray("false"))))
                    .getTotalCount();
            final long ftItemCount = this.itemService.searchItems(new ItemSearchRequest(ImmutableMap.of("formPartitionId", paramArray(formPartition.getId()),
                                                                                                        "fieldTestItem", paramArray("true"),
                                                                                                        "associatedItem", paramArray("false"))))
                    .getTotalCount();

            // validate segment min/max ranges
            if (opItemCount < formPartition.getSegment().getMinOpItems()) {
                validationList.add(new ValidationResult<FormPartition>(formPartition, String.format(FORM_PARTITION_ITEM_COUNT_MSG,
                        formPartition.getForm().getName() + " - " + formPartition.getName(), "few", "OP", opItemCount, "minimum", formPartition.getSegment().getMinOpItems())));
            }
            if (opItemCount > formPartition.getSegment().getMaxOpItems()) {
                validationList.add(new ValidationResult<FormPartition>(formPartition, String.format(FORM_PARTITION_ITEM_COUNT_MSG,
                        formPartition.getForm().getName() + " - " + formPartition.getName(), "many", "OP", opItemCount, "maximum", formPartition.getSegment().getMaxOpItems())));
            }
            if (ftItemCount < formPartition.getSegment().getMinFtItems()) {
                validationList.add(new ValidationResult<FormPartition>(formPartition, String.format(FORM_PARTITION_ITEM_COUNT_MSG,
                        formPartition.getForm().getName() + " - " + formPartition.getName(), "few", "FT", ftItemCount, "minimum", formPartition.getSegment().getMinFtItems())));

            }
            if (ftItemCount > formPartition.getSegment().getMaxFtItems()) {
                validationList.add(new ValidationResult<FormPartition>(formPartition, String.format(FORM_PARTITION_ITEM_COUNT_MSG,
                        formPartition.getForm().getName() + " - " + formPartition.getName(), "many", "FT", ftItemCount, "maximum", formPartition.getSegment().getMaxFtItems())));
            }

            // validate bp standard min/max ranges
            for (final Entry<BlueprintElement, ItemCountSummary> entry : standardCounts.get(formPartition.getId()).entrySet()) {
                final BlueprintElement standard = entry.getKey();
                final ItemCountSummary standardCount = entry.getValue();
                if (standardCount.getOpCount() < standardCount.getOpMin()) {
                    validationList.add(new ValidationResult<FormPartition>(
                            formPartition,
                            String.format(BLUEPRINT_ITEM_COUNT_MSG,
                                    formPartition.getForm().getName() + " - " + formPartition.getName(), "few", "OP", standardCount.getOpCount(),
                                    standard.getStandardKey(), standard.getGrade(), "minimum", standardCount.getOpMin()),
                            ValidationResult.WARNING_LEVEL));
                }
                if (standardCount.getOpCount() > standardCount.getOpMax()) {
                    validationList.add(new ValidationResult<FormPartition>(
                            formPartition,
                            String.format(BLUEPRINT_ITEM_COUNT_MSG,
                                    formPartition.getForm().getName() + " - " + formPartition.getName(), "many", "OP", standardCount.getOpCount(),
                                    standard.getStandardKey(), standard.getGrade(), "maximum", standardCount.getOpMax()),
                            ValidationResult.WARNING_LEVEL));
                }
                if (standardCount.getFtCount() < standardCount.getFtMin()) {
                    validationList.add(new ValidationResult<FormPartition>(
                            formPartition,
                            String.format(BLUEPRINT_ITEM_COUNT_MSG,
                                    formPartition.getForm().getName() + " - " + formPartition.getName(), "few", "FT", standardCount.getFtCount(),
                                    standard.getStandardKey(), standard.getGrade(), "minimum", standardCount.getFtMin()),
                            ValidationResult.WARNING_LEVEL));

                }
                if (standardCount.getFtCount() > standardCount.getFtMax()) {
                    validationList.add(new ValidationResult<FormPartition>(
                            formPartition,
                            String.format(BLUEPRINT_ITEM_COUNT_MSG,
                                    formPartition.getForm().getName() + " - " + formPartition.getName(), "many", "FT", standardCount.getFtCount(),
                                    standard.getStandardKey(), standard.getGrade(), "maximum", standardCount.getFtMax()),
                            ValidationResult.WARNING_LEVEL));
                }
            }
        }

        return validationList;
    }
}
