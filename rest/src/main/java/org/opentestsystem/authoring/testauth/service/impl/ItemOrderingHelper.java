/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.service.impl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.authoring.testauth.domain.AdaptiveItemLocation;
import org.opentestsystem.authoring.testauth.domain.FixedFormItemLocation;
import org.opentestsystem.authoring.testauth.domain.Item;
import org.opentestsystem.authoring.testauth.domain.ItemLocation;
import org.opentestsystem.authoring.testauth.domain.ItemMoveRequest;
import org.opentestsystem.authoring.testauth.domain.ItemMoveResponse;
import org.opentestsystem.authoring.testauth.persistence.ItemRepository;
import org.opentestsystem.authoring.testauth.service.FormPartitionService;
import org.opentestsystem.authoring.testauth.service.ItemGroupService;
import org.opentestsystem.authoring.testauth.service.PublicationService;
import org.opentestsystem.authoring.testauth.service.TibItemService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;

@Component
public class ItemOrderingHelper extends ItemBaseHelper {

    @Autowired
    private transient ItemRepository itemRepository;

    @Autowired
    private ItemGroupService itemGroupService;

    @Autowired
    private TibItemService tibItemService;

    @Autowired
    private PublicationService publicationService;

    @Autowired
    private FormPartitionService formPartitionService;

    protected void reindexSortOrderPartition(final String assessmentId, final String formPartitionId) {
        final List<Item> items = this.itemRepository.findAllByFormPartitionId(formPartitionId);
        final List<ItemLocation> itemsOnPartition = getItemLocationsOnPartition(formPartitionId, items);
        reindexSortOrder(itemsOnPartition);
        updateItemLocationSortingInformation(assessmentId, items, itemsOnPartition);
    }
    
    protected void reindexSortOrderSegmemt(final String assessmentId, final String segmentId) {
        final List<Item> items = this.itemRepository.findAllBySegmentId(segmentId);
        final List<ItemLocation> itemsOnPartition = getItemLocationsOnSegment(segmentId, items);
        reindexSortOrder(itemsOnPartition);
        updateItemLocationSortingInformation(assessmentId, items, itemsOnPartition);
    }

    private void reindexSortOrder(final List<ItemLocation> itemLocations) {
        final List<ItemLocation> sortedItemLocations = ItemHelper.LOCATION_ORDER.sortedCopy(itemLocations);
        int index1 = 0;
        int index2 = 0;
        String currentGroupId = Item.NO_GROUP_KEY;
        for (final ItemLocation loc : sortedItemLocations) {
            if (!Item.NO_GROUP_KEY.equals(loc.getItemGroupId()) && currentGroupId.equals(loc.getItemGroupId())) {

            } else {
                index1++;
                index2 = 0;
            }
            index2++;
            loc.setLevel1SortIndex(index1);
            loc.setLevel2SortIndex(index2);
            currentGroupId = loc.getItemGroupId();
        }
    }

    protected void updateItemLocationSortingInformation(final String assessmentId, final List<Item> allItemsInLocation, final List<ItemLocation> itemLocationsToSort) {
        final HashMap<String, List<ItemLocation>> locationsById = new HashMap<String, List<ItemLocation>>();
        for (final ItemLocation locationToUpdate : itemLocationsToSort) {
            List<ItemLocation> locationList = locationsById.get(locationToUpdate.getItemIdentifier());
            if (locationList == null) {
                locationList = new ArrayList<ItemLocation>();
                locationsById.put(locationToUpdate.getItemIdentifier(), locationList);
            }
            locationList.add(locationToUpdate);
        }
        for (final Item item : allItemsInLocation) {
            if (locationsById.get(item.getTibIdentifier()) != null) {
                for (final ItemLocation cloc : item.getItemLocation()) {
                    for (final ItemLocation locWithNewValues : locationsById.get(item.getTibIdentifier())) {
                        if (cloc.isSameLocation(locWithNewValues)) {
                            cloc.setLevel1SortIndex(locWithNewValues.getLevel1SortIndex());
                            cloc.setLevel2SortIndex(locWithNewValues.getLevel2SortIndex());
                        }
                    }
                }
                this.itemRepository.save(item);
            }
        }
    }

    protected ItemMoveResponse moveSegmentPoolItems(final String assessmentId, final ItemMoveRequest moveRequest) {
        ItemMoveResponse response;
        if (hasValidMoveInformation(moveRequest)) {
            final AdaptiveItemLocation target = new AdaptiveItemLocation();
            target.setSegmentId(moveRequest.getTargetLocationId());
            target.setItemGroupId(moveRequest.getTargetGroupId());

            final AdaptiveItemLocation source = new AdaptiveItemLocation();
            source.setSegmentId(moveRequest.getSourceLocationId());
            source.setItemGroupId(moveRequest.getSourceGroupId());
            response = moveItems(assessmentId, source, target, moveRequest.getItemMetadataIds());

            autoSortSegmentItems(assessmentId, source.getSegmentId());
            if (!source.getSegmentId().equals(target.getSegmentId())) {
                autoSortSegmentItems(assessmentId, target.getSegmentId());
            }
            
        } else {
            response = new ItemMoveResponse();
            response.setMessage("Unable to move items, source and destination required");
        }
        return response;
    }

    protected ItemMoveResponse moveFormPartitionItems(final String assessmentId, final ItemMoveRequest moveRequest) {
        ItemMoveResponse response;
        if (hasValidMoveInformation(moveRequest)) {
            final FixedFormItemLocation target = new FixedFormItemLocation();
            target.setFormPartitionId(moveRequest.getTargetLocationId());
            target.setItemGroupId(moveRequest.getTargetGroupId());

            final FixedFormItemLocation source = new FixedFormItemLocation();
            source.setFormPartitionId(moveRequest.getSourceLocationId());
            source.setItemGroupId(moveRequest.getSourceGroupId());
            response = moveItems(assessmentId, source, target, moveRequest.getItemMetadataIds());

            autoSortFormPartitionItems(assessmentId, source.getFormPartitionId());
            if (!source.getFormPartitionId().equals(target.getFormPartitionId())) {
                autoSortFormPartitionItems(assessmentId, target.getFormPartitionId());
            }
        } else {
            response = new ItemMoveResponse();
            response.setMessage("Unable to move items, source and destination required");
        }
        return response;
    }

    
    protected void autoSortFormPartitionItems(final String assessmentId, final String formPartitionId){
        final List<Item> items = this.itemRepository.findAllByFormPartitionId(formPartitionId);
        final List<ItemLocation> itemsOnPartition = getItemLocationsOnPartition(formPartitionId, items);     
        autoSortItems(assessmentId, items, itemsOnPartition);
    }
    
    protected void autoSortSegmentItems(final String assessmentId, final String segmentId){
        final List<Item> items = this.itemRepository.findAllBySegmentId(segmentId);
        final List<ItemLocation> itemsOnSegment = getItemLocationsOnSegment(segmentId, items);     
        autoSortItems(assessmentId, items, itemsOnSegment);
    }
    
    private void autoSortItems(final String assessmentId, final List<Item> allItems, final List<ItemLocation> itemLocation) {
        final HashMap<String, Integer> groupPosistionMap = Maps.newHashMap();
        final HashMap<Integer, Integer> secondLevelCounterMap = Maps.newHashMap();
        final List<ItemLocation> needsSorting = Lists.newArrayList();

        int firstLevelCounter = 0;
        for (final ItemLocation loc : itemLocation) {
            if (loc.getLevel1SortIndex() == 0 || loc.getLevel2SortIndex() == 0) {
                needsSorting.add(loc);
            } else {
                if (loc.getLevel1SortIndex() > firstLevelCounter) {
                    firstLevelCounter = loc.getLevel1SortIndex();
                }
                if (!Item.NO_GROUP_KEY.equals(loc.getItemGroupId())) {
                    groupPosistionMap.put(loc.getItemGroupId(), loc.getLevel1SortIndex());
                }
                if (secondLevelCounterMap.get(loc.getLevel1SortIndex()) == null
                        || secondLevelCounterMap.get(loc.getLevel1SortIndex()) < loc.getLevel2SortIndex()) {
                    secondLevelCounterMap.put(loc.getLevel1SortIndex(), loc.getLevel2SortIndex());
                }
            }
        }

        for (final ItemLocation locationToSort : needsSorting) {
            if (Item.NO_GROUP_KEY.equals(locationToSort.getItemGroupId())) {
                // no group
                firstLevelCounter++;
                locationToSort.setLevel1SortIndex(firstLevelCounter);
                locationToSort.setLevel2SortIndex(1);
            } else {
                final Integer groupPosition = groupPosistionMap.get(locationToSort.getItemGroupId());
                if (groupPosition == null) {
                    firstLevelCounter++;
                    locationToSort.setLevel1SortIndex(firstLevelCounter);
                    groupPosistionMap.put(locationToSort.getItemGroupId(), firstLevelCounter);
                    secondLevelCounterMap.put(firstLevelCounter, 1);
                    locationToSort.setLevel2SortIndex(1);
                } else {
                    locationToSort.setLevel1SortIndex(groupPosition);
                    final int nextValue = secondLevelCounterMap.get(groupPosition) + 1;
                    locationToSort.setLevel2SortIndex(nextValue);
                    secondLevelCounterMap.put(groupPosition, nextValue);
                }
            }
        }
        reindexSortOrder(itemLocation);
        updateItemLocationSortingInformation(assessmentId, allItems, itemLocation);
    }

    protected ItemMoveResponse moveItems(final String assessmentId, final ItemLocation source, final ItemLocation target, final List<String> itemIdsToMove) {
        final ItemMoveResponse response = new ItemMoveResponse();
        int omitted = 0;
        int moved = 0;
        if (!CollectionUtils.isEmpty(itemIdsToMove)) {
            for (final String itemId : itemIdsToMove) {
                source.setItemIdentifier(itemId);
                target.setItemIdentifier(itemId);
                if (moveItem(assessmentId, source, target)) {
                    moved++;
                } else {
                    omitted++;
                }
            }
        }
        response.setItemsImpacted(moved);
        response.setItemsOmitted(omitted);
        return response;
    }

    private boolean moveItem(final String assessmentId, final ItemLocation source, final ItemLocation target) {
        boolean moved = false;
        final Item item = getItemByAssessmentIdAndTibIdentifier(assessmentId, source.getItemIdentifier());
        if (!hasLocation(item, target)) {
            for (final ItemLocation existingLocation : item.getItemLocation()) {
                if (existingLocation.isSameLocation(source)) {
                    existingLocation.updateLocation(target);
                    saveItem(item);
                    moved = true;
                    break;
                }
            }
        }
        return moved;
    }

    private boolean hasValidMoveInformation(final ItemMoveRequest itemMoveRequest) {
        return StringUtils.isNotBlank(itemMoveRequest.getTargetLocationId())
                && StringUtils.isNotBlank(itemMoveRequest.getTargetGroupId())
                && StringUtils.isNotBlank(itemMoveRequest.getSourceLocationId())
                && StringUtils.isNotBlank(itemMoveRequest.getSourceGroupId());
    }

}
