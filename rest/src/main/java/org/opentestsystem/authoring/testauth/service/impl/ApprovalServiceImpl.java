/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.service.impl;

import static org.opentestsystem.shared.search.domain.AbstractSearchRequest.SORT_DIR;

import java.util.List;
import java.util.Map;

import org.apache.commons.lang.StringUtils;
import org.joda.time.DateTime;
import org.opentestsystem.authoring.testauth.config.TestAuthUtil;
import org.opentestsystem.authoring.testauth.domain.Approval;
import org.opentestsystem.authoring.testauth.domain.ApprovalStatus;
import org.opentestsystem.authoring.testauth.domain.Assessment;
import org.opentestsystem.authoring.testauth.domain.Permissions;
import org.opentestsystem.authoring.testauth.domain.PublishingRecord;
import org.opentestsystem.authoring.testauth.domain.PublishingStatus;
import org.opentestsystem.authoring.testauth.domain.search.ApprovalSearchRequest;
import org.opentestsystem.authoring.testauth.persistence.ApprovalRepository;
import org.opentestsystem.authoring.testauth.persistence.AssessmentRepository;
import org.opentestsystem.authoring.testauth.persistence.PublishingRecordRepository;
import org.opentestsystem.authoring.testauth.service.ApprovalService;
import org.opentestsystem.authoring.testauth.service.AssessmentService;
import org.opentestsystem.authoring.testauth.service.PublishingRecordService;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.exception.RestException;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.opentestsystem.shared.security.domain.SbacUser;
import org.opentestsystem.shared.security.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;

@Service
public class ApprovalServiceImpl implements ApprovalService {

    @Autowired
    private transient AssessmentService assessmentService;

    @Autowired
    private transient AssessmentRepository assessmentRepository;

    @Autowired
    private transient PublishingRecordService publishingRecordService;

    @Autowired
    private transient PublishingRecordRepository publishingRecordRepository;

    @Autowired
    private transient UserService userService;

    @Autowired
    private transient ApprovalRepository approvalRepository;

    private enum ApprovalLevel {
        CONTENT_APPROVAL(1, Permissions.CONTENT_LEAD),
        PSYCHOMETRIC_APPROVAL(1, Permissions.PSYCHOMETRIC_LEAD),
        QALEAD_APPROVAL(2, Permissions.QA_LEAD);

        private ApprovalLevel(final int inLevel, final Permissions inPermission) {
            this.level = inLevel;
            this.permission = inPermission.toSpringRoleName();
            this.permissionLabel = inPermission.getTitle();
        }

        private final int level;
        private final String permission;
        private final String permissionLabel;
    }

    @Override
    public Approval getApproval(final String approvalId) {
        return this.approvalRepository.findOne(approvalId);
    }

    @Override
    public SearchResponse<Approval> searchApprovals(final Map<String, String[]> parameterMap) {
        final ApprovalSearchRequest searchRequest = new ApprovalSearchRequest(parameterMap);
        if (searchRequest.isValid()) {
            return this.approvalRepository.search(searchRequest);
        }
        throw new RestException("approval.search.invalidSearchCriteria");
    }

    @Override
    public Approval updateApproval(final Approval approval) {
        final SbacUser user = this.userService.getCurrentUser();

        Approval savedApproval = null;
        if (user.hasPermission(approval.getPermission())) {

            if (!approvalIsEditable(approval)) {
                throw new RestException("approval.approve.canBeEdited");
            }
            if (!approvalCanBeApproved(approval, approval.getLevel())) {
                throw new RestException("approval.approve.canBeApproved");
            }
            if (StringUtils.isBlank(approval.getMessage())) {
                throw new LocalizedException("approval.message.required");
            }
            approval.setLastUpdatedDate(new DateTime());

            // save new approval, overwrite if pending
            if (StringUtils.isNotBlank(approval.getId())) {
                final Approval existingApproval = getApproval(approval.getId());
                if (!ApprovalStatus.PENDING.equals(existingApproval.getStatus())) {
                    approval.setId(null);
                }
            }
            savedApproval = this.approvalRepository.save(approval);
            final PublishingRecord currentPublishingRecord = this.publishingRecordService.getPublishingRecord(approval.getPublishingRecordId());
            currentPublishingRecord.setErrorMessageText(null);
            if (canPublishToSpecBank(savedApproval.getPublishingRecordId())) {
                this.publishingRecordService.savePublishingRecord(currentPublishingRecord, false);
            } else if (ApprovalStatus.REJECTED.equals(approval.getStatus())) {
                currentPublishingRecord.setPublishingStatus(PublishingStatus.REJECT);
                Assessment assessment = assessmentService.getAssessment(currentPublishingRecord.getAssessmentId());
                assessment.setStatus(PublishingStatus.REJECT);
                this.assessmentRepository.save(assessment);
                this.publishingRecordService.savePublishingRecord(currentPublishingRecord, false);
            } else {
                this.publishingRecordRepository.save(currentPublishingRecord);
            }
            return savedApproval;
        }
        throw new RestException("approval.approve.notAuthorized");
    }

    @Override
    public void removeByAssessmentId(final String assessmentId) {
        this.approvalRepository.delete(this.approvalRepository.findAllByAssessmentId(assessmentId));
    }

    @Override
    public List<Approval> createInitialApprovals(final String publishingRecordId) {
        final PublishingRecord publishingRecord = this.publishingRecordService.getPublishingRecord(publishingRecordId);
        final List<Approval> initialApprovals = Lists.newArrayList();

        for (final ApprovalLevel approvalLevel : ApprovalLevel.values()) {
            final Approval approval = new Approval();
            approval.setAssessmentId(publishingRecord.getAssessmentId());
            approval.setPublishingRecordId(publishingRecord.getId());
            approval.setStatus(ApprovalStatus.PENDING);
            approval.setPermission(approvalLevel.permission);
            approval.setPermissionLabel(approvalLevel.permissionLabel);
            approval.setLastUpdatedDate(new DateTime());
            approval.setUsername("");
            approval.setVersion(publishingRecord.getVersion());
            approval.setLevel(approvalLevel.level);
            approval.setMessage("");

            final Approval savedApproval = this.approvalRepository.save(approval);
            initialApprovals.add(savedApproval);
        }
        return initialApprovals;
    }

    @Override
    public List<Approval> retrieveLatestApprovals(final String publishingRecordId) {
        final List<Approval> approvalList = Lists.newArrayList();
        final Map<String, Boolean> foundMap = Maps.newHashMap();

        if (publishingRecordId != null) {
            final Map<String, String[]> parameterMap = ImmutableMap.of("publishingRecordId", new String[] { publishingRecordId }, "sortKey", new String[] { "lastUpdatedDate" }, SORT_DIR,
                    TestAuthUtil.paramArray("DESC"));
            final SearchResponse<Approval> searchResponse = searchApprovals(parameterMap);

            for (final Approval approval : searchResponse.getSearchResults()) {
                if (foundMap.get(approval.getPermission()) == null) {
                    approvalList.add(approval);
                    foundMap.put(approval.getPermission(), true);
                }

                if (allApprovalsFound(foundMap)) {
                    return approvalList;
                }
            }
        }
        return approvalList;
    }

    @Override
    public boolean canPublishToSpecBank(final String publishingRecordId) {
        final List<Approval> approvalList = retrieveLatestApprovals(publishingRecordId);

        if (approvalList.size() == 0) {
            return false;
        }

        for (final Approval approval : approvalList) {
            if (!ApprovalStatus.APPROVED.equals(approval.getStatus())) {
                return false;
            }
        }
        return true;
    }

    @Override
    public boolean isAdminUser() {
        final SbacUser user = this.userService.getCurrentUser();

        for (final ApprovalLevel approvalLevel : ApprovalLevel.values()) {
            if (user.hasPermission(approvalLevel.permission)) {
                return true;
            }
        }
        return false;
    }

    private boolean allApprovalsFound(final Map<String, Boolean> foundMap) {
        for (final ApprovalLevel approvalLevel : ApprovalLevel.values()) {
            if (!foundMap.containsKey(approvalLevel.permission)) {
                return false;
            }
        }
        return true;
    }

    private boolean approvalCanBeApproved(final Approval currentApproval, int level) {
        if (level-- > 1) {
            final List<Approval> approvalList = retrieveLatestApprovals(currentApproval.getPublishingRecordId());

            for (final Approval approval : approvalList) {
                if (level == approval.getLevel() && !ApprovalStatus.APPROVED.equals(approval.getStatus())) {
                    return false;
                }
            }
            return approvalCanBeApproved(currentApproval, level);
        }
        return true;
    }

    private boolean approvalIsEditable(final Approval currentApproval) {
        final PublishingRecord publishingRecord = this.publishingRecordService.getPublishingRecord(currentApproval.getPublishingRecordId());
        return PublishingStatus.AWAITING_APPROVAL.equals(publishingRecord.getPublishingStatus());
    }
}
