/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.service.impl;

import java.util.List;
import java.util.Map;

import org.joda.time.DateTime;
import org.opentestsystem.authoring.testauth.domain.Assessment;
import org.opentestsystem.authoring.testauth.domain.FileGroup;
import org.opentestsystem.authoring.testauth.domain.GridFile;
import org.opentestsystem.authoring.testauth.domain.PsychometricRecord;
import org.opentestsystem.authoring.testauth.domain.PublishingRecord;
import org.opentestsystem.authoring.testauth.domain.PublishingStatus;
import org.opentestsystem.authoring.testauth.domain.SimulationRecord;
import org.opentestsystem.authoring.testauth.domain.search.FileGroupSearchRequest;
import org.opentestsystem.authoring.testauth.persistence.FileGroupRepository;
import org.opentestsystem.authoring.testauth.persistence.GridFsRepository;
import org.opentestsystem.authoring.testauth.persistence.PsychometricRecordRepository;
import org.opentestsystem.authoring.testauth.persistence.PublishingRecordRepository;
import org.opentestsystem.authoring.testauth.persistence.SimulationRecordRepository;
import org.opentestsystem.authoring.testauth.service.AssessmentService;
import org.opentestsystem.authoring.testauth.service.FileGroupService;
import org.opentestsystem.authoring.testauth.service.PublishingRecordService;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.exception.RestException;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.mongodb.DBObject;
import com.mongodb.gridfs.GridFSDBFile;
import com.mongodb.gridfs.GridFSFile;

@Service
public class FileGroupServiceImpl extends AssessmentChildHelper implements FileGroupService {

    @Autowired
    private transient FileGroupRepository fileGroupRepository;

    @Autowired
    private transient GridFsRepository gridFsRepository;

    @Autowired
    private transient SimulationRecordRepository simulationRecordRepository;

    @Autowired
    private transient PsychometricRecordRepository psychometricRecordRepository;

    @Autowired
    private transient PublishingRecordRepository publishingRecordRepository;

    @Autowired
    private transient AssessmentService assessmentService;

    @Autowired
    private transient PublishingRecordService publishingRecordService;

    @Override
    public FileGroup getFileGroup(final String fileGroupId) {
        return this.fileGroupRepository.findOne(fileGroupId);
    }

    @Override
    public FileGroup saveFileGroup(final FileGroup fileGroup) {
        fileGroup.setCreateDate(new DateTime());
        return this.fileGroupRepository.save(fileGroup);
    }

    @Override
    public void removeFileGroup(final String fileGroupId) {
        final FileGroup fileGroup = this.fileGroupRepository.findOne(fileGroupId);
        if (fileGroup.getSimulationRecordId() != null) {
            if (!canRemoveSimulationFileGroup(fileGroup.getSimulationRecordId())) {
                throw new LocalizedException("fileGroup.cannot.remove.simulation");
            }
        } else if (fileGroup.getPsychometricRecordId() != null) {
            if (!canRemovePsychometricFileGroup(fileGroup.getPsychometricRecordId())) {
                throw new LocalizedException("fileGroup.cannot.remove.psychometric");
            }
        }
        deleteGridFsFiles(getFileGroup(fileGroupId));
        this.fileGroupRepository.delete(fileGroupId);
    }

    @Override
    public void removeFileGroupByAssessmentId(final String assessmentId) {
        final List<SimulationRecord> simulationRecordList = this.simulationRecordRepository.findAllByAssessmentId(assessmentId);
        if (!CollectionUtils.isEmpty(simulationRecordList)) {
            for (final SimulationRecord simulationRecord : simulationRecordList) {
                final List<FileGroup> fileGroupList = this.fileGroupRepository.findAllBySimulationRecordId(simulationRecord.getId());
                for (final FileGroup fileGroup : fileGroupList) {
                    deleteGridFsFiles(getFileGroup(fileGroup.getId()));
                }
                this.fileGroupRepository.delete(fileGroupList);
            }
            this.simulationRecordRepository.delete(simulationRecordList);
        }
    }

    @Override
    public SearchResponse<FileGroup> searchFileGroups(final Map<String, String[]> parameterMap) {
        final FileGroupSearchRequest searchRequest = new FileGroupSearchRequest(parameterMap);
        if (searchRequest.isValid()) {
            return this.fileGroupRepository.search(searchRequest);
        } else {
            throw new RestException("fileGroup.search.invalidSearchCriteria");
        }
    }

    @Override
    public GridFSDBFile getGridFsFile(final String inGridFSId) {
        return this.gridFsRepository.getById(inGridFSId);
    }

    @Override
    public GridFSFile saveGridFsFile(final String fileName, final byte[] inBytes, final String fileContentType) {
        final DBObject metadata = null;
        final GridFSFile gridFsFile = this.gridFsRepository.save(inBytes, fileName, fileContentType, metadata);
        return gridFsFile;
    }

    @Override
    public void deleteGridFsFile(final String gridFsId) {
        this.gridFsRepository.delete(gridFsId);
    }

    private void deleteGridFsFiles(final FileGroup fileGroup) {
        if (fileGroup.getGridFiles() != null) {
            for (final GridFile gridFile : fileGroup.getGridFiles()) {
                if (gridFile.getGridFsId() != null) {
                    deleteGridFsFile(gridFile.getGridFsId());
                }
            }
        }
    }

    /************************************** Simulation Record Services **************************************/
    @Override
    public SimulationRecord getSimulationRecord(final String simulationRecordId) {
        return this.simulationRecordRepository.findOne(simulationRecordId);
    }

    @Override
    public SimulationRecord getSimulationRecordByAssessmentId(final String assessmentId) {
        final List<SimulationRecord> simulationRecords = this.simulationRecordRepository.findAllByAssessmentId(assessmentId);
        if (simulationRecords.size() > 0) {
            return simulationRecords.get(0);
        }
        return null;
    }

    @Override
    public SimulationRecord saveSimulationRecord(final SimulationRecord simulationRecord) {
        if (simulationRecord.getAssessmentId() != null) {
            checkForLockedAssessment(simulationRecord.getAssessmentId());
            final PublishingRecord pubRec = this.publishingRecordService.retrieveCurrentPublishingRecord(simulationRecord.getAssessmentId());
            simulationRecord.setVersion(pubRec.getVersion());

            simulationRecord.setLastUploadDate(new DateTime());
            return this.simulationRecordRepository.save(simulationRecord);
        }
        return simulationRecord;
    }

    @Override
    public void removeSimulationRecord(final String simulationRecordId) {
        final SimulationRecord simulationRecord = getSimulationRecord(simulationRecordId);

        checkForLockedAssessment(simulationRecord.getAssessmentId());

        for (final FileGroup fileGroup : this.fileGroupRepository.findAllBySimulationRecordId(simulationRecordId)) {
            removeFileGroup(fileGroup.getId());
        }
        this.simulationRecordRepository.delete(this.simulationRecordRepository.findOne(simulationRecordId));
    }

    private boolean canRemoveSimulationFileGroup(final String simulationRecordId) {
        final SimulationRecord simulationRecord = getSimulationRecord(simulationRecordId);
        final Assessment existingAssessment = this.assessmentService.getAssessment(simulationRecord.getAssessmentId());
        return existingAssessment != null && !existingAssessment.isLocked();
    }

    /********************************************************************************************************/

    /************************************** Psychometric Record Services **************************************/
    @Override
    public PsychometricRecord getPsychometricRecord(final String psychometricRecordId) {
        return this.psychometricRecordRepository.findOne(psychometricRecordId);
    }

    @Override
    public PsychometricRecord getPsychometricRecordByPublishingRecordId(final String publishingRecordId) {
        final List<PsychometricRecord> psychometricRecords = this.psychometricRecordRepository.findAllByPublishingRecordId(publishingRecordId);
        if (psychometricRecords.size() > 0) {
            return psychometricRecords.get(0);
        }
        return null;
    }

    @Override
    public PsychometricRecord savePsychometricRecord(final PsychometricRecord psychometricRecord) {
        if (psychometricRecord.getPublishingRecordId() != null) {
            final PublishingRecord existingPublishingRecord = this.publishingRecordService.getPublishingRecord(psychometricRecord.getPublishingRecordId());
            if (existingPublishingRecord != null && !PublishingStatus.PUBLISHED.equals(existingPublishingRecord.getPublishingStatus())) {
                throw new LocalizedException("assessment.must.be.published");
            }
            final PublishingRecord pubRec = this.publishingRecordService.getPublishingRecord(psychometricRecord.getPublishingRecordId());
            psychometricRecord.setVersion(pubRec.getVersion());

            psychometricRecord.setLastUploadDate(new DateTime());
            return this.psychometricRecordRepository.save(psychometricRecord);
        }
        return psychometricRecord;
    }

    @Override
    public void removePsychometricRecord(final String psychometricRecordId) {
        for (final FileGroup fileGroup : this.fileGroupRepository.findAllByPsychometricRecordId(psychometricRecordId)) {
            removeFileGroup(fileGroup.getId());
        }
        this.psychometricRecordRepository.delete(this.psychometricRecordRepository.findOne(psychometricRecordId));
    }

    @Override
    public SearchResponse<FileGroup> searchPsychometricRecordFileGroupsByVersion(final Map<String, String[]> parameterMap) {

        final SearchResponse<PublishingRecord> publishingRecordResponse = this.publishingRecordService.searchPublishingRecords(getPublishingRecordSearchParams(parameterMap));

        for (final PublishingRecord publishingRecord : publishingRecordResponse.getSearchResults()) {
            final PsychometricRecord psychometricRecord = getPsychometricRecordByPublishingRecordId(publishingRecord.getId());
            if (psychometricRecord != null) {
                final Map<String, String[]> updatedParams = Maps.newHashMap();
                updatedParams.putAll(Maps.difference(parameterMap, updatedParams).entriesOnlyOnLeft());
                updatedParams.put("psychometricRecordId", new String[] { psychometricRecord.getId() });
                updatedParams.remove("assessmentId");
                updatedParams.remove("version");
                return searchFileGroups(updatedParams);
            }
        }
        return searchFileGroups(ImmutableMap.of("psychometricRecordId", new String[] { "invalid-psychometric-id" }));
    }

    @Override
    public List<String> getPsychometricRecordVersions(final String assessmentId) {
        final List<String> versionList = Lists.newArrayList();
        final List<PublishingRecord> publishingRecordList = this.publishingRecordRepository.findAllByAssessmentId(assessmentId);

        for (final PublishingRecord publishingRecord : publishingRecordList) {
            final List<PsychometricRecord> psychometricRecordList = this.psychometricRecordRepository.findAllByPublishingRecordId(publishingRecord.getId());

            for (final PsychometricRecord psychometricRecord : psychometricRecordList) {
                versionList.add(psychometricRecord.getVersion());
            }
        }
        return versionList;
    }

    private boolean canRemovePsychometricFileGroup(final String psychometricRecordId) {
        final PsychometricRecord psychometricRecord = getPsychometricRecord(psychometricRecordId);
        final PublishingRecord existingPublishingRecord = this.publishingRecordService.getPublishingRecord(psychometricRecord.getPublishingRecordId());
        return existingPublishingRecord != null && PublishingStatus.PUBLISHED.equals(existingPublishingRecord.getPublishingStatus());
    }

    /********************************************************************************************************/

    private Map<String, String[]> getPublishingRecordSearchParams(final Map<String, String[]> parameterMap) {
        final Map<String, String[]> publishingRecordParams = Maps.newHashMap();
        publishingRecordParams.putAll(Maps.difference(parameterMap, publishingRecordParams).entriesOnlyOnLeft());

        publishingRecordParams.put("currentPage", new String[] { "0" });
        publishingRecordParams.put("pageSize", new String[] { "9999" });
        publishingRecordParams.put("sortKey", new String[] { "version" });
        publishingRecordParams.remove("psychometricRecordId");
        return publishingRecordParams;
    }

}
