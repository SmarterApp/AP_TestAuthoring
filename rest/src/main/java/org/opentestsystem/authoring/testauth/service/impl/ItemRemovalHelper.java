/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.service.impl;

import static org.opentestsystem.authoring.testauth.service.impl.ItemHelper.ENEMY_ID_TRANSFORMER;

import java.util.List;
import java.util.Set;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.authoring.testauth.config.TestAuthUtil;
import org.opentestsystem.authoring.testauth.domain.AdaptiveItemLocation;
import org.opentestsystem.authoring.testauth.domain.Enemy;
import org.opentestsystem.authoring.testauth.domain.FixedFormItemLocation;
import org.opentestsystem.authoring.testauth.domain.Item;
import org.opentestsystem.authoring.testauth.domain.ItemLocation;
import org.opentestsystem.authoring.testauth.domain.ItemMoveRequest;
import org.opentestsystem.authoring.testauth.domain.ItemMoveResponse;
import org.opentestsystem.authoring.testauth.persistence.ItemRepository;
import org.opentestsystem.authoring.testauth.service.EnemyService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;

import com.google.common.base.Predicate;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;

@Component
public class ItemRemovalHelper extends ItemBaseHelper {

    @Autowired
    private transient ItemRepository itemRepository;

    @Autowired
    private ItemOrderingHelper itemOrderingHelper;

    @Autowired
    private EnemyService enemyService;

    protected void removeByFilter(final List<Item> items, final Predicate<ItemLocation> locationRemovalFilter) {
        final List<Item> itemsToRemove = Lists.newArrayList();
        final List<Item> itemsToSave = Lists.newArrayList();
        for (final Item item : items) {
            final List<ItemLocation> itemLocationToRemove = Lists.newArrayList();
            for (final ItemLocation location : item.getItemLocation()) {
                if (location != null) {
                    if (locationRemovalFilter.apply(location)) {
                        // remove the enemies associated with this segment/item
                        itemLocationToRemove.add(location);
                    }
                }
            }
            item.getItemLocation().removeAll(itemLocationToRemove);
            if (CollectionUtils.isEmpty(item.getAdaptiveAndFixedItemLocations())) {
                removeEnemiesByItem(item);
                itemsToRemove.add(item);
            } else {
                itemsToSave.add(item);
            }
        }
        if (!CollectionUtils.isEmpty(itemsToRemove)) {
            this.itemRepository.delete(itemsToRemove);
        }
        if (!CollectionUtils.isEmpty(itemsToSave)) {
            this.itemRepository.save(itemsToSave);
        }
    }

    protected ItemMoveResponse removeFormPartitionItems(final String assessmentId, final ItemMoveRequest moveRequest) {
        ItemMoveResponse response;
        if (hasValidRemoveInformation(moveRequest)) {
            final FixedFormItemLocation source = new FixedFormItemLocation();
            source.setFormPartitionId(moveRequest.getSourceLocationId());
            source.setItemGroupId(moveRequest.getSourceGroupId());
            response = removeItemsFromLocation(assessmentId, source, moveRequest.getItemMetadataIds());
        } else {
            response = new ItemMoveResponse();
            response.setMessage("Unable to remove items source is required");
        }
        return response;
    }

    protected ItemMoveResponse removeSegmentPoolItems(final String assessmentId, final ItemMoveRequest moveRequest) {
        ItemMoveResponse response;
        if (hasValidRemoveInformation(moveRequest)) {
            final AdaptiveItemLocation source = new AdaptiveItemLocation();
            source.setSegmentId(moveRequest.getSourceLocationId());
            source.setItemGroupId(moveRequest.getSourceGroupId());
            response = removeItemsFromLocation(assessmentId, source, moveRequest.getItemMetadataIds());
        } else {
            response = new ItemMoveResponse();
            response.setMessage("Unable to remove items source is required");
        }
        return response;
    }

    protected ItemMoveResponse removeItemsFromLocation(final String assessmentId, final ItemLocation removeMe, final List<String> itemIdsToRemove) {
        final ItemMoveResponse response = new ItemMoveResponse();
        int omitted = 0;
        int removed = 0;
        if (!CollectionUtils.isEmpty(itemIdsToRemove)) {
            for (final String itemId : itemIdsToRemove) {
                removeMe.setItemIdentifier(itemId);
                if (removeItem(assessmentId, removeMe)) {
                    removed++;
                } else {
                    omitted++;
                }
            }
            this.itemOrderingHelper.reindexSortOrder(assessmentId, removeMe.getFormPartitionId());
        }
        response.setItemsImpacted(removed);
        response.setItemsOmitted(omitted);
        return response;
    }

    private boolean removeItem(final String assessmentId, final ItemLocation toRemove) {
        boolean removed = false;
        final Item item = getItemByAssessmentIdAndTibIdentifier(assessmentId, toRemove.getItemIdentifier());
        ItemLocation removeIt = null;
        if (item != null && !CollectionUtils.isEmpty(item.getItemLocation())) {
            for (final ItemLocation existingLocation : item.getItemLocation()) {
                if (existingLocation.isSameLocation(toRemove)) {
                    removeIt = existingLocation;
                    break;
                }
            }
        }
        if (removeIt != null) {
            item.getItemLocation().remove(removeIt);
            if (CollectionUtils.isEmpty(item.getAdaptiveAndFixedItemLocations())) {
                removeEnemiesByItem(item);
                this.itemRepository.delete(item);
            } else {
                saveItem(item);
            }
            removed = true;
        }
        return removed;
    }

    private boolean hasValidRemoveInformation(final ItemMoveRequest itemMoveRequest) {
        return StringUtils.isNotBlank(itemMoveRequest.getSourceLocationId())
                && StringUtils.isNotBlank(itemMoveRequest.getSourceGroupId());
    }

    protected void removeEnemiesByItem(final Item item) {
        final List<Enemy> object1EnemyList = this.enemyService.getEnemiesByAssessmentIdAndObjectId1(item.getAssessmentId(), item.getTibIdentifier());
        final List<Enemy> object2EnemyList = this.enemyService.getEnemiesByAssessmentIdAndObjectId2(item.getAssessmentId(), item.getTibIdentifier());
        final List<Enemy> objectCompositeEnemyList = Lists.newArrayList();
        if (object1EnemyList != null) {
            objectCompositeEnemyList.addAll(object1EnemyList);
        }
        if (object2EnemyList != null) {
            objectCompositeEnemyList.addAll(object2EnemyList);
        }
        final Set<String> enemyIdList = Sets.newHashSet(TestAuthUtil.nullsafeListTransform(objectCompositeEnemyList, ENEMY_ID_TRANSFORMER));
        if (!CollectionUtils.isEmpty(enemyIdList)) {
            for (final String enemyId : enemyIdList) {
                this.enemyService.removeEnemy(enemyId);
            }
        }
    }
}
