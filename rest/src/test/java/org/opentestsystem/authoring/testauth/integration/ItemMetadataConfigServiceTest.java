/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.integration;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.notNullValue;
import static org.hamcrest.CoreMatchers.nullValue;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.Assert.fail;

import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.authoring.testauth.domain.Assessment;
import org.opentestsystem.authoring.testauth.domain.DomainFactory;
import org.opentestsystem.authoring.testauth.domain.ItemMetadataConfig;
import org.opentestsystem.authoring.testauth.domain.Publication;
import org.opentestsystem.authoring.testauth.domain.Subject;
import org.opentestsystem.authoring.testauth.persistence.AssessmentRepository;
import org.opentestsystem.authoring.testauth.rest.AbstractRestEmbeddedMongoTest;
import org.opentestsystem.authoring.testauth.service.ItemMetadataConfigService;
import org.opentestsystem.authoring.testauth.service.PublicationService;
import org.opentestsystem.authoring.testauth.service.SubjectService;
import org.opentestsystem.shared.exception.LocalizedException;
import org.springframework.beans.factory.annotation.Autowired;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;

public class ItemMetadataConfigServiceTest extends AbstractRestEmbeddedMongoTest {

    @Autowired
    private SubjectService subjectService;

    @Autowired
    private PublicationService publicationService;

    @Autowired
    private AssessmentRepository assessmentRepository;

    @Autowired
    private ItemMetadataConfigService itemMetadataConfigService;

    private Assessment savedAssessment;

    @Before
    public void setupTestData() {
        final Subject savedSubject = this.subjectService.saveSubject(DomainFactory.manufactureValidSubject("abb"));
        final Publication savedPublication = this.publicationService.savePublication(DomainFactory.manufactureValidPublication(savedSubject.getTenantId(), ImmutableSet.of(savedSubject)));
        this.savedAssessment = this.assessmentRepository.save(DomainFactory.manufactureValidAssessment(savedSubject, savedPublication));
    }

    @Test
    public void saveNewItemMetadataConfigTest() {
        final ItemMetadataConfig itemMetadataConfigToSave = buildValidItemMetadataConfig();

        final ItemMetadataConfig savedItemMetadataConfig = this.itemMetadataConfigService.saveItemMetadataConfig(itemMetadataConfigToSave);
        assertThat(savedItemMetadataConfig, is(notNullValue()));

        final ItemMetadataConfig retrievedItemMetadataConfig = this.itemMetadataConfigService.getItemMetadataConfigByAssessment(this.savedAssessment.getId());
        assertThat(retrievedItemMetadataConfig, is(notNullValue()));
    }

    @Test
    public void saveNewItemMetadataConfigAssessmentAlreadyLockedTest() {
        this.savedAssessment.setLocked(true);
        this.assessmentRepository.save(this.savedAssessment);

        final ItemMetadataConfig itemMetadataConfigToSave = buildValidItemMetadataConfig();
        try {
            this.itemMetadataConfigService.saveItemMetadataConfig(itemMetadataConfigToSave);
            fail("exception should be thrown when trying to save a new itemMetadataConfig after assessment is locked");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("cannot.be.altered.assessment.locked"));
        }
    }

    @Test
    public void saveExistingItemMetadataConfigTest() {
        final ItemMetadataConfig itemMetadataConfigToSave = buildValidItemMetadataConfig();
        final ItemMetadataConfig savedItemMetadataConfig = this.itemMetadataConfigService.saveItemMetadataConfig(itemMetadataConfigToSave);

        savedItemMetadataConfig.setItemMetadataReckonSet(Sets.newHashSet("different-metadata"));
        final ItemMetadataConfig resavedItemMetadataConfig = this.itemMetadataConfigService.saveItemMetadataConfig(savedItemMetadataConfig);
        assertThat(resavedItemMetadataConfig, is(notNullValue()));
        assertThat(resavedItemMetadataConfig.getItemMetadataReckonSet().iterator().next(), is(equalTo("different-metadata")));
    }

    @Test
    public void saveDuplicateItemMetadataConfigTest() {
        final ItemMetadataConfig itemMetadataConfigToSave = buildValidItemMetadataConfig();
        this.itemMetadataConfigService.saveItemMetadataConfig(itemMetadataConfigToSave);

        final ItemMetadataConfig duplicateItemMetadataConfig = this.itemMetadataConfigService.getItemMetadataConfigByAssessment(this.savedAssessment.getId());
        duplicateItemMetadataConfig.setId(null);

        try {
            this.itemMetadataConfigService.saveItemMetadataConfig(duplicateItemMetadataConfig);
            fail("should throw duplicate key exception");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("itemMetadataConfig.already.exists"));
        }
    }

    @Test
    public void saveExistingItemMetadataConfigAssessmentAlreadyLockedTest() {
        final ItemMetadataConfig itemMetadataConfigToSave = buildValidItemMetadataConfig();
        final ItemMetadataConfig savedItemMetadataConfig = this.itemMetadataConfigService.saveItemMetadataConfig(itemMetadataConfigToSave);

        this.savedAssessment.setLocked(true);
        this.assessmentRepository.save(this.savedAssessment);

        savedItemMetadataConfig.setItemMetadataReckonSet(Sets.newHashSet("new-metadata"));
        try {
            this.itemMetadataConfigService.saveItemMetadataConfig(savedItemMetadataConfig);
            fail("exception should be thrown when trying to save an existing itemMetadataConfig after assessment is locked");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("cannot.be.altered.assessment.locked"));
        }
    }

    @Test
    public void deleteItemMetadataConfigTest() {
        final ItemMetadataConfig itemMetadataConfigToSave = buildValidItemMetadataConfig();
        final ItemMetadataConfig savedItemMetadataConfig = this.itemMetadataConfigService.saveItemMetadataConfig(itemMetadataConfigToSave);

        this.itemMetadataConfigService.removeItemMetadataConfig(savedItemMetadataConfig.getId());
        final ItemMetadataConfig retrievedItemMetadataConfig = this.itemMetadataConfigService.getItemMetadataConfigByAssessment(this.savedAssessment.getId());
        assertThat(retrievedItemMetadataConfig, is(nullValue()));
    }

    @Test
    public void deleteItemMetadataConfigAssessmentAlreadyLockedTest() {
        final ItemMetadataConfig itemMetadataConfigToSave = buildValidItemMetadataConfig();
        final ItemMetadataConfig savedItemMetadataConfig = this.itemMetadataConfigService.saveItemMetadataConfig(itemMetadataConfigToSave);

        this.savedAssessment.setLocked(true);
        this.assessmentRepository.save(this.savedAssessment);

        try {
            this.itemMetadataConfigService.removeItemMetadataConfig(savedItemMetadataConfig.getId());
            fail("exception should be thrown when trying to delete an itemMetadataConfig after assessment is locked");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("cannot.be.altered.assessment.locked"));
        }

        final ItemMetadataConfig retrievedItemMetadataConfig = this.itemMetadataConfigService.getItemMetadataConfigByAssessment(this.savedAssessment.getId());
        assertThat(retrievedItemMetadataConfig, is(notNullValue()));
    }

    @Test
    public void removeItemMetadataConfigByAssessmentIdTest() {
        final ItemMetadataConfig itemMetadataConfigToSave = buildValidItemMetadataConfig();
        this.itemMetadataConfigService.saveItemMetadataConfig(itemMetadataConfigToSave);

        this.itemMetadataConfigService.removeItemMetadataConfigByAssessment(this.savedAssessment.getId());

        final ItemMetadataConfig retrievedItemMetadataConfig = this.itemMetadataConfigService.getItemMetadataConfigByAssessment(this.savedAssessment.getId());
        assertThat(retrievedItemMetadataConfig, is(nullValue()));
    }

    private ItemMetadataConfig buildValidItemMetadataConfig() {
        return DomainFactory.manufactureValidItemMetadataConfig(this.savedAssessment.getAssessmentId(), "itemMetadataField1", "itemMetadataField2");
    }
}
