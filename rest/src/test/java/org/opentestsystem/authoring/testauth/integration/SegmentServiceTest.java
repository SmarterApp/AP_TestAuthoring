/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.integration;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.notNullValue;
import static org.hamcrest.CoreMatchers.nullValue;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.Assert.fail;

import java.util.HashMap;
import java.util.List;

import javax.validation.ConstraintViolationException;

import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.authoring.testauth.domain.Assessment;
import org.opentestsystem.authoring.testauth.domain.BlueprintElement;
import org.opentestsystem.authoring.testauth.domain.DomainFactory;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionAlgorithm;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionAlgorithmParameter;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionAlgorithmType;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionPurpose;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionType;
import org.opentestsystem.authoring.testauth.domain.Publication;
import org.opentestsystem.authoring.testauth.domain.Segment;
import org.opentestsystem.authoring.testauth.domain.Subject;
import org.opentestsystem.authoring.testauth.persistence.AssessmentRepository;
import org.opentestsystem.authoring.testauth.rest.AbstractRestEmbeddedMongoTest;
import org.opentestsystem.authoring.testauth.service.BlueprintElementService;
import org.opentestsystem.authoring.testauth.service.ItemSelectionAlgorithmService;
import org.opentestsystem.authoring.testauth.service.PublicationService;
import org.opentestsystem.authoring.testauth.service.SegmentService;
import org.opentestsystem.authoring.testauth.service.SubjectService;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.springframework.beans.factory.annotation.Autowired;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;

public class SegmentServiceTest extends AbstractRestEmbeddedMongoTest {

    @Autowired
    private SegmentService segmentService;

    @Autowired
    private SubjectService subjectService;

    @Autowired
    private PublicationService publicationService;

    @Autowired
    private AssessmentRepository assessmentRepository;

    @Autowired
    private ItemSelectionAlgorithmService itemSelectionAlgorithmService;

    @Autowired
    private BlueprintElementService blueprintElementService;

    private Assessment savedAssessment;
    private ItemSelectionAlgorithm savedAlgorithm;
    private ItemSelectionAlgorithm savedAlgorithm2;

    @Before
    public void setupTestData() {
        final Subject savedSubject = this.subjectService.saveSubject(DomainFactory.manufactureValidSubject("abb"));
        final Publication savedPublication = this.publicationService.savePublication(DomainFactory.manufactureValidPublication(savedSubject.getTenantId(), ImmutableSet.of(savedSubject)));
        this.savedAssessment = this.assessmentRepository.save(DomainFactory.manufactureValidAssessment(savedSubject, savedPublication));

        final ItemSelectionAlgorithm algorithm = DomainFactory.manufactureValidItemSelectionAlgorithm(ItemSelectionPurpose.SCALAR, ItemSelectionType.FLOAT);
        algorithm.setItemSelectionAlgorithmType(ItemSelectionAlgorithmType.FIXEDFORM);
        this.savedAlgorithm = this.itemSelectionAlgorithmService.createItemSelectionAlgorithm(algorithm);

        final ItemSelectionAlgorithm algorithm2 = DomainFactory.manufactureValidItemSelectionAlgorithm(ItemSelectionPurpose.BLUEPRINT, ItemSelectionType.BOOLEAN);
        algorithm2.setItemSelectionAlgorithmType(ItemSelectionAlgorithmType.ADAPTIVE);
        this.savedAlgorithm2 = this.itemSelectionAlgorithmService.createItemSelectionAlgorithm(algorithm2);
    }

    @Test
    public void saveNewSegmentTest() {
        createSegments(1);
    }

    @Test
    public void saveNewSegmentMoreThanDefaultPaginationOf10Test() {
        final String[] segmentIdArray = createSegments(21);
        final Segment retrievedSegment = this.segmentService.getSegment(segmentIdArray[20]);
        assertThat(retrievedSegment, is(notNullValue()));
        assertThat(retrievedSegment.getPosition(), is(equalTo(21)));
    }

    @Test
    public void saveNewSegmentWithInvalidPositionTest() {
        createSegments(2);

        final Segment segmentToSave3 = DomainFactory.manufactureValidSegment(this.savedAssessment.getId(), this.savedAlgorithm, 1);
        segmentToSave3.setId(null);
        segmentToSave3.setPosition(5);
        try {
            this.segmentService.createSegment(segmentToSave3);
            fail("exception should be thrown when trying to add a new segment w/ invalid position");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "segment.invalid.position").size(), is(1));
        }

        segmentToSave3.setPosition(0);
        try {
            this.segmentService.createSegment(segmentToSave3);
            fail("exception should be thrown when trying to add a new segment w/ invalid position");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "segment.invalid.position").size(), is(1));
        }
    }

    @Test
    public void saveNewSegmentWithInvalidItemCountsTest() {
        final Segment segmentToSave = DomainFactory.manufactureValidSegment(this.savedAssessment.getId(), this.savedAlgorithm, 1);
        segmentToSave.setId(null);
        segmentToSave.setPosition(1);
        segmentToSave.setMinOpItems(1000);
        segmentToSave.setMaxOpItems(1000);
        segmentToSave.setMinFtItems(1000);
        segmentToSave.setMaxFtItems(1000);
        try {
            this.segmentService.createSegment(segmentToSave);
            fail("exception should be thrown when trying to add a new segment w/ invalid item counts");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(4));
            assertThat(getConstraintViolation(e, "segment.minOpItems.range").size(), is(1));
            assertThat(getConstraintViolation(e, "segment.maxOpItems.range").size(), is(1));
            assertThat(getConstraintViolation(e, "segment.minFtItems.range").size(), is(1));
            assertThat(getConstraintViolation(e, "segment.maxFtItems.range").size(), is(1));
        }
    }

    @Test
    public void saveNewSegmentAssessmentAlreadyLockedTest() {
        createSegments(1);
        this.savedAssessment.setLocked(true);
        this.assessmentRepository.save(this.savedAssessment);

        final Segment segmentToSave = DomainFactory.manufactureValidSegment(this.savedAssessment.getId(), this.savedAlgorithm, 1);
        segmentToSave.setId(null);
        segmentToSave.setPosition(2);
        try {
            this.segmentService.createSegment(segmentToSave);
            fail("exception should be thrown when trying to save a new segment after assessment is locked");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("cannot.be.altered.assessment.locked"));
        }
    }

    @Test
    public void saveExistingSegmentTest() {
        final String[] segmentIdArray = createSegments(1);

        final Segment retrievedSegment = this.segmentService.getSegment(segmentIdArray[0]);
        retrievedSegment.setMaxOpItems(99);
        final Segment resavedSegment = this.segmentService.updateSegment(retrievedSegment);
        assertThat(resavedSegment, is(notNullValue()));
        assertThat(resavedSegment.getMaxOpItems(), is(equalTo(99)));
    }

    @Test
    public void saveSegmentListTest() {
        final List<Segment> segmentListToSave = manufactureValidSegment(2);
        final Segment savedSegment = this.segmentService.createSegment(segmentListToSave.get(0));
        final Segment savedSegment2 = this.segmentService.createSegment(segmentListToSave.get(1));
        final List<Segment> updatedSegmentListToSave = Lists.newArrayList(savedSegment, savedSegment2);

        final List<Segment> savedSegmentList = this.segmentService.saveSegmentList(updatedSegmentListToSave, true);
        assertThat(savedSegmentList, is(notNullValue()));
        final Segment retrievedSegment = this.segmentService.getSegment(savedSegmentList.get(0).getId());
        assertThat(retrievedSegment, is(notNullValue()));
    }

    @Test
    public void saveDuplicateSegmentTest() {
        final String[] segmentIdArray = createSegments(1);

        final Segment duplicateSegment = this.segmentService.getSegment(segmentIdArray[0]);
        duplicateSegment.setId(null);
        duplicateSegment.setPosition(2);

        try {
            this.segmentService.createSegment(duplicateSegment);
            fail("should thow duplicate key exception");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("segment.already.exists"));
        }
    }

    @Test
    public void saveExistingSegmentAssessmentAlreadyLockedTest() {
        final String[] segmentIdArray = createSegments(1);
        this.savedAssessment.setLocked(true);
        this.assessmentRepository.save(this.savedAssessment);

        final Segment retrievedSegment = this.segmentService.getSegment(segmentIdArray[0]);
        retrievedSegment.setMaxOpItems(99);
        try {
            this.segmentService.updateSegment(retrievedSegment);
            fail("exception should be thrown when trying to update an existing segment after assessment is locked");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("cannot.be.altered.assessment.locked"));
        }
    }

    @Test
    public void saveExistingSegmentWithInvalidPositionTest() {
        final String[] segmentIdArray = createSegments(3);

        final Segment retrievedSegment3 = this.segmentService.getSegment(segmentIdArray[2]);
        retrievedSegment3.setPosition(5);
        try {
            this.segmentService.updateSegment(retrievedSegment3);
            fail("exception should be thrown when trying to update an existing segment w/ invalid position");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "segment.invalid.position").size(), is(1));
        }
    }

    @Test
    public void saveExistingSegmentResequenceUpPositionTest() {
        final String[] segmentIdArray = createSegments(5);

        // rest put w/ new position resequences the rest
        final Segment retrievedSegment3 = this.segmentService.getSegment(segmentIdArray[2]);
        retrievedSegment3.setPosition(1);
        final Segment reSavedSegment3 = this.segmentService.updateSegment(retrievedSegment3);
        assertThat(reSavedSegment3, is(notNullValue()));

        final Segment reRetrievedSegment1 = this.segmentService.getSegment(segmentIdArray[0]);
        assertThat(reRetrievedSegment1, is(notNullValue()));
        assertThat(reRetrievedSegment1.getPosition(), is(2));
        final Segment reRetrievedSegment2 = this.segmentService.getSegment(segmentIdArray[1]);
        assertThat(reRetrievedSegment2, is(notNullValue()));
        assertThat(reRetrievedSegment2.getPosition(), is(3));
        final Segment reRetrievedSegment4 = this.segmentService.getSegment(segmentIdArray[3]);
        assertThat(reRetrievedSegment4, is(notNullValue()));
        assertThat(reRetrievedSegment4.getPosition(), is(4));
        final Segment reRetrievedSegment5 = this.segmentService.getSegment(segmentIdArray[4]);
        assertThat(reRetrievedSegment5, is(notNullValue()));
        assertThat(reRetrievedSegment5.getPosition(), is(5));
    }

    @Test
    public void saveExistingSegmentResequenceUpPositionTest2() {
        final String[] segmentIdArray = createSegments(5);

        // rest put w/ new position resequences the rest
        final Segment retrievedSegment5 = this.segmentService.getSegment(segmentIdArray[4]);
        retrievedSegment5.setPosition(2);
        final Segment reSavedSegment5 = this.segmentService.updateSegment(retrievedSegment5);
        assertThat(reSavedSegment5, is(notNullValue()));

        final Segment reRetrievedSegment1 = this.segmentService.getSegment(segmentIdArray[0]);
        assertThat(reRetrievedSegment1, is(notNullValue()));
        assertThat(reRetrievedSegment1.getPosition(), is(1));
        final Segment reRetrievedSegment2 = this.segmentService.getSegment(segmentIdArray[1]);
        assertThat(reRetrievedSegment2, is(notNullValue()));
        assertThat(reRetrievedSegment2.getPosition(), is(3));
        final Segment reRetrievedSegment3 = this.segmentService.getSegment(segmentIdArray[2]);
        assertThat(reRetrievedSegment3, is(notNullValue()));
        assertThat(reRetrievedSegment3.getPosition(), is(4));
        final Segment reRetrievedSegment4 = this.segmentService.getSegment(segmentIdArray[3]);
        assertThat(reRetrievedSegment4, is(notNullValue()));
        assertThat(reRetrievedSegment4.getPosition(), is(5));
    }

    @Test
    public void saveExistingSegmentResequenceDownPositionTest() {
        final String[] segmentIdArray = createSegments(5);

        // rest put w/ new position resequences the rest
        final Segment retrievedSegment1 = this.segmentService.getSegment(segmentIdArray[0]);
        retrievedSegment1.setPosition(3);
        final Segment reSavedSegment1 = this.segmentService.updateSegment(retrievedSegment1);
        assertThat(reSavedSegment1, is(notNullValue()));

        final Segment reRetrievedSegment2 = this.segmentService.getSegment(segmentIdArray[1]);
        assertThat(reRetrievedSegment2, is(notNullValue()));
        assertThat(reRetrievedSegment2.getPosition(), is(1));
        final Segment reRetrievedSegment3 = this.segmentService.getSegment(segmentIdArray[2]);
        assertThat(reRetrievedSegment3, is(notNullValue()));
        assertThat(reRetrievedSegment3.getPosition(), is(2));
        final Segment reRetrievedSegment4 = this.segmentService.getSegment(segmentIdArray[3]);
        assertThat(reRetrievedSegment4, is(notNullValue()));
        assertThat(reRetrievedSegment4.getPosition(), is(4));
        final Segment reRetrievedSegment5 = this.segmentService.getSegment(segmentIdArray[4]);
        assertThat(reRetrievedSegment5, is(notNullValue()));
        assertThat(reRetrievedSegment5.getPosition(), is(5));
    }

    @Test
    public void saveExistingSegmentResequenceDownPositionTest2() {
        final String[] segmentIdArray = createSegments(5);

        // rest put w/ new position resequences the rest
        final Segment retrievedSegment2 = this.segmentService.getSegment(segmentIdArray[1]);
        retrievedSegment2.setPosition(4);
        final Segment reSavedSegment2 = this.segmentService.updateSegment(retrievedSegment2);
        assertThat(reSavedSegment2, is(notNullValue()));

        final Segment reRetrievedSegment1 = this.segmentService.getSegment(segmentIdArray[0]);
        assertThat(reRetrievedSegment1, is(notNullValue()));
        assertThat(reRetrievedSegment1.getPosition(), is(1));
        final Segment reRetrievedSegment3 = this.segmentService.getSegment(segmentIdArray[2]);
        assertThat(reRetrievedSegment3, is(notNullValue()));
        assertThat(reRetrievedSegment3.getPosition(), is(2));
        final Segment reRetrievedSegment4 = this.segmentService.getSegment(segmentIdArray[3]);
        assertThat(reRetrievedSegment4, is(notNullValue()));
        assertThat(reRetrievedSegment4.getPosition(), is(3));
        final Segment reRetrievedSegment5 = this.segmentService.getSegment(segmentIdArray[4]);
        assertThat(reRetrievedSegment5, is(notNullValue()));
        assertThat(reRetrievedSegment5.getPosition(), is(5));
    }

    @Test
    public void saveExistingSegmentResequenceDownPositionMoreThanDefaultPaginationTest() {
        final String[] segmentIdArray = createSegments(25);

        // rest put w/ new position resequences the rest
        final Segment retrievedSegment2 = this.segmentService.getSegment(segmentIdArray[1]);
        retrievedSegment2.setPosition(24);
        final Segment reSavedSegment2 = this.segmentService.updateSegment(retrievedSegment2);
        assertThat(reSavedSegment2, is(notNullValue()));

        final Segment reRetrievedSegment1 = this.segmentService.getSegment(segmentIdArray[0]);
        assertThat(reRetrievedSegment1, is(notNullValue()));
        assertThat(reRetrievedSegment1.getPosition(), is(1));
        final Segment reRetrievedSegment3 = this.segmentService.getSegment(segmentIdArray[2]);
        assertThat(reRetrievedSegment3, is(notNullValue()));
        assertThat(reRetrievedSegment3.getPosition(), is(2));
        final Segment reRetrievedSegment4 = this.segmentService.getSegment(segmentIdArray[3]);
        assertThat(reRetrievedSegment4, is(notNullValue()));
        assertThat(reRetrievedSegment4.getPosition(), is(3));
        final Segment reRetrievedSegment5 = this.segmentService.getSegment(segmentIdArray[4]);
        assertThat(reRetrievedSegment5, is(notNullValue()));
        assertThat(reRetrievedSegment5.getPosition(), is(4));
        final Segment reRetrievedSegment24 = this.segmentService.getSegment(segmentIdArray[23]);
        assertThat(reRetrievedSegment24, is(notNullValue()));
        assertThat(reRetrievedSegment24.getPosition(), is(23));
        final Segment reRetrievedSegment25 = this.segmentService.getSegment(segmentIdArray[24]);
        assertThat(reRetrievedSegment25, is(notNullValue()));
        assertThat(reRetrievedSegment25.getPosition(), is(25));
    }

    @Test
    public void saveExistingSegmentWithNewItemSelectionAlgorithmCannotSave() {
        // create blueprint elements for assessment
        final BlueprintElement blueprintElement1 = buildBlueprintElement();
        final BlueprintElement blueprintElement2 = buildBlueprintElement();
        final BlueprintElement blueprintElement3 = buildBlueprintElement();
        assertThat(this.blueprintElementService.saveBlueprintElementList(ImmutableList.of(blueprintElement1, blueprintElement2, blueprintElement3)).size(), is(3));
        assertThat(this.blueprintElementService.getBlueprintElementsByAssessmentId(this.savedAssessment.getId()).size(), is(3));

        // verify blueprint elements have 0 ISA parameters for scalar segment algorithm
        final String[] segmentIdArray = createSegments(1);
        final List<BlueprintElement> blueprintElementList = this.blueprintElementService.getBlueprintElementsByAssessmentId(this.savedAssessment.getId());
        assertThat(blueprintElementList.get(0).getBlueprintElementValueMap().get(segmentIdArray[0]).getItemSelectionParameters().size(), is(0));

        // update segment to contain a blueprint ISA parameter
        final Segment segment = this.segmentService.getSegment(segmentIdArray[0]);
        segment.setItemSelectionAlgorithmId(this.savedAlgorithm2.getId());
        segment.getItemSelectionParameters().clear();
        try {
            this.segmentService.updateSegment(segment);
            fail("cannot alter ISA type validation should have been thrown");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "segment.cannot.alter.itemSelectionAlgorithm.type").size(), is(1));
        }
    }

    @Test
    public void saveExistingSegmentWithNewItemSelectionAlgorithm() {
        // create blueprint elements for assessment
        final BlueprintElement blueprintElement1 = buildBlueprintElement();
        final BlueprintElement blueprintElement2 = buildBlueprintElement();
        final BlueprintElement blueprintElement3 = buildBlueprintElement();
        assertThat(this.blueprintElementService.saveBlueprintElementList(ImmutableList.of(blueprintElement1, blueprintElement2, blueprintElement3)).size(), is(3));
        assertThat(this.blueprintElementService.getBlueprintElementsByAssessmentId(this.savedAssessment.getId()).size(), is(3));

        // verify blueprint elements have 0 ISA parameters for scalar segment algorithm
        final String[] segmentIdArray = createSegments(1);
        final List<BlueprintElement> blueprintElementList = this.blueprintElementService.getBlueprintElementsByAssessmentId(this.savedAssessment.getId());
        assertThat(blueprintElementList.get(0).getBlueprintElementValueMap().get(segmentIdArray[0]).getItemSelectionParameters().size(), is(0));

        // update segment to contain a blueprint ISA parameter
        final Segment segment = this.segmentService.getSegment(segmentIdArray[0]);
        final ItemSelectionAlgorithm algorithm3 = DomainFactory.manufactureValidItemSelectionAlgorithm(ItemSelectionPurpose.BLUEPRINT, ItemSelectionType.BOOLEAN);
        algorithm3.setItemSelectionAlgorithmType(ItemSelectionAlgorithmType.FIXEDFORM);
        final ItemSelectionAlgorithm savedAlgorithm3 = this.itemSelectionAlgorithmService.createItemSelectionAlgorithm(algorithm3);
        segment.setItemSelectionAlgorithmId(savedAlgorithm3.getId());
        segment.getItemSelectionParameters().clear();
        this.segmentService.updateSegment(segment);

        // verif blueprint elements have exactly 1 ISA parameters for segment algorithm with exactly 1 blueprint parameter
        final List<BlueprintElement> updatedBlueprintElementList = this.blueprintElementService.getBlueprintElementsByAssessmentId(this.savedAssessment.getId());
        assertThat(updatedBlueprintElementList.get(0).getBlueprintElementValueMap().get(segmentIdArray[0]).getItemSelectionParameters().size(), is(1));
    }

    @Test
    public void saveFieldTestSegmentWithNonZeroOpItemTest() {
        final ItemSelectionAlgorithm algorithm3 = DomainFactory.manufactureValidItemSelectionAlgorithm(ItemSelectionPurpose.BLUEPRINT, ItemSelectionType.BOOLEAN);
        algorithm3.setItemSelectionAlgorithmType(ItemSelectionAlgorithmType.FIELDTEST);
        final ItemSelectionAlgorithm savedAlgorithm3 = this.itemSelectionAlgorithmService.createItemSelectionAlgorithm(algorithm3);

        final Segment segment = DomainFactory.manufactureValidSegment(this.savedAssessment.getId(), savedAlgorithm3, 1);
        segment.setMinOpItems(1);
        segment.setMaxOpItems(2);

        try {
            this.segmentService.createSegment(segment);
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(2));
            assertThat(getConstraintViolation(e, "segment.minOpItems.fieldTest.nonzero").size(), is(1));
            assertThat(getConstraintViolation(e, "segment.maxOpItems.fieldTest.nonzero").size(), is(1));
        }
    }

    private BlueprintElement buildBlueprintElement() {
        final List<Segment> segmentList = segmentService.findSegmentListByAssessmentId(savedAssessment.getId());
        segmentService.loadReferenceData(segmentList);
        final BlueprintElement blueprintElement = DomainFactory.manufactureValidBlueprintElement(savedAssessment.getId(), segmentList);
        blueprintElement.setGrade(this.savedAssessment.getGrade()[0]);
        return blueprintElement;
    }

    @Test
    public void deleteSegmentTest() {
        final String[] segmentIdArray = createSegments(5);

        this.segmentService.removeSegment(segmentIdArray[0]);

        final Segment reRetrievedSegment = this.segmentService.getSegment(segmentIdArray[0]);
        assertThat(reRetrievedSegment, is(nullValue()));

        // verify other segment positions were resequenced
        final Segment reRetrievedSegment2 = this.segmentService.getSegment(segmentIdArray[1]);
        assertThat(reRetrievedSegment2, is(notNullValue()));
        assertThat(reRetrievedSegment2.getPosition(), is(1));
        final Segment reRetrievedSegment3 = this.segmentService.getSegment(segmentIdArray[2]);
        assertThat(reRetrievedSegment3, is(notNullValue()));
        assertThat(reRetrievedSegment3.getPosition(), is(2));
        final Segment reRetrievedSegment4 = this.segmentService.getSegment(segmentIdArray[3]);
        assertThat(reRetrievedSegment4, is(notNullValue()));
        assertThat(reRetrievedSegment4.getPosition(), is(3));
        final Segment reRetrievedSegment5 = this.segmentService.getSegment(segmentIdArray[4]);
        assertThat(reRetrievedSegment5, is(notNullValue()));
        assertThat(reRetrievedSegment5.getPosition(), is(4));
    }

    @Test
    public void deleteSegmentTest2() {
        final String[] segmentIdArray = createSegments(5);

        this.segmentService.removeSegment(segmentIdArray[2]);

        final Segment reRetrievedSegment3 = this.segmentService.getSegment(segmentIdArray[2]);
        assertThat(reRetrievedSegment3, is(nullValue()));

        // verify other segment positions were resequenced
        final Segment reRetrievedSegment1 = this.segmentService.getSegment(segmentIdArray[0]);
        assertThat(reRetrievedSegment1, is(notNullValue()));
        assertThat(reRetrievedSegment1.getPosition(), is(1));
        final Segment reRetrievedSegment2 = this.segmentService.getSegment(segmentIdArray[1]);
        assertThat(reRetrievedSegment2, is(notNullValue()));
        assertThat(reRetrievedSegment2.getPosition(), is(2));
        final Segment reRetrievedSegment4 = this.segmentService.getSegment(segmentIdArray[3]);
        assertThat(reRetrievedSegment4, is(notNullValue()));
        assertThat(reRetrievedSegment4.getPosition(), is(3));
        final Segment reRetrievedSegment5 = this.segmentService.getSegment(segmentIdArray[4]);
        assertThat(reRetrievedSegment5, is(notNullValue()));
        assertThat(reRetrievedSegment5.getPosition(), is(4));
    }

    @Test
    public void deleteSegmentFromMoreThanDefaultPaginationTest() {
        final String[] segmentIdArray = createSegments(15);

        this.segmentService.removeSegment(segmentIdArray[2]);

        final Segment reRetrievedSegment3 = this.segmentService.getSegment(segmentIdArray[2]);
        assertThat(reRetrievedSegment3, is(nullValue()));

        // verify other segment positions were resequenced
        final Segment reRetrievedSegment1 = this.segmentService.getSegment(segmentIdArray[0]);
        assertThat(reRetrievedSegment1, is(notNullValue()));
        assertThat(reRetrievedSegment1.getPosition(), is(1));
        final Segment reRetrievedSegment2 = this.segmentService.getSegment(segmentIdArray[1]);
        assertThat(reRetrievedSegment2, is(notNullValue()));
        assertThat(reRetrievedSegment2.getPosition(), is(2));
        final Segment reRetrievedSegment4 = this.segmentService.getSegment(segmentIdArray[3]);
        assertThat(reRetrievedSegment4, is(notNullValue()));
        assertThat(reRetrievedSegment4.getPosition(), is(3));
        final Segment reRetrievedSegment5 = this.segmentService.getSegment(segmentIdArray[4]);
        assertThat(reRetrievedSegment5, is(notNullValue()));
        assertThat(reRetrievedSegment5.getPosition(), is(4));
        final Segment reRetrievedSegment11 = this.segmentService.getSegment(segmentIdArray[10]);
        assertThat(reRetrievedSegment11, is(notNullValue()));
        assertThat(reRetrievedSegment11.getPosition(), is(10));
        final Segment reRetrievedSegment15 = this.segmentService.getSegment(segmentIdArray[14]);
        assertThat(reRetrievedSegment15, is(notNullValue()));
        assertThat(reRetrievedSegment15.getPosition(), is(14));
    }

    @Test
    public void saveNewSegmentWithParameterTrimmingTest() {
        final Segment segmentToSave = DomainFactory.manufactureValidSegment(this.savedAssessment.getId(), this.savedAlgorithm, 1);

        final String field1 = this.savedAlgorithm.getScalarParameters().get(0).getParameterName();
        segmentToSave.getItemSelectionParameters().put(field1, "009.87654325315460");

        final Segment savedSegment = this.segmentService.createSegment(segmentToSave);
        assertThat(savedSegment.getItemSelectionParameters().get(field1), is("9.8765432531546"));
    }

    @Test
    public void validationCannotDeleteAssessmentAlreadyPublishedTest() {
        final String[] segmentIdArray = createSegments(2);
        this.savedAssessment.setLocked(true);
        this.assessmentRepository.save(this.savedAssessment);

        final Segment retrievedSegment = this.segmentService.getSegment(segmentIdArray[0]);
        assertThat(retrievedSegment, is(notNullValue()));

        try {
            this.segmentService.removeSegment(retrievedSegment.getId());
            fail("exception should be thrown when trying to remove a locked assessment");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("cannot.be.altered.assessment.locked"));
        }
    }

    @Test
    public void removeSegmentByAssessmentIdTest() {
        final String[] segmentIdArray = createSegments(2);

        final Segment retrievedSegment = this.segmentService.getSegment(segmentIdArray[0]);

        this.segmentService.removeByAssessmentId(retrievedSegment.getAssessmentId());

        final Segment reRetrievedSegment = this.segmentService.getSegment(segmentIdArray[0]);
        assertThat(reRetrievedSegment, is(nullValue()));

        final Segment retrievedSegment2 = this.segmentService.getSegment(segmentIdArray[1]);
        assertThat(retrievedSegment2, is(nullValue()));
    }

    @Test
    public void searchSegments() {
        final String[] segmentIdArray = createSegments(2);
        final Segment retrievedSegment = this.segmentService.getSegment(segmentIdArray[0]);

        final SearchResponse<Segment> searchResponse = this.segmentService.searchSegments(ImmutableMap.of("position", new String[] { Integer.toString(retrievedSegment.getPosition()) }));
        assertThat(searchResponse.getReturnCount(), is(1));
        assertThat(searchResponse.getSearchResults().size(), is(1));
    }

    private String[] createSegments(final int numberToCreate) {
        final String[] segmentIdArray = new String[numberToCreate];
        for (int i = 0; i < numberToCreate; i++) {
            final Segment segmentToSave = DomainFactory.manufactureValidSegment(this.savedAssessment.getId(), this.savedAlgorithm, 1);
            segmentToSave.setId(null);
            segmentToSave.setPosition(i + 1);
            final Segment savedSegment = this.segmentService.createSegment(segmentToSave);
            assertThat(savedSegment, is(notNullValue()));
            final Segment retrievedSegment = this.segmentService.getSegment(savedSegment.getId());
            assertThat(retrievedSegment, is(notNullValue()));
            segmentIdArray[i] = retrievedSegment.getId();
        }
        return segmentIdArray;
    }

    private List<Segment> manufactureValidSegment(final int i) {
        final List<Segment> segmentList = Lists.newArrayList();
        for (int j = 1; j < i + 1; j++) {
            final Segment segment = PODAM_FACTORY.manufacturePojo(Segment.class);
            segment.setId(null);
            segment.setAssessmentId(this.savedAssessment.getId());
            segment.setPosition(1);
            segment.setMinFtItems(0);
            segment.setMaxFtItems(999);
            segment.setMinOpItems(0);
            segment.setMaxOpItems(ItemSelectionAlgorithmType.FIELDTEST.equals(this.savedAlgorithm.getItemSelectionAlgorithmType()) ? 0 : 999);
            segment.setPosition(Integer.valueOf(j));
            segment.setItemSelectionAlgorithmId(this.savedAlgorithm.getId());
            segment.setItemSelectionAlgorithm(null);

            segment.setItemSelectionParameters(new HashMap<String, String>());
            for (final ItemSelectionAlgorithmParameter parameter : this.savedAlgorithm.getScalarParameters()) {
                segment.getItemSelectionParameters().put(parameter.getParameterName(), parameter.getDefaultValue());
            }
            segmentList.add(segment);
        }
        return segmentList;
    }
}
