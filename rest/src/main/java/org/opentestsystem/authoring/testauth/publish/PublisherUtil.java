/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.publish;

import static org.opentestsystem.authoring.testauth.config.TestAuthUtil.DEFAULT_VERSION;
import static org.opentestsystem.authoring.testauth.config.TestAuthUtil.nullsafeListTransform;
import static org.opentestsystem.authoring.testauth.config.TestAuthUtil.paramArray;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigDecimal;
import java.nio.charset.Charset;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.authoring.testauth.domain.AdaptiveItemLocation;
import org.opentestsystem.authoring.testauth.domain.AffinityGroup;
import org.opentestsystem.authoring.testauth.domain.BlueprintDenotationType;
import org.opentestsystem.authoring.testauth.domain.BlueprintElement;
import org.opentestsystem.authoring.testauth.domain.BlueprintReferenceType;
import org.opentestsystem.authoring.testauth.domain.ComputationRule;
import org.opentestsystem.authoring.testauth.domain.ComputationRuleParameter;
import org.opentestsystem.authoring.testauth.domain.ConversionTableType;
import org.opentestsystem.authoring.testauth.domain.Enemy;
import org.opentestsystem.authoring.testauth.domain.FixedFormItemLocation;
import org.opentestsystem.authoring.testauth.domain.FormPartition;
import org.opentestsystem.authoring.testauth.domain.Item;
import org.opentestsystem.authoring.testauth.domain.ItemGroup;
import org.opentestsystem.authoring.testauth.domain.ItemGroupLocationType;
import org.opentestsystem.authoring.testauth.domain.ItemLocation;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionAlgorithmType;
import org.opentestsystem.authoring.testauth.domain.PerformanceLevel;
import org.opentestsystem.authoring.testauth.domain.PerformanceLevelValue;
import org.opentestsystem.authoring.testauth.domain.ReportingMeasure;
import org.opentestsystem.authoring.testauth.domain.ScoringRule;
import org.opentestsystem.authoring.testauth.domain.ScoringRuleDictionaryElement;
import org.opentestsystem.authoring.testauth.domain.ScoringRuleParameter;
import org.opentestsystem.authoring.testauth.domain.Segment;
import org.opentestsystem.authoring.testauth.persistence.GridFsRepository;
import org.opentestsystem.authoring.testauth.publish.domain.ConversionTable;
import org.opentestsystem.authoring.testauth.publish.domain.ConversionTuple;
import org.opentestsystem.authoring.testauth.publish.domain.Identifier;
import org.opentestsystem.authoring.testauth.publish.domain.ItemReference;
import org.opentestsystem.authoring.testauth.publish.domain.ItemReferenceGroup;
import org.opentestsystem.authoring.testauth.publish.domain.ItemScoreDimension;
import org.opentestsystem.authoring.testauth.publish.domain.ItemScoreParameter;
import org.opentestsystem.authoring.testauth.publish.domain.ItemSelectionParameter;
import org.opentestsystem.authoring.testauth.publish.domain.Passage;
import org.opentestsystem.authoring.testauth.publish.domain.PoolProperty;
import org.opentestsystem.authoring.testauth.publish.domain.Property;
import org.opentestsystem.authoring.testauth.publish.domain.ScoreType;
import org.opentestsystem.authoring.testauth.publish.domain.TestComputationRule;
import org.opentestsystem.authoring.testauth.publish.domain.TestComputationRuleParameter;
import org.opentestsystem.authoring.testauth.publish.domain.TestComputationRuleParameterValue;
import org.opentestsystem.authoring.testauth.publish.domain.TestEnemy;
import org.opentestsystem.authoring.testauth.publish.domain.TestItem;
import org.opentestsystem.authoring.testauth.publish.domain.TestPerformanceLevel;
import org.opentestsystem.authoring.testauth.publish.domain.TestReportingMeasure;
import org.opentestsystem.shared.exception.LocalizedException;
import org.springframework.util.CollectionUtils;

import au.com.bytecode.opencsv.CSVReader;

import com.google.common.base.Function;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Ordering;
import com.mongodb.gridfs.GridFSDBFile;

public final class PublisherUtil {

    protected static final String EMPTY_PROPERTY = "";

    private PublisherUtil() {
        // singleton
    }

    // ========================================================================================================================================================================
    // general

    protected static Identifier buildIdentifier(final String name, final String label, final String version) {
        final List<String> fields = Lists.newArrayList(Iterables.filter(Lists.newArrayList(StringUtils.trimToNull(name), StringUtils.trimToNull(label), StringUtils.trimToNull(version)),
                Predicates.notNull()));
        return new Identifier(StringUtils.join(fields.toArray(), "-"), name, label, version);
    }

    protected static final class POOLPROPERTY_TO_POOLPROPERTY_TYPE_TRANSFORMER implements Function<PoolProperty, String> {
        private final List<String> configuredItemMetadataConfigValues;

        public static POOLPROPERTY_TO_POOLPROPERTY_TYPE_TRANSFORMER getInstance(final List<String> configuredItemMetadataConfigValues) {
            return new POOLPROPERTY_TO_POOLPROPERTY_TYPE_TRANSFORMER(configuredItemMetadataConfigValues);
        }

        private POOLPROPERTY_TO_POOLPROPERTY_TYPE_TRANSFORMER(final List<String> configuredItemMetadataConfigValues) {
            this.configuredItemMetadataConfigValues = configuredItemMetadataConfigValues;
        }

        @Override
        public String apply(final PoolProperty poolProperty) {
            return StringUtils.isBlank(poolProperty.getProperty()) || !this.configuredItemMetadataConfigValues.contains(poolProperty.getProperty()) ? EMPTY_PROPERTY : poolProperty.getProperty();
        }
    };

    protected static final Function<PoolProperty, String> POOLPROPERTY_TO_POOLPROPERTY_VALUE_TRANSFORMER = new Function<PoolProperty, String>() {
        @Override
        public String apply(final PoolProperty poolProperty) {
            return StringUtils.isBlank(poolProperty.getValue()) ? EMPTY_PROPERTY : poolProperty.getValue();
        }
    };

    protected static final Ordering<PoolProperty> POOL_PROPERTY_ORDER = Ordering.natural().onResultOf(new Function<PoolProperty, String>() {
        @Override
        public String apply(final PoolProperty poolProperty) {
            return poolProperty.getProperty() + poolProperty.getValue();
        }
    });

    // ========================================================================================================================================================================
    // item pool construction
    protected static final Function<ItemGroup, String> ITEMGROUP_MAPKEY_TRANSFORMER = new Function<ItemGroup, String>() {
        @Override
        public String apply(final ItemGroup itemGroup) {
            return itemGroup.getId();
        }
    };

    protected static final class ITEM_TESTITEM_TRANSFORMER implements Function<Item, TestItem> {
        private final Map<String, ItemGroup> itemGroupMap;
        private final Map<String, Segment> segmentMap;
        private final Map<String, AffinityGroup> affinityGroupMap;

        public static ITEM_TESTITEM_TRANSFORMER getInstance(final Map<String, ItemGroup> itemGroupMap, final Map<String, Segment> segmentMap, final Map<String, AffinityGroup> affinityGroupMap) {
            return new ITEM_TESTITEM_TRANSFORMER(itemGroupMap, segmentMap, affinityGroupMap);
        }

        private ITEM_TESTITEM_TRANSFORMER(final Map<String, ItemGroup> itemGroupMap, final Map<String, Segment> segmentMap, final Map<String, AffinityGroup> affinityGroupMap) {
            this.itemGroupMap = itemGroupMap;
            this.segmentMap = segmentMap;
            this.affinityGroupMap = affinityGroupMap;
        }

        @Override
        public TestItem apply(final Item item) {
            final TestItem testItem = new TestItem(null, item.getInteractionType(), buildIdentifier(item.getTibIdentifier(), item.getTibIdentifier(), item.getVersion()));
            testItem.setBluprintReferenceList(
                    Lists.newArrayList(Iterables.concat(
                            nullsafeListTransform(item.getItemLocation(), ITEM_LOCATION_SEGMENT_ID_TRANSFORMER.getInstance(this.segmentMap)),
                            Lists.newArrayList(item.getPrimaryStandard()),
                            nullsafeListTransform(item.getItemLocation(), ITEM_LOCATION_AFFINITY_GROUP_ID_TRANSFORMER.getInstance(this.affinityGroupMap)))));
            testItem.setItemType(item.getInteractionType());
            testItem.setPassageReferenceList(nullsafeListTransform(item.getItemLocation(), ITEMLOCATION_GROUP_PASSAGE_ID_TRANSFORMER.getInstance(this.itemGroupMap)));
            testItem.setPoolPropertyList(buildPoolPropertyForItem(item));
            testItem.setItemScoreDimensionList(nullsafeListTransform(item.getItemScoreDimensionList(), ITEM_SCORE_DIMENSION_TRANSFORMER));
            testItem.setDatabaseId(item.getId());
            return testItem;
        }

        private List<PoolProperty> buildPoolPropertyForItem(final Item item) {
            final List<PoolProperty> metadataPoolPropertyList = Lists.newArrayList();
            if (item.getAllIncludedMetadata() != null) {
                for (final Entry<String, Object> metadataEntry : item.getAllIncludedMetadata().entrySet()) {
                    metadataPoolPropertyList.add(new PoolProperty(metadataEntry.getKey(), metadataEntry.getValue().toString(), metadataEntry.getValue().toString()));
                }
            }
            return metadataPoolPropertyList;
        }
    };

    private static final Function<org.opentestsystem.authoring.testauth.domain.ItemScoreDimension, ItemScoreDimension> ITEM_SCORE_DIMENSION_TRANSFORMER = new Function<org.opentestsystem.authoring.testauth.domain.ItemScoreDimension, ItemScoreDimension>() {
        @Override
        public ItemScoreDimension apply(final org.opentestsystem.authoring.testauth.domain.ItemScoreDimension itemScoreDimension) {
            final ItemScoreDimension isd = new ItemScoreDimension();
            isd.setMeasurementModel(itemScoreDimension.getMeasurementModel());
            isd.setDimension(itemScoreDimension.getDimension());
            isd.setScorePoints(itemScoreDimension.getScorePoints());
            isd.setWeight(itemScoreDimension.getWeight());
            isd.setItemScoreParameterList(nullsafeListTransform(itemScoreDimension.getItemScoreParameterList(), ITEM_SCORE_PARAMETER_TRANSFORMER));
            return isd;
        };
    };

    private static final Function<org.opentestsystem.authoring.testauth.domain.ItemScoreParameter, ItemScoreParameter> ITEM_SCORE_PARAMETER_TRANSFORMER = new Function<org.opentestsystem.authoring.testauth.domain.ItemScoreParameter, ItemScoreParameter>() {
        @Override
        public ItemScoreParameter apply(final org.opentestsystem.authoring.testauth.domain.ItemScoreParameter itemScoreParameter) {
            final ItemScoreParameter isp = new ItemScoreParameter();
            isp.setMeasurementParameter(itemScoreParameter.getMeasurementParameter());
            isp.setValue(itemScoreParameter.getValue());
            return isp;
        };
    };

    protected static final Function<TestItem, String> TESTITEM_ID_TRANSFORMER = new Function<TestItem, String>() {
        @Override
        public String apply(final TestItem testItem) {
            return testItem.getDatabaseId();
        }
    };

    private static final class ITEMLOCATION_FILTER implements Predicate<ItemLocation> {
        private final String locationId;
        private final ItemGroupLocationType itemGroupLocationType;

        public static ITEMLOCATION_FILTER getInstance(final String locationId, final ItemGroupLocationType itemGroupLocationType) {
            return new ITEMLOCATION_FILTER(locationId, itemGroupLocationType);
        }

        private ITEMLOCATION_FILTER(final String aLocationId, final ItemGroupLocationType aItemGroupLocationType) {
            this.locationId = aLocationId;
            this.itemGroupLocationType = aItemGroupLocationType;
        }

        @Override
        public boolean apply(final ItemLocation itemLocation) {
            if (itemLocation instanceof FixedFormItemLocation && this.itemGroupLocationType == ItemGroupLocationType.FORM_PARTITION) {
                return StringUtils.equals(this.locationId, itemLocation.getFormPartitionId());
            } else if (itemLocation instanceof AdaptiveItemLocation && this.itemGroupLocationType == ItemGroupLocationType.SEGMENT) {
                return StringUtils.equals(this.locationId, itemLocation.getSegmentId());
            }
            return false;
        };
    }

    protected static final class ITEM_ITEMLOCATION_FILTER implements Function<Item, Item> {
        private final String locationId;
        private final ItemGroupLocationType itemGroupLocationType;

        public static ITEM_ITEMLOCATION_FILTER getInstance(final String locationId, final ItemGroupLocationType itemGroupLocationType) {
            return new ITEM_ITEMLOCATION_FILTER(locationId, itemGroupLocationType);
        }

        private ITEM_ITEMLOCATION_FILTER(final String aLocationId, final ItemGroupLocationType aItemGroupLocationType) {
            this.locationId = aLocationId;
            this.itemGroupLocationType = aItemGroupLocationType;
        }

        @Override
        public Item apply(final Item item) {
            Item returnItem = null;
            if (item != null && item.getItemLocation() != null && Iterables.any(item.getItemLocation(), ITEMLOCATION_FILTER.getInstance(this.locationId, this.itemGroupLocationType))) {
                returnItem = item;
            }
            return returnItem;
        }
    };

    protected static final Function<Segment, String> SEGMENT_KEYID_TRANSFORMER = new Function<Segment, String>() {
        @Override
        public String apply(final Segment segment) {
            return segment.getId();
        }
    };

    protected static final Function<AffinityGroup, String> AFFINITY_GROUP_KEYID_TRANSFORMER = new Function<AffinityGroup, String>() {
        @Override
        public String apply(final AffinityGroup affinityGroup) {
            return affinityGroup.getId();
        }
    };

    protected static final Function<Item, Passage> ITEM_PASSAGE_TRANSFORMER = new Function<Item, Passage>() {
        @Override
        public Passage apply(final Item item) {
            if (item != null && StringUtils.isNotBlank(item.getAssociatedStimulus())) {
                return new Passage(null, buildIdentifier(item.getAssociatedStimulus(), item.getStimulusName(), DEFAULT_VERSION));
            }
            return null;
        };
    };

    protected final static Function<Enemy, String> ENEMY_TO_ENEMYID1_TRANSFORMER = new Function<Enemy, String>() {
        @Override
        public String apply(final Enemy enemy) {
            return StringUtils.isBlank(enemy.getObjectId1()) ? EMPTY_PROPERTY : enemy.getObjectId1();
        }
    };

    protected static final Function<Enemy, String> ENEMY_TO_ENEMYID2_TRANSFORMER = new Function<Enemy, String>() {
        @Override
        public String apply(final Enemy enemy) {
            return StringUtils.isBlank(enemy.getObjectId2()) ? EMPTY_PROPERTY : enemy.getObjectId2();
        }
    };

    protected static final Function<Enemy, TestEnemy> ENEMY1_TRANSFORMER = new Function<Enemy, TestEnemy>() {
        @Override
        public TestEnemy apply(final Enemy enemy) {
            return new TestEnemy(enemy.getObjectId2(), enemy.getObjectType2().getXmlValue());
        };
    };

    protected static final Function<Enemy, TestEnemy> ENEMY2_TRANSFORMER = new Function<Enemy, TestEnemy>() {
        @Override
        public TestEnemy apply(final Enemy enemy) {
            return new TestEnemy(enemy.getObjectId1(), enemy.getObjectType1().getXmlValue());
        };
    };

    private static final class ITEMLOCATION_GROUP_PASSAGE_ID_TRANSFORMER implements Function<ItemLocation, String> {
        private final Map<String, ItemGroup> itemGroupMap;

        public static ITEMLOCATION_GROUP_PASSAGE_ID_TRANSFORMER getInstance(final Map<String, ItemGroup> itemGroupMap) {
            return new ITEMLOCATION_GROUP_PASSAGE_ID_TRANSFORMER(itemGroupMap);
        }

        private ITEMLOCATION_GROUP_PASSAGE_ID_TRANSFORMER(final Map<String, ItemGroup> itemGroupMap) {
            this.itemGroupMap = itemGroupMap;
        }

        @Override
        public String apply(final ItemLocation itemLocation) {
            return itemLocation != null && StringUtils.isNotBlank(itemLocation.getItemGroupId()) && !StringUtils.equals(itemLocation.getItemGroupId(), Item.NO_GROUP_KEY)
                    && this.itemGroupMap.get(itemLocation.getItemGroupId()) != null ? this.itemGroupMap.get(itemLocation.getItemGroupId()).getPassageId() : null;
        };
    };

    private static final class ITEM_LOCATION_SEGMENT_ID_TRANSFORMER implements Function<ItemLocation, String> {
        private final Map<String, Segment> segmentMap;

        public static ITEM_LOCATION_SEGMENT_ID_TRANSFORMER getInstance(final Map<String, Segment> segmentMap) {
            return new ITEM_LOCATION_SEGMENT_ID_TRANSFORMER(segmentMap);
        }

        private ITEM_LOCATION_SEGMENT_ID_TRANSFORMER(final Map<String, Segment> segmentMap) {
            this.segmentMap = segmentMap;
        }

        @Override
        public String apply(final ItemLocation itemLocation) {
            return itemLocation != null && StringUtils.isNotBlank(itemLocation.getSegmentId()) ? this.segmentMap.get(itemLocation.getSegmentId()).getLabel() : null;
        };
    };

    private static final class ITEM_LOCATION_AFFINITY_GROUP_ID_TRANSFORMER implements Function<ItemLocation, String> {
        private final Map<String, AffinityGroup> affinityGroupMap;

        public static ITEM_LOCATION_AFFINITY_GROUP_ID_TRANSFORMER getInstance(final Map<String, AffinityGroup> affinityGroupMap) {
            return new ITEM_LOCATION_AFFINITY_GROUP_ID_TRANSFORMER(affinityGroupMap);
        }

        private ITEM_LOCATION_AFFINITY_GROUP_ID_TRANSFORMER(final Map<String, AffinityGroup> affinityGroupMap) {
            this.affinityGroupMap = affinityGroupMap;
        }

        @Override
        public String apply(final ItemLocation itemLocation) {
            return itemLocation != null && StringUtils.isNotBlank(itemLocation.getAffinityGroupId()) ? this.affinityGroupMap.get(itemLocation.getAffinityGroupId()).getGroupName() : null;
        };
    };

    // ========================================================================================================================================================================
    // blueprint construction
    protected static final class ITEM_COUNT_FILTER implements Predicate<Item> {
        private final String standardKey;
        private final String statusKey;

        public static ITEM_COUNT_FILTER getInstance(final String standardKey, final String statusKey) {
            return new ITEM_COUNT_FILTER(standardKey, statusKey);
        }

        private ITEM_COUNT_FILTER(final String standardKey, final String statusKey) {
            this.standardKey = standardKey;
            this.statusKey = statusKey;
        }

        @Override
        public boolean apply(final Item item) {
            return item != null && item.getPrimaryStandard() != null && item.getPrimaryStandard().contains(this.standardKey)
                    && item.getStatus() != null && item.getStatus().equalsIgnoreCase(this.statusKey);
        }
    };

    // ========================================================================================================================================================================
    // segment construction
    public static final Predicate<Segment> FIXEDFORM_SEGMENT_FILTER = new Predicate<Segment>() {
        @Override
        public boolean apply(final Segment segment) {
            return segment != null && segment.getItemSelectionAlgorithm() != null && segment.getItemSelectionAlgorithm().getItemSelectionAlgorithmType() != null
                    && segment.getItemSelectionAlgorithm().getItemSelectionAlgorithmType().equals(ItemSelectionAlgorithmType.FIXEDFORM);
        }
    };

    protected static final Function<FormPartition, String> FORMPARTITION_REFERENCE_TRANSFORMER = new Function<FormPartition, String>() {
        @Override
        public String apply(final FormPartition formPartition) {
            return formPartition != null && formPartition.getName() != null ? formPartition.getName() : null;
        }
    };

    protected static final class ISP_LIST_TRANSFORMER implements Function<Entry<String, Map<String, String>>, ItemSelectionParameter> {
        private final Map<String, Segment> segmentMap;

        public static ISP_LIST_TRANSFORMER getInstance(final Map<String, Segment> segmentMap) {
            return new ISP_LIST_TRANSFORMER(segmentMap);
        }

        private ISP_LIST_TRANSFORMER(final Map<String, Segment> segmentMap) {
            this.segmentMap = segmentMap;
        }

        @Override
        public ItemSelectionParameter apply(final Entry<String, Map<String, String>> itemSelectionParameterUsage) {
            final ItemSelectionParameter isp = new ItemSelectionParameter();
            final String bpElementId = this.segmentMap.get(itemSelectionParameterUsage.getKey()) != null ? this.segmentMap.get(itemSelectionParameterUsage.getKey()).getLabel()
                    : itemSelectionParameterUsage.getKey();
            isp.setBlueprintElementId(bpElementId);
            if (!itemSelectionParameterUsage.getValue().entrySet().isEmpty()) {
                final List<Property> propertyList = Lists.newArrayList();
                for (final Entry<String, String> mapEntryValue : itemSelectionParameterUsage.getValue().entrySet()) {
                    propertyList.add(new Property(mapEntryValue.getKey(), mapEntryValue.getValue(), mapEntryValue.getKey(), null));
                }
                isp.setPropertyList(propertyList);
            }
            return isp;
        }
    };

    // ========================================================================================================================================================================
    // segment/partition item reference group/item reference (itemgroup/groupitem)
    protected static final Function<ItemGroup, String> ITEMGROUPID_KEY_TRANSFORMER = new Function<ItemGroup, String>() {
        @Override
        public String apply(final ItemGroup itemGroup) {
            return itemGroup.getId();
        }
    };
    protected static final Function<Item, List<String>> ITEM_ITEMGROUPIDLIST_TRANSFORMER = new Function<Item, List<String>>() {
        @Override
        public List<String> apply(final Item item) {
            return Lists.transform(item.getAdaptiveAndFixedItemLocations(), ITEMLOCATION_ITEMGROUP_TRANSFORMER);
        }
    };
    private static final Function<ItemLocation, String> ITEMLOCATION_ITEMGROUP_TRANSFORMER = new Function<ItemLocation, String>() {
        @Override
        public String apply(final ItemLocation itemLocation) {
            return itemLocation != null ? itemLocation.getItemGroupId() : null;
        }
    };

    protected static final class ITEM_ITEMGROUP_TRANSFORMER implements Function<Item, ItemReferenceGroup> {
        private final boolean isSegmentLevel;
        private final String locationId;

        public static ITEM_ITEMGROUP_TRANSFORMER getInstance(final boolean isSegmentLevel, final String locationId) {
            return new ITEM_ITEMGROUP_TRANSFORMER(isSegmentLevel, locationId);
        }

        private ITEM_ITEMGROUP_TRANSFORMER(final boolean isSegmentLevel, final String locationId) {
            this.isSegmentLevel = isSegmentLevel;
            this.locationId = locationId;
        }

        @Override
        public ItemReferenceGroup apply(final Item item) {
            final ItemReferenceGroup itemReferenceGroup = new ItemReferenceGroup();
            ItemLocation itemLocationToUse = null;
            for (final ItemLocation itemLocation : item.getAdaptiveAndFixedItemLocations()) {
                if (this.isSegmentLevel && StringUtils.equals(this.locationId, itemLocation.getSegmentId())
                        || !this.isSegmentLevel && StringUtils.equals(this.locationId, itemLocation.getFormPartitionId())) {
                    itemLocationToUse = itemLocation;
                }
            }
            itemReferenceGroup.setMaxResponses(this.isSegmentLevel ? null : "1");
            itemReferenceGroup.setFormPosition(itemLocationToUse != null ? String.valueOf(itemLocationToUse.getLevel1SortIndex()) : "1");
            itemReferenceGroup.setMaxItems(this.isSegmentLevel ? null : "1");
            itemReferenceGroup.setIdentifier(buildIdentifier(item.getTibIdentifier(), item.getTibIdentifier(), item.getVersion()));
            if (StringUtils.isNotBlank(item.getAssociatedStimulus())) {
                itemReferenceGroup.setPassageReferenceList(Lists.newArrayList(item.getAssociatedStimulus()));
            }
            itemReferenceGroup.setItemReferenceList(Lists.newArrayList(ITEM_ITEMREFERENCE_TRANSFORMER.getInstance(Item.NO_GROUP_KEY).apply(item)));
            // itemReferenceGroup.setProperty(null);
            return itemReferenceGroup;
        }
    };

    // construct group w/ item children
    protected static final Function<Entry<ItemGroup, List<Item>>, ItemReferenceGroup> ITEMLIST_ITEMGROUP_TRANSFORMER = new Function<Entry<ItemGroup, List<Item>>, ItemReferenceGroup>() {
        @Override
        public ItemReferenceGroup apply(final Entry<ItemGroup, List<Item>> itemGroupMapEntry) {
            final ItemReferenceGroup itemReferenceGroup = new ItemReferenceGroup();
            final ItemGroup itemGroup = itemGroupMapEntry.getKey();
            itemReferenceGroup.setMaxResponses(itemGroup.getMaxResponses().toString());
            // all items passed in SHOULD have the same ItemLocation attribute to find
            ItemLocation itemLocationToUse = null;
            for (final ItemLocation itemLocation : itemGroupMapEntry.getValue().get(0).getItemLocation()) {
                if (StringUtils.equals(itemGroup.getId(), itemLocation.getItemGroupId())) {
                    itemLocationToUse = itemLocation;
                }
            }
            itemReferenceGroup.setFormPosition(String.valueOf(itemLocationToUse.getLevel1SortIndex()));
            itemReferenceGroup.setMaxItems(itemGroup.getMaxitems().toString());
            itemReferenceGroup.setIdentifier(buildIdentifier(
                    StringUtils.isNotBlank(itemGroup.getPassageId()) ? itemGroup.getPassageId() : itemGroup.getGroupName(),
                    itemGroup.getPassageName(), DEFAULT_VERSION));
            if (StringUtils.isNotBlank(itemGroup.getPassageId())) {
                itemReferenceGroup.setPassageReferenceList(Lists.newArrayList(itemGroup.getPassageId()));
            }
            itemReferenceGroup.setItemReferenceList(Lists.transform(itemGroupMapEntry.getValue(), ITEM_ITEMREFERENCE_TRANSFORMER.getInstance(itemGroup.getId())));
            return itemReferenceGroup;
        }
    };

    private static final class ITEM_ITEMREFERENCE_TRANSFORMER implements Function<Item, ItemReference> {
        private final String itemGroupId;

        public static ITEM_ITEMREFERENCE_TRANSFORMER getInstance(final String itemGroupId) {
            return new ITEM_ITEMREFERENCE_TRANSFORMER(itemGroupId);
        }

        private ITEM_ITEMREFERENCE_TRANSFORMER(final String itemGroupId) {
            this.itemGroupId = itemGroupId;
        }

        @Override
        public ItemReference apply(final Item item) {
            ItemLocation itemLocationToUse = null;
            for (final ItemLocation itemLocation : item.getItemLocation()) {
                if (StringUtils.equals(this.itemGroupId, itemLocation.getItemGroupId())) {
                    itemLocationToUse = itemLocation;
                }
            }
            return itemLocationToUse != null ? new ItemReference(getItemMetadataIdentifier(item), itemLocationToUse.getLevel2SortIndex(),
                    itemLocationToUse.isAdminRequired(), itemLocationToUse.isResponseRequired(), itemLocationToUse.isFieldTestItem(), itemLocationToUse.isActive(),
                    itemLocationToUse.getBlockId())
                    : new ItemReference(getItemMetadataIdentifier(item), 1, true, true, false, false, ""); // latter should never actually happen
        }
    };

    protected static String getItemMetadataIdentifier(final Item item) {
        return item.getAllIncludedMetadata().get("Identifier").toString();
    }

    protected static final Ordering<ItemReferenceGroup> ITEM_REF_GROUP_ORDER = Ordering.natural().onResultOf(new Function<ItemReferenceGroup, Integer>() {
        @Override
        public Integer apply(final ItemReferenceGroup itemReferenceGroup) {
            return Integer.valueOf(itemReferenceGroup.getFormPosition());
        }
    });

    protected static final class ITEM_LOCATION_MATCHER implements Predicate<ItemLocation> {
        private final String itemGroupId;
        private final String locationId;
        private final ItemGroupLocationType itemGroupLocationType;

        public static ITEM_LOCATION_MATCHER getInstance(final String itemGroupId, final String locationId, final ItemGroupLocationType itemGroupLocationType) {
            return new ITEM_LOCATION_MATCHER(itemGroupId, locationId, itemGroupLocationType);
        }

        private ITEM_LOCATION_MATCHER(final String itemGroupId, final String locationId, final ItemGroupLocationType itemGroupLocationType) {
            this.itemGroupId = itemGroupId;
            this.locationId = locationId;
            this.itemGroupLocationType = itemGroupLocationType;
        }

        @Override
        public boolean apply(final ItemLocation itemLocation) {
            return StringUtils.equals(itemLocation.getItemGroupId(), this.itemGroupId) && ITEMLOCATION_FILTER.getInstance(this.locationId, this.itemGroupLocationType).apply(itemLocation);
        };
    }

    // ========================================================================================================================================================================
    // performance level construction
    protected static final class PERFORMANCE_LEVEL_TRANSFORMER implements Function<PerformanceLevel, List<TestPerformanceLevel>> {
        private final Map<BlueprintReferenceType, Map<String, String>> blueprintReferenceMap;

        public static PERFORMANCE_LEVEL_TRANSFORMER getInstance(final Map<BlueprintReferenceType, Map<String, String>> blueprintReferenceMap) {
            return new PERFORMANCE_LEVEL_TRANSFORMER(blueprintReferenceMap);
        }

        private PERFORMANCE_LEVEL_TRANSFORMER(final Map<BlueprintReferenceType, Map<String, String>> blueprintReferenceMap) {
            this.blueprintReferenceMap = blueprintReferenceMap;
        }

        @Override
        public List<TestPerformanceLevel> apply(final PerformanceLevel performanceLevel) {
            if (this.blueprintReferenceMap.get(performanceLevel.getBlueprintReferenceType()) != null
                    && this.blueprintReferenceMap.get(performanceLevel.getBlueprintReferenceType()).get(performanceLevel.getBlueprintReferenceId()) != null) {
                final String currentBlueprintReferenceName = this.blueprintReferenceMap.get(performanceLevel.getBlueprintReferenceType()).get(performanceLevel.getBlueprintReferenceId());
                return Lists.transform(performanceLevel.getPerformanceLevelValues(), PERFORMANCE_LEVEL_VALUE_TRANSFORMER.getInstance(currentBlueprintReferenceName));
            }
            return Lists.newArrayList();
        }
    };

    private static final class PERFORMANCE_LEVEL_VALUE_TRANSFORMER implements Function<PerformanceLevelValue, TestPerformanceLevel> {
        private final String bpElementId;

        public static PERFORMANCE_LEVEL_VALUE_TRANSFORMER getInstance(final String bpElementId) {
            return new PERFORMANCE_LEVEL_VALUE_TRANSFORMER(bpElementId);
        }

        private PERFORMANCE_LEVEL_VALUE_TRANSFORMER(final String bpElementId) {
            this.bpElementId = bpElementId;
        }

        @Override
        public TestPerformanceLevel apply(final PerformanceLevelValue performanceLevelValue) {
            return new TestPerformanceLevel(this.bpElementId, performanceLevelValue.getLevel().toString(), performanceLevelValue.getScaledLo(), performanceLevelValue.getScaledHi());
        }
    };

    // ========================================================================================================================================================================
    // scoring rule construction
    protected static final class SCORING_RULE_TRANSFORMER implements Function<ScoringRule, TestComputationRule> {
        private final Map<BlueprintReferenceType, Map<String, String>> blueprintReferenceMap;

        public static SCORING_RULE_TRANSFORMER getInstance(final Map<BlueprintReferenceType, Map<String, String>> blueprintReferenceMap) {
            return new SCORING_RULE_TRANSFORMER(blueprintReferenceMap);
        }

        private SCORING_RULE_TRANSFORMER(final Map<BlueprintReferenceType, Map<String, String>> blueprintReferenceMap) {
            this.blueprintReferenceMap = blueprintReferenceMap;
        }

        @Override
        public TestComputationRule apply(final ScoringRule scoringRule) {
            if (!(scoringRule.getBlueprintReferenceType().equals(BlueprintReferenceType.STANDARD) && !scoringRule.getBlueprintDenotationType().equals(BlueprintDenotationType.STANDARD_KEY))
                    && this.blueprintReferenceMap.get(scoringRule.getBlueprintReferenceType()) != null
                    && this.blueprintReferenceMap.get(scoringRule.getBlueprintReferenceType()).get(scoringRule.getBlueprintReferenceId()) != null) {
                final String currentBlueprintReferenceName = this.blueprintReferenceMap.get(scoringRule.getBlueprintReferenceType()).get(scoringRule.getBlueprintReferenceId());
                final TestComputationRule testComputationRule = new TestComputationRule();
                testComputationRule.setScoringRuleId(scoringRule.getId());
                testComputationRule.setBpElementId(currentBlueprintReferenceName);
                testComputationRule.setComputationOrder(scoringRule.getOrder().toString());
                final ComputationRule computationRule = scoringRule.getComputationRule();
                if (!CollectionUtils.isEmpty(computationRule.getParameters())) {
                    final Map<String, ComputationRuleParameter> computationRuleParameterMap = Maps.uniqueIndex(computationRule.getParameters(), COMPUTATION_RULE_PARAM_NAME_TRANSFORMER);
                    testComputationRule.setComputationRuleParameterList(Lists.transform(scoringRule.getParameters(),
                            SCORING_RULE_PARAMETER_TRANSFORMER.getInstance(scoringRule.getLabel(), computationRuleParameterMap)));
                }
                testComputationRule.setIdentifier(buildIdentifier(scoringRule.getLabel(), computationRule.getName(), computationRule.getVersion()));
                return testComputationRule;
            }
            return null;
        }
    };

    private static final Function<ComputationRuleParameter, String> COMPUTATION_RULE_PARAM_NAME_TRANSFORMER = new Function<ComputationRuleParameter, String>() {
        @Override
        public String apply(final ComputationRuleParameter computationRuleParameter) {
            return StringUtils.isBlank(computationRuleParameter.getParameterName()) ? EMPTY_PROPERTY : computationRuleParameter.getParameterName();
        }
    };

    private static final class SCORING_RULE_PARAMETER_TRANSFORMER implements Function<ScoringRuleParameter, TestComputationRuleParameter> {
        private final String scoringRuleName;
        private final Map<String, ComputationRuleParameter> computationRuleParameterMap;

        public static SCORING_RULE_PARAMETER_TRANSFORMER getInstance(final String scoringRuleName, final Map<String, ComputationRuleParameter> computationRuleParameterMap) {
            return new SCORING_RULE_PARAMETER_TRANSFORMER(scoringRuleName, computationRuleParameterMap);
        }

        private SCORING_RULE_PARAMETER_TRANSFORMER(final String scoringRuleName, final Map<String, ComputationRuleParameter> computationRuleParameterMap) {
            this.scoringRuleName = scoringRuleName;
            this.computationRuleParameterMap = computationRuleParameterMap;
        }

        @Override
        public TestComputationRuleParameter apply(final ScoringRuleParameter scoringRuleParameter) {
            final TestComputationRuleParameter testComputationRuleParameter = new TestComputationRuleParameter();
            final ComputationRuleParameter computationRuleParameter = this.computationRuleParameterMap.get(scoringRuleParameter.getComputationRuleParameterName());
            testComputationRuleParameter.setPosition(String.valueOf(computationRuleParameter.getPosition()));
            testComputationRuleParameter.setParameterType(computationRuleParameter.getComputationRuleType().name().toLowerCase());
            final String paramName = scoringRuleParameter.getComputationRuleParameterName();
            testComputationRuleParameter.setIdentifier(buildIdentifier(this.scoringRuleName, paramName, DEFAULT_VERSION));
            if (StringUtils.isNotBlank(scoringRuleParameter.getScalarValue())) {
                testComputationRuleParameter.setComputationRuleParameterValueList(Lists.newArrayList(new TestComputationRuleParameterValue(scoringRuleParameter.getScalarValue(), null)));
            } else {
                testComputationRuleParameter.setComputationRuleParameterValueList(Lists.transform(scoringRuleParameter.getDictionaryValue(), this.SCORING_RULE_DICTIONARY_TRANSFORMER));
            }
            return testComputationRuleParameter;
        }

        private final Function<ScoringRuleDictionaryElement, TestComputationRuleParameterValue> SCORING_RULE_DICTIONARY_TRANSFORMER = new Function<ScoringRuleDictionaryElement, TestComputationRuleParameterValue>() {
            @Override
            public TestComputationRuleParameterValue apply(final ScoringRuleDictionaryElement dictionary) {
                return new TestComputationRuleParameterValue(dictionary.getValue(), dictionary.getKey());
            }
        };
    };

    protected static final class CONVERSION_TABLE_TRANSFORMER implements Function<ScoringRule, List<ConversionTable>> {
        private final GridFsRepository gridFsRepository;

        public static CONVERSION_TABLE_TRANSFORMER getInstance(final GridFsRepository gridFsRepository) {
            return new CONVERSION_TABLE_TRANSFORMER(gridFsRepository);
        }

        private CONVERSION_TABLE_TRANSFORMER(final GridFsRepository gridFsRepository) {
            this.gridFsRepository = gridFsRepository;
        }

        @Override
        public List<ConversionTable> apply(final ScoringRule scoringRule) {
            if (scoringRule.getComputationRule().getConversionTableType().equals(ConversionTableType.NONE)) {
                return null;
            }
            final List<ConversionTable> conversionTableList = Lists.newArrayList();
            if (StringUtils.isNotEmpty(scoringRule.getValueConversionTableGridFsId())) {
                final ConversionTable conversionTable = new ConversionTable(scoringRule.getBlueprintReferenceName(), null, "score", null,
                        buildIdentifier(scoringRule.getValueConversionTableFilename(), null, DEFAULT_VERSION),
                        buildConversionTupleForScoringRule(scoringRule.getValueConversionTableGridFsId(), scoringRule.getLabel(), "VALUE"));
                conversionTableList.add(conversionTable);
            }
            if (StringUtils.isNotEmpty(scoringRule.getStandardErrorConversionTableGridFsId())) {
                final ConversionTable conversionTable = new ConversionTable(scoringRule.getBlueprintReferenceName(), null, "standarderror", null,
                        buildIdentifier(scoringRule.getStandardErrorConversionTableFilename(), null, DEFAULT_VERSION),
                        buildConversionTupleForScoringRule(scoringRule.getStandardErrorConversionTableGridFsId(), scoringRule.getLabel(), "STANDARD_ERROR"));
                conversionTableList.add(conversionTable);
            }

            return conversionTableList;
        }

        private List<ConversionTuple> buildConversionTupleForScoringRule(final String gridFsId, final String scoringRuleName, final String conversionTableType) {
            final GridFSDBFile file = this.gridFsRepository.getById(gridFsId);
            final ByteArrayOutputStream baos = new ByteArrayOutputStream();
            try {
                file.writeTo(baos);
            } catch (final IOException e) {
                throw new LocalizedException("publishingRecord.conversionTableFile.ioexception", paramArray(scoringRuleName, conversionTableType));
            }
            final List<ConversionTuple> conversionTupleList = validateConversionListFile(baos.toByteArray(), scoringRuleName, conversionTableType, true);
            // do not return header row as that should not make it into outbound XML
            return conversionTupleList.subList(1, conversionTupleList.size());
        }
    };

    public static List<ConversionTuple> validateConversionListFile(final byte[] file, final String name, final String fileType, final boolean publishMode) {
        final List<ConversionTuple> conversionTupleList = Lists.newArrayList();
        final String messagePrefix = publishMode ? "publishingRecord" : "scoringRule";
        CSVReader reader = null;
        try {
            reader = new CSVReader(new InputStreamReader(new ByteArrayInputStream(file), Charset.forName("UTF-8")));

            String[] csvContent;
            int i = 0;

            while ((csvContent = reader.readNext()) != null) {
                if (csvContent != null && csvContent.length > 1) {
                    if (i == 0) { // first record, validate headers
                        if (!StringUtils.equalsIgnoreCase("invalue", csvContent[0])) {
                            throw new LocalizedException(messagePrefix + ".conversionTableFile.header.invalue", paramArray(name, fileType));
                        } else if (!StringUtils.equalsIgnoreCase("outvalue", csvContent[1])) {
                            throw new LocalizedException(messagePrefix + ".conversionTableFile.header.outvalue", paramArray(name, fileType));
                        }
                    }
                    conversionTupleList.add(new ConversionTuple(csvContent[0], csvContent[1]));
                } else {
                    throw new LocalizedException(messagePrefix + ".conversionTableFile.unparseable", paramArray(name, fileType));
                }
                i++;
            }
        } catch (final IOException e) {
            throw new LocalizedException(messagePrefix + ".conversionTableFile.ioexception", paramArray(name, fileType));
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (final IOException e) {
                    throw new LocalizedException(messagePrefix + ".conversionTableFile.closeexception", paramArray(name, fileType));
                }
            }
        }
        return conversionTupleList;
    }

    protected static final class LEAF_NODE_LEVEL_SCORING_RULE_TRANSFORMER implements Function<BlueprintElement, TestComputationRule> {
        private final ScoringRule scoringRule;
        private int orderIncr;

        public static LEAF_NODE_LEVEL_SCORING_RULE_TRANSFORMER getInstance(final ScoringRule scoringRule, final int orderIncr) {
            return new LEAF_NODE_LEVEL_SCORING_RULE_TRANSFORMER(scoringRule, orderIncr);
        }

        private LEAF_NODE_LEVEL_SCORING_RULE_TRANSFORMER(final ScoringRule scoringRule, final int orderIncr) {
            this.scoringRule = scoringRule;
            this.orderIncr = orderIncr;
        }

        @Override
        public TestComputationRule apply(final BlueprintElement blueprintElement) {
            final TestComputationRule testComputationRule = new TestComputationRule();
            testComputationRule.setScoringRuleId(this.scoringRule.getId());
            testComputationRule.setBpElementId(blueprintElement.getStandardKey());
            testComputationRule.setComputationOrder(this.scoringRule.getOrder().toString() + "." + StringUtils.leftPad(String.valueOf(this.orderIncr++), 5, '0'));
            final ComputationRule computationRule = this.scoringRule.getComputationRule();
            if (!CollectionUtils.isEmpty(computationRule.getParameters())) {
                final Map<String, ComputationRuleParameter> computationRuleParameterMap = Maps.uniqueIndex(computationRule.getParameters(), COMPUTATION_RULE_PARAM_NAME_TRANSFORMER);
                testComputationRule.setComputationRuleParameterList(Lists.transform(this.scoringRule.getParameters(),
                        SCORING_RULE_PARAMETER_TRANSFORMER.getInstance(this.scoringRule.getLabel(), computationRuleParameterMap)));
            }
            testComputationRule.setIdentifier(buildIdentifier(this.scoringRule.getLabel() + testComputationRule.getComputationOrder(), computationRule.getName(), computationRule.getVersion()));
            return testComputationRule;
        }
    };

    protected static final Predicate<ScoringRule> LEAF_NODE_TYPE_FILTER = new Predicate<ScoringRule>() {
        @Override
        public boolean apply(final ScoringRule scoringRule) {
            return scoringRule != null && BlueprintDenotationType.LEAF_NODES == scoringRule.getBlueprintDenotationType();
        }
    };

    protected static final Predicate<BlueprintElement> PARENT_KEY_FILTER = new Predicate<BlueprintElement>() {
        @Override
        public boolean apply(final BlueprintElement bpElement) {
            return StringUtils.isBlank(bpElement.getParentKey());
        }
    };
    protected static final Function<BlueprintElement, String> BP_PARENT_KEY_TRANSFORMER = new Function<BlueprintElement, String>() {
        @Override
        public String apply(final BlueprintElement bpElement) {
            return bpElement.getParentKey();
        }
    };

    protected static final class NON_LEAF_NODE_FILTER implements Predicate<BlueprintElement> {
        private final Set<String> parentKeys;

        public static NON_LEAF_NODE_FILTER getInstance(final Set<String> parentKeys) {
            return new NON_LEAF_NODE_FILTER(parentKeys);
        }

        private NON_LEAF_NODE_FILTER(final Set<String> parentKeys) {
            this.parentKeys = parentKeys;
        }

        @Override
        public boolean apply(final BlueprintElement bpElement) {
            return this.parentKeys.contains(bpElement.getStandardKey());
        }
    }

    protected static final Predicate<ScoringRule> LEVEL_TYPE_FILTER = new Predicate<ScoringRule>() {
        @Override
        public boolean apply(final ScoringRule scoringRule) {
            return scoringRule != null && BlueprintDenotationType.LEVEL == scoringRule.getBlueprintDenotationType();
        }
    };

    protected static final class LEVEL_FILTER implements Predicate<BlueprintElement> {
        private final String level;

        public static LEVEL_FILTER getInstance(final String level) {
            return new LEVEL_FILTER(level);
        }

        private LEVEL_FILTER(final String level) {
            this.level = level;
        }

        @Override
        public boolean apply(final BlueprintElement bpElement) {
            return StringUtils.equals(this.level, bpElement.getLevel());
        }
    }

    protected static final Ordering<TestComputationRule> COMPUTATION_RULE_ORDER = Ordering.natural().onResultOf(new Function<TestComputationRule, BigDecimal>() {
        @Override
        public BigDecimal apply(final TestComputationRule testComputationRule) {
            return new BigDecimal(testComputationRule.getComputationOrder());
        }
    });

    protected static final class COMP_RULE_REORDER_TRANSFORMER implements Function<TestComputationRule, TestComputationRule> {
        private int orderIncr;

        public static COMP_RULE_REORDER_TRANSFORMER getInstance(final int orderIncr) {
            return new COMP_RULE_REORDER_TRANSFORMER(orderIncr);
        }

        private COMP_RULE_REORDER_TRANSFORMER(final int orderIncr) {
            this.orderIncr = orderIncr;
        }

        @Override
        public TestComputationRule apply(final TestComputationRule testComputationRule) {
            testComputationRule.setComputationOrder(String.valueOf(this.orderIncr++));
            return testComputationRule;
        }
    };

    protected static final Function<TestComputationRule, String> COMPRULE_MULTIMAP_TRANSFORMER = new Function<TestComputationRule, String>() {
        @Override
        public String apply(final TestComputationRule testComputationRule) {
            return testComputationRule.getScoringRuleId();
        }
    };

    // ========================================================================================================================================================================
    // reporting measure construction
    protected static final class REPORTING_MEASURE_TRANSFORMER implements Function<ReportingMeasure, List<TestReportingMeasure>> {
        private final Map<BlueprintReferenceType, Map<String, String>> blueprintReferenceMap;
        private final Map<String, Collection<TestComputationRule>> scoringRuleReferenceMap;

        public static REPORTING_MEASURE_TRANSFORMER getInstance(final Map<BlueprintReferenceType, Map<String, String>> blueprintReferenceMap,
                final Map<String, Collection<TestComputationRule>> scoringRuleReferenceMap) {
            return new REPORTING_MEASURE_TRANSFORMER(blueprintReferenceMap, scoringRuleReferenceMap);
        }

        private REPORTING_MEASURE_TRANSFORMER(final Map<BlueprintReferenceType, Map<String, String>> blueprintReferenceMap, final Map<String, Collection<TestComputationRule>> scoringRuleReferenceMap) {
            this.blueprintReferenceMap = blueprintReferenceMap;
            this.scoringRuleReferenceMap = scoringRuleReferenceMap;
        }

        @Override
        public List<TestReportingMeasure> apply(final ReportingMeasure reportingMeasure) {
            if (this.blueprintReferenceMap.get(reportingMeasure.getBlueprintReferenceType()) != null) {
                final Map<String, Collection<TestComputationRule>> rulesNeedingMeasureMap = Maps.filterEntries(this.scoringRuleReferenceMap,
                        RULES_MATCHING_MEASURE_FILTER.getInstance(reportingMeasure.getScoringRuleIdList()));
                final List<TestReportingMeasure> testReportingMeasureList = Lists.newArrayList();

                if (reportingMeasure.getBlueprintReferenceType() == BlueprintReferenceType.STANDARD && (reportingMeasure.getBlueprintDenotationType() == BlueprintDenotationType.LEVEL
                        || reportingMeasure.getBlueprintDenotationType() == BlueprintDenotationType.LEAF_NODES)) {
                    for (final Collection<TestComputationRule> levelCompRuleList : rulesNeedingMeasureMap.values()) {
                        for (final TestComputationRule testComputationRule : levelCompRuleList) {
                            testReportingMeasureList.add(new TestReportingMeasure(testComputationRule.getBpElementId(),
                                    Lists.newArrayList(new ScoreType(testComputationRule.getIdentifier().getName(), testComputationRule.getIdentifier().getLabel()))));
                        }
                    }
                } else if (this.blueprintReferenceMap.get(reportingMeasure.getBlueprintReferenceType()).get(reportingMeasure.getBlueprintReferenceId()) != null) {
                    final String currentBlueprintReferenceName = this.blueprintReferenceMap.get(reportingMeasure.getBlueprintReferenceType()).get(reportingMeasure.getBlueprintReferenceId());
                    testReportingMeasureList.add(new TestReportingMeasure(currentBlueprintReferenceName,
                            Lists.newArrayList(Iterables.concat(nullsafeListTransform(reportingMeasure.getScoringRuleIdList(),
                                    REPORTINGMEASURE_SCORINGREFERENCE_TRANSFORMER.getInstance(rulesNeedingMeasureMap))))));
                }

                return testReportingMeasureList;
            }
            return null;
        }
    };

    private static final class RULES_MATCHING_MEASURE_FILTER implements Predicate<Entry<String, Collection<TestComputationRule>>> {
        private final List<String> scoringRuleIdList;

        public static RULES_MATCHING_MEASURE_FILTER getInstance(final List<String> scoringRuleIdList) {
            return new RULES_MATCHING_MEASURE_FILTER(scoringRuleIdList);
        }

        private RULES_MATCHING_MEASURE_FILTER(final List<String> scoringRuleIdList) {
            this.scoringRuleIdList = scoringRuleIdList;
        }

        @Override
        public boolean apply(final Entry<String, Collection<TestComputationRule>> testComputationRuleEntry) {
            return this.scoringRuleIdList != null && testComputationRuleEntry != null && this.scoringRuleIdList.contains(testComputationRuleEntry.getKey());
        }
    };

    private static final class REPORTINGMEASURE_SCORINGREFERENCE_TRANSFORMER implements Function<String, List<ScoreType>> {
        private final Map<String, Collection<TestComputationRule>> scoringRuleReferenceMap;

        public static REPORTINGMEASURE_SCORINGREFERENCE_TRANSFORMER getInstance(final Map<String, Collection<TestComputationRule>> scoringRuleReferenceMap) {
            return new REPORTINGMEASURE_SCORINGREFERENCE_TRANSFORMER(scoringRuleReferenceMap);
        }

        private REPORTINGMEASURE_SCORINGREFERENCE_TRANSFORMER(final Map<String, Collection<TestComputationRule>> scoringRuleReferenceMap) {
            this.scoringRuleReferenceMap = scoringRuleReferenceMap;
        }

        @Override
        public List<ScoreType> apply(final String scoringRuleId) {
            if (this.scoringRuleReferenceMap.containsKey(scoringRuleId)) {
                final List<ScoreType> scoreTypeList = Lists.newArrayList();
                for (final TestComputationRule compRule : this.scoringRuleReferenceMap.get(scoringRuleId)) {
                    scoreTypeList.add(new ScoreType(compRule.getIdentifier().getName(), compRule.getIdentifier().getLabel()));
                }
                return scoreTypeList;
            }
            return null;
        }
    };
}