/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.service.impl;

import static org.opentestsystem.authoring.testauth.service.impl.ItemHelper.FT_OR_ADAPTIVE_SEGMENT_FILTER;

import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.opentestsystem.authoring.testauth.domain.AffinityGroup;
import org.opentestsystem.authoring.testauth.domain.Assessment;
import org.opentestsystem.authoring.testauth.domain.BlueprintElement;
import org.opentestsystem.authoring.testauth.domain.BlueprintElementValue;
import org.opentestsystem.authoring.testauth.domain.FormPartition;
import org.opentestsystem.authoring.testauth.domain.Item;
import org.opentestsystem.authoring.testauth.domain.ItemCountSummary;
import org.opentestsystem.authoring.testauth.domain.ItemLocation;
import org.opentestsystem.authoring.testauth.domain.Segment;
import org.opentestsystem.authoring.testauth.domain.search.ItemSearchRequest;
import org.opentestsystem.authoring.testauth.persistence.AssessmentRepository;
import org.opentestsystem.authoring.testauth.persistence.ItemRepository;
import org.opentestsystem.authoring.testauth.persistence.SegmentRepository;
import org.opentestsystem.authoring.testauth.service.AffinityGroupService;
import org.opentestsystem.authoring.testauth.service.BlueprintElementService;
import org.opentestsystem.authoring.testauth.service.FormPartitionService;
import org.opentestsystem.authoring.testauth.service.SegmentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.google.common.collect.Iterables;
import com.google.common.collect.Maps;

@Component
public class ItemCountHelper extends ItemBaseHelper {

    @Autowired
    private transient AssessmentRepository assessmentRepository;
  
    @Autowired
    private transient ItemRepository itemRepository;

    @Autowired
    private SegmentRepository segmentRepository;

    @Autowired
    private SegmentService segmentService;

    @Autowired
    private AffinityGroupService affinityGroupService;

    @Autowired
    private BlueprintElementService blueprintElementService;

    @Autowired
    private FormPartitionService formPartitionService;

    // standardKey - > grade -> itemCounts
    protected Map<String, Map<String, ItemCountSummary>> getSegmentItemCounts(final String segmentId) {
        final Map<String, Map<String, ItemCountSummary>> itemCountsMap = Maps.newHashMap();
        final Segment segment = this.segmentRepository.findOne(segmentId);
        if (segment != null) {
            final List<BlueprintElement> blueprintElements = this.blueprintElementService.getBlueprintElementsByAssessmentId(segment.getAssessmentId());
            final List<Item> items = this.itemRepository.findAllBySegmentId(segmentId);

            for (final BlueprintElement blueprintElement : blueprintElements) {

                final BlueprintElementValue bpElementValue = blueprintElement.getBlueprintElementValueMap().get(segmentId);
                int opCount = 0;
                int ftCount = 0;
                for (final Item item : items) {
                    if (isItemAlignedToBlueprintElement(item, blueprintElement)) {
                        for (final ItemLocation itemLocation : item.getItemLocation()) {
                            if (itemLocation.isFieldTestItem()) {
                                ftCount++;
                            } else {
                                opCount++;
                            }
                        }
                    }
                }

                final ItemCountSummary itemCount = new ItemCountSummary();
                itemCount.setOpMin(bpElementValue.getOperationalItemMinValue());
                itemCount.setOpMax(bpElementValue.getOperationalItemMaxValue());
                itemCount.setOpCount(opCount);
                itemCount.setFtMin(bpElementValue.getFieldTestItemMinValue());
                itemCount.setFtMax(bpElementValue.getFieldTestItemMaxValue());
                itemCount.setFtCount(ftCount);

                if (itemCountsMap.get(blueprintElement.getStandardKey()) == null) {
                    itemCountsMap.put(blueprintElement.getStandardKey(), new HashMap<String, ItemCountSummary>());
                }
                itemCountsMap.get(blueprintElement.getStandardKey()).put(blueprintElement.getGrade(), itemCount);
            }
        }
        return itemCountsMap;
    }

    @SuppressWarnings("unchecked")
    private static final boolean isItemAlignedToBlueprintElement(final Item item, final BlueprintElement blueprintElement) {
        final String itemIntendedGrade = (String) item.getAllIncludedMetadata().get("IntendedGrade");

        if (itemIntendedGrade.equals(blueprintElement.getGrade())) { // grade aligned
            final List<Map<String, Object>> itemPublicationList = (List<Map<String, Object>>) item.getAllIncludedMetadata().get("StandardPublication");

            if (CollectionUtils.isNotEmpty(itemPublicationList)) {
                for (final Map<String, Object> publication : itemPublicationList) {
                    final String primaryStandard = (String) publication.get("PrimaryStandard");
                    if (StringUtils.isNotBlank(primaryStandard) && primaryStandard.contains(blueprintElement.getStandardKey())) { // standard aligned
                        return true;
                    }
                }
            }
        }

        return false;
    }

    protected Map<String, Map<BlueprintElement, ItemCountSummary>> getAdaptiveSegmentStandardItemCounts(final String assessmentId) {
        final Map<String, Map<BlueprintElement, ItemCountSummary>> itemCountsMap = Maps.newLinkedHashMap();

        final Assessment assessment = this.assessmentRepository.findOne(assessmentId);
        final List<Segment> allSegments = this.segmentService.findSegmentListByAssessmentId(assessmentId);
        this.segmentService.loadReferenceData(allSegments);
        final List<BlueprintElement> blueprintElements = this.blueprintElementService.getBlueprintElementsByAssessmentId(assessmentId);

        for (final Segment segment : Iterables.filter(allSegments, FT_OR_ADAPTIVE_SEGMENT_FILTER)) {
            if (itemCountsMap.get(segment.getId()) == null) {
                itemCountsMap.put(segment.getId(), new LinkedHashMap<BlueprintElement, ItemCountSummary>());
            }

            final List<Item> items = this.itemRepository.findAllBySegmentId(segment.getId());

            for (final BlueprintElement blueprintElement : blueprintElements) {
                if (blueprintElement.isActive()) {
                    final ItemCountSummary itemCount = new ItemCountSummary();
                    itemCount.setOpMin(blueprintElement.getBlueprintElementValueMap().get(segment.getId()).getOperationalItemMinValue());
                    itemCount.setOpMax(blueprintElement.getBlueprintElementValueMap().get(segment.getId()).getOperationalItemMaxValue());
                    itemCount.setOpCount(0);
                    itemCount.setFtMin(blueprintElement.getBlueprintElementValueMap().get(segment.getId()).getFieldTestItemMinValue());
                    itemCount.setFtMax(blueprintElement.getBlueprintElementValueMap().get(segment.getId()).getFieldTestItemMaxValue());
                    itemCount.setFtCount(0);

                    for (final Item alignedItem : Iterables.filter(items, ItemHelper.ITEM_STANDARD_KEY_AND_GRADE_FILTER.getInstance(cutClientName(assessment.getClient (), blueprintElement.getStandardKey()), blueprintElement.getGrade()))) {
                        for (final ItemLocation itemLocation : alignedItem.getAdaptiveAndFixedItemLocations()) {
                            if (segment.getId().equals(itemLocation.getSegmentId())) {
                                if (itemLocation.isFieldTestItem()) {
                                    itemCount.setFtCount(itemCount.getFtCount() + 1);
                                } else {
                                    itemCount.setOpCount(itemCount.getOpCount() + 1);
                                }
                            }
                        }
                    }

                    itemCountsMap.get(segment.getId()).put(blueprintElement, itemCount);
                }
            }
        }
        return itemCountsMap;
    }

    /**
     * This method is used to remove the client name and the trailing dash from the standard key.
     * The stripped key is returned and will be used in finding partial matches with blueprint list
     * in ItemHelper.ITEM_STANDARD_KEY_AND_GRADE_FILTER.
     * If the clientName is not found in the key, the complete standardKey is returned.
     * Example: SBAC-1-IT|2-LCD will get converted into 1-IT|2-LCD
     * @param  final String clientName - The Client Name, retrieved from assessment.getClient()
     * @param  String standardKey - The key to be stripped
     * @return standardKey (stripped of the client name, if any).
     */
    private String cutClientName(final String clientName, String standardKey)
    {
      int index = standardKey.indexOf(clientName.concat("-"));
      if (index > -1)
        return standardKey.substring(clientName.length()+1);
      else return standardKey;
    }
    
    protected Map<String, Map<BlueprintElement, ItemCountSummary>> getFormPartitionStandardItemCounts(final String assessmentId) {
        final Map<String, Map<BlueprintElement, ItemCountSummary>> itemCountsMap = Maps.newLinkedHashMap();

        final List<FormPartition> formPartitions = this.formPartitionService.getFormPartitionsByAssessmentId(assessmentId);
        final List<BlueprintElement> blueprintElements = this.blueprintElementService.getBlueprintElementsByAssessmentId(assessmentId);
        final Assessment assessment = this.assessmentRepository.findOne(assessmentId);
        
        for (final FormPartition formPartition : formPartitions) {
            if (itemCountsMap.get(formPartition.getId()) == null) {
                itemCountsMap.put(formPartition.getId(), new LinkedHashMap<BlueprintElement, ItemCountSummary>());
            }

            final List<Item> items = this.itemRepository.findAllByFormPartitionId(formPartition.getId());

            for (final BlueprintElement blueprintElement : blueprintElements) {
                if (blueprintElement.isActive()) {
                    final ItemCountSummary itemCount = new ItemCountSummary();
                    itemCount.setOpMin(blueprintElement.getBlueprintElementValueMap().get(formPartition.getSegmentId()).getOperationalItemMinValue());
                    itemCount.setOpMax(blueprintElement.getBlueprintElementValueMap().get(formPartition.getSegmentId()).getOperationalItemMaxValue());
                    itemCount.setOpCount(0);
                    itemCount.setFtMin(blueprintElement.getBlueprintElementValueMap().get(formPartition.getSegmentId()).getFieldTestItemMinValue());
                    itemCount.setFtMax(blueprintElement.getBlueprintElementValueMap().get(formPartition.getSegmentId()).getFieldTestItemMaxValue());
                    itemCount.setFtCount(0);

                    for (final Item alignedItem : Iterables.filter(items, ItemHelper.ITEM_STANDARD_KEY_AND_GRADE_FILTER.getInstance(cutClientName(assessment.getClient (), blueprintElement.getStandardKey()),  blueprintElement.getGrade()))) {
                        for (final ItemLocation itemLocation : alignedItem.getAdaptiveAndFixedItemLocations()) {
                            if (formPartition.getId().equals(itemLocation.getFormPartitionId())) {
                                if (itemLocation.isFieldTestItem() && itemLocation.isAssociatedItem () == false) {
                                    itemCount.setFtCount(itemCount.getFtCount() + 1);
                                } else if  (itemLocation.isFieldTestItem() == false && itemLocation.isAssociatedItem () == false) {
                                    itemCount.setOpCount(itemCount.getOpCount() + 1);
                                }
                            }
                        }
                    }

                    itemCountsMap.get(formPartition.getId()).put(blueprintElement, itemCount);
                }
            }
        }
        return itemCountsMap;
    }

    /**
     * Get item counts for each segment in the affinity group
     * 
     * @param affinityGroupId
     * @return map of segmentId -> item count summary
     */
    protected Map<String, ItemCountSummary> getAffinityGroupItemCounts(final String affinityGroupId) {
        final Map<String, ItemCountSummary> segmentIdToItemCountMap = Maps.newHashMap();
        final AffinityGroup affinityGroup = this.affinityGroupService.getAffinityGroup(affinityGroupId);

        // setup locationId map
        final List<Segment> segments = this.segmentService.findSegmentListByAssessmentId(affinityGroup.getAssessmentId());

        for (final Segment segment : segments) {
            final ItemCountSummary itemCount = new ItemCountSummary();
            itemCount.setOpMin(affinityGroup.getAffinityGroupValueMap().get(segment.getId()).getOperationalItemMinValue());
            itemCount.setOpMax(affinityGroup.getAffinityGroupValueMap().get(segment.getId()).getOperationalItemMaxValue());
            itemCount.setOpCount(0);
            itemCount.setFtMin(affinityGroup.getAffinityGroupValueMap().get(segment.getId()).getFieldTestItemMinValue());
            itemCount.setFtMax(affinityGroup.getAffinityGroupValueMap().get(segment.getId()).getFieldTestItemMaxValue());
            itemCount.setFtCount(0);
            segmentIdToItemCountMap.put(segment.getId(), itemCount);
        }

        // populate item counts
        final Map<String, String[]> itemParams = Maps.newHashMap();
        itemParams.put("assessmentId", new String[] { affinityGroup.getAssessmentId() });
        itemParams.put("affinityGroupId", new String[] { affinityGroup.getId() });
        itemParams.put("pageSize", new String[] { "99999" });
        final List<Item> affinityGroupItems = searchItems(new ItemSearchRequest(itemParams)).getSearchResults();

        for (final Item item : affinityGroupItems) {
            for (final ItemLocation itemLocation : item.getAdaptiveAndFixedItemLocations()) {
                // determine segmentId from segment or form partition location
                String itemLocationSegmentId = null;
                if (StringUtils.isNotBlank(itemLocation.getSegmentId())) {
                    itemLocationSegmentId = itemLocation.getSegmentId();
                } else if (StringUtils.isNotBlank(itemLocation.getFormPartitionId())) {
                    final FormPartition formPartition = this.formPartitionService.getFormPartition(itemLocation.getFormPartitionId());
                    itemLocationSegmentId = formPartition.getSegmentId();
                }

                // increase item counts
                if (itemLocation.isFieldTestItem()) {
                    final int currentFtCount = segmentIdToItemCountMap.get(itemLocationSegmentId).getFtCount();
                    segmentIdToItemCountMap.get(itemLocationSegmentId).setFtCount(currentFtCount + 1);
                } else {
                    final int currentOpCount = segmentIdToItemCountMap.get(itemLocationSegmentId).getOpCount();
                    segmentIdToItemCountMap.get(itemLocationSegmentId).setOpCount(currentOpCount + 1);
                }
            }
        }

        return segmentIdToItemCountMap;
    }
}
