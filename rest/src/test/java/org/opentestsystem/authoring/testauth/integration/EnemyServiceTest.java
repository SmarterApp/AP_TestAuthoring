/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.integration;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.notNullValue;
import static org.hamcrest.CoreMatchers.nullValue;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.Assert.fail;

import javax.validation.ConstraintViolationException;

import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.authoring.testauth.domain.Assessment;
import org.opentestsystem.authoring.testauth.domain.DomainFactory;
import org.opentestsystem.authoring.testauth.domain.Enemy;
import org.opentestsystem.authoring.testauth.domain.EnemyType;
import org.opentestsystem.authoring.testauth.domain.Item;
import org.opentestsystem.authoring.testauth.domain.ItemGroup;
import org.opentestsystem.authoring.testauth.domain.Publication;
import org.opentestsystem.authoring.testauth.domain.Subject;
import org.opentestsystem.authoring.testauth.persistence.AssessmentRepository;
import org.opentestsystem.authoring.testauth.persistence.ItemGroupRepository;
import org.opentestsystem.authoring.testauth.persistence.ItemRepository;
import org.opentestsystem.authoring.testauth.rest.AbstractRestEmbeddedMongoTest;
import org.opentestsystem.authoring.testauth.service.EnemyService;
import org.opentestsystem.authoring.testauth.service.PublicationService;
import org.opentestsystem.authoring.testauth.service.SubjectService;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.springframework.beans.factory.annotation.Autowired;

import com.google.common.collect.ImmutableMap;

public class EnemyServiceTest extends AbstractRestEmbeddedMongoTest {

    @Autowired
    private SubjectService subjectService;

    @Autowired
    private PublicationService publicationService;

    @Autowired
    private AssessmentRepository assessmentRepository;

    @Autowired
    private ItemRepository itemRepository;

    @Autowired
    private ItemGroupRepository itemGroupRepository;

    @Autowired
    private EnemyService enemyService;

    private Assessment savedAssessment;
    private Item savedItem;
    private Item savedItem2;
    private Item savedItem3;
    private ItemGroup savedItemGroup;

    @Before
    public void setupTestData() {
        final Subject savedSubject = this.subjectService.saveSubject(DomainFactory.manufactureValidSubject("abb"));
        final Publication savedPublication = this.publicationService.savePublication(PODAM_FACTORY.manufacturePojo(Publication.class));
        this.savedAssessment = this.assessmentRepository.save(DomainFactory.manufactureValidAssessment(savedSubject, savedPublication));

        this.savedItem = this.itemRepository.save(DomainFactory.manufactureValidItem(this.savedAssessment.getId()));
        this.savedItem2 = this.itemRepository.save(DomainFactory.manufactureValidItem(this.savedAssessment.getId()));
        this.savedItem3 = this.itemRepository.save(DomainFactory.manufactureValidItem(this.savedAssessment.getId()));
        this.savedItemGroup = this.itemGroupRepository.save(DomainFactory.manufactureValidAdaptiveItemGroup("segment-id"));
    }

    @Test
    public void saveNewEnemyTest() {
        final Enemy enemyToSave = DomainFactory.manufactureValidEnemy(this.savedAssessment.getId(), this.savedItem.getTibIdentifier(), EnemyType.ITEM, this.savedItemGroup.getId(),
                EnemyType.ITEM_GROUP);

        final Enemy savedEnemy = this.enemyService.saveEnemy(null, enemyToSave);
        assertThat(savedEnemy, is(notNullValue()));

        final Enemy retrievedEnemy = this.enemyService.getEnemy(savedEnemy.getId());
        assertThat(retrievedEnemy, is(notNullValue()));
    }

    @Test
    public void saveEnemyPopulatesObjectIdSearchTest() {
        final Enemy enemyToSave = DomainFactory.manufactureValidEnemy(this.savedAssessment.getId(), this.savedItem.getTibIdentifier(), EnemyType.ITEM, this.savedItemGroup.getId(),
                EnemyType.ITEM_GROUP);

        final Enemy savedEnemy = this.enemyService.saveEnemy(null, enemyToSave);
        assertThat(savedEnemy, is(notNullValue()));

        final Enemy retrievedEnemy = this.enemyService.getEnemy(savedEnemy.getId());
        assertThat(retrievedEnemy, is(notNullValue()));
        assertThat(retrievedEnemy.getObjectIdSearch().length, is(2));
        assertThat(retrievedEnemy.getObjectIdSearch()[0], is(this.savedItem.getTibIdentifier()));
        assertThat(retrievedEnemy.getObjectIdSearch()[1], is(this.savedItemGroup.getId()));
    }

    @Test
    public void saveNewEnemyWithInvalidDataTest() {
        final Enemy enemyToSave = DomainFactory.manufactureValidEnemy(this.savedAssessment.getId(), this.savedItem.getTibIdentifier(), EnemyType.ITEM, this.savedItemGroup.getId(),
                EnemyType.ITEM_GROUP);
        enemyToSave.setObjectId1(null);
        enemyToSave.setObjectType1(null);
        enemyToSave.setObjectId2(null);
        enemyToSave.setObjectType2(null);

        try {
            this.enemyService.saveEnemy(null, enemyToSave);
            fail("exception should be thrown when trying to add a new enemy w/ invalid objectId1");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(4));
            assertThat(getConstraintViolation(e, "enemy.objectId1.required").size(), is(1));
            assertThat(getConstraintViolation(e, "enemy.objectType1.required").size(), is(1));
            assertThat(getConstraintViolation(e, "enemy.objectId2.required").size(), is(1));
            assertThat(getConstraintViolation(e, "enemy.objectType2.required").size(), is(1));
        }
    }

    @Test
    public void saveEnemyWithInvalidObjectIdsTest() {
        final Enemy enemyToSave = DomainFactory.manufactureValidEnemy(this.savedAssessment.getId(), this.savedItem.getTibIdentifier(), EnemyType.ITEM, this.savedItem.getTibIdentifier(),
                EnemyType.ITEM);

        try {
            this.enemyService.saveEnemy(null, enemyToSave);
            fail("exception should be thrown when trying to add a new enemy w/ invalid objectId1");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("enemy.cannot.be.enemy.of.self"));
        }

        enemyToSave.setObjectId1(this.savedItemGroup.getId());
        try {
            this.enemyService.saveEnemy(null, enemyToSave);
            fail("exception should be thrown when trying to add a new enemy w/ invalid objectId1");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("enemy.objectId1.invalid"));
        }

        enemyToSave.setObjectId1(this.savedItem2.getTibIdentifier());
        enemyToSave.setObjectId2(this.savedItemGroup.getId());
        try {
            this.enemyService.saveEnemy(null, enemyToSave);
            fail("exception should be thrown when trying to add a new enemy w/ invalid objectId1");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("enemy.objectId2.invalid"));
        }

        enemyToSave.setObjectType2(EnemyType.ITEM_GROUP);
        final Enemy savedEnemy = this.enemyService.saveEnemy(null, enemyToSave);
        assertThat(savedEnemy, is(notNullValue()));
    }

    @Test
    public void saveNewEnemyAssessmentAlreadyLockedTest() {
        this.savedAssessment.setLocked(true);
        this.assessmentRepository.save(this.savedAssessment);

        final Enemy enemyToSave = DomainFactory.manufactureValidEnemy(this.savedAssessment.getId(), this.savedItem.getTibIdentifier(), EnemyType.ITEM, this.savedItemGroup.getId(),
                EnemyType.ITEM_GROUP);
        try {
            this.enemyService.saveEnemy(null, enemyToSave);
            fail("exception should be thrown when trying to save a new enemy after assessment is locked");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("cannot.be.altered.assessment.locked"));
        }
    }

    @Test
    public void saveExistingEnemyTest() {
        final Enemy enemyToSave = DomainFactory.manufactureValidEnemy(this.savedAssessment.getId(), this.savedItem.getTibIdentifier(), EnemyType.ITEM, this.savedItemGroup.getId(),
                EnemyType.ITEM_GROUP);
        final Enemy savedEnemy = this.enemyService.saveEnemy(null, enemyToSave);

        savedEnemy.setObjectId2(this.savedItem2.getTibIdentifier());
        savedEnemy.setObjectType2(EnemyType.ITEM);
        final Enemy resavedEnemy = this.enemyService.saveEnemy(savedEnemy.getId(), savedEnemy);
        assertThat(resavedEnemy, is(notNullValue()));
        assertThat(resavedEnemy.getObjectId2(), is(equalTo(this.savedItem2.getTibIdentifier())));
    }

    @Test
    public void saveExistingEnemyPopulatesObjectIdSearchTest() {
        final Enemy enemyToSave = DomainFactory.manufactureValidEnemy(this.savedAssessment.getId(), this.savedItem.getTibIdentifier(), EnemyType.ITEM, this.savedItemGroup.getId(),
                EnemyType.ITEM_GROUP);
        final Enemy savedEnemy = this.enemyService.saveEnemy(null, enemyToSave);

        savedEnemy.setObjectId2(this.savedItem2.getTibIdentifier());
        savedEnemy.setObjectType2(EnemyType.ITEM);
        final Enemy resavedEnemy = this.enemyService.saveEnemy(savedEnemy.getId(), savedEnemy);
        assertThat(resavedEnemy, is(notNullValue()));
        assertThat(resavedEnemy.getObjectId2(), is(equalTo(this.savedItem2.getTibIdentifier())));

        assertThat(resavedEnemy.getObjectIdSearch().length, is(2));
        assertThat(resavedEnemy.getObjectIdSearch()[0], is(this.savedItem.getTibIdentifier()));
        assertThat(resavedEnemy.getObjectIdSearch()[1], is(this.savedItem2.getTibIdentifier()));
    }

    @Test
    public void saveDuplicateEnemyTest() {
        final Enemy enemyToSave = DomainFactory.manufactureValidEnemy(this.savedAssessment.getId(), this.savedItem.getTibIdentifier(), EnemyType.ITEM, this.savedItemGroup.getId(),
                EnemyType.ITEM_GROUP);
        final Enemy savedEnemy = this.enemyService.saveEnemy(null, enemyToSave);

        final Enemy duplicateEnemy = this.enemyService.getEnemy(savedEnemy.getId());
        duplicateEnemy.setId(null);

        try {
            this.enemyService.saveEnemy(null, duplicateEnemy);
            fail("should thow duplicate key exception");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("enemy.already.exists"));
        }
    }

    @Test
    public void saveExistingEnemyAssessmentAlreadyLockedTest() {
        final Enemy enemyToSave = DomainFactory.manufactureValidEnemy(this.savedAssessment.getId(), this.savedItem.getTibIdentifier(), EnemyType.ITEM, this.savedItemGroup.getId(),
                EnemyType.ITEM_GROUP);
        final Enemy savedEnemy = this.enemyService.saveEnemy(null, enemyToSave);

        this.savedAssessment.setLocked(true);
        this.assessmentRepository.save(this.savedAssessment);

        savedEnemy.setObjectId1("new-item");
        try {
            this.enemyService.saveEnemy(savedEnemy.getId(), savedEnemy);
            fail("exception should be thrown when trying to save an existing enemy after assessment is locked");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("cannot.be.altered.assessment.locked"));
        }
    }

    @Test
    public void deleteEnemyTest() {
        final Enemy enemyToSave = DomainFactory.manufactureValidEnemy(this.savedAssessment.getId(), this.savedItem.getTibIdentifier(), EnemyType.ITEM, this.savedItemGroup.getId(),
                EnemyType.ITEM_GROUP);
        final Enemy savedEnemy = this.enemyService.saveEnemy(null, enemyToSave);

        this.enemyService.removeEnemy(savedEnemy.getId());

        final Enemy retreivedEnemy = this.enemyService.getEnemy(savedEnemy.getId());
        assertThat(retreivedEnemy, is(nullValue()));
    }

    @Test
    public void deleteEnemyAssessmentAlreadyLockedTest() {
        final Enemy enemyToSave = DomainFactory.manufactureValidEnemy(this.savedAssessment.getId(), this.savedItem.getTibIdentifier(), EnemyType.ITEM, this.savedItemGroup.getId(),
                EnemyType.ITEM_GROUP);
        final Enemy savedEnemy = this.enemyService.saveEnemy(null, enemyToSave);

        this.savedAssessment.setLocked(true);
        this.assessmentRepository.save(this.savedAssessment);

        try {
            this.enemyService.removeEnemy(savedEnemy.getId());
            fail("exception should be thrown when trying to delete an enemy after assessment is locked");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("cannot.be.altered.assessment.locked"));
        }

        final Enemy retreivedEnemy = this.enemyService.getEnemy(savedEnemy.getId());
        assertThat(retreivedEnemy, is(notNullValue()));
    }

    @Test
    public void removeEnemyByAssessmentIdTest() {
        final Enemy enemyToSave1 = DomainFactory.manufactureValidEnemy(this.savedAssessment.getId(), this.savedItem.getTibIdentifier(), EnemyType.ITEM, this.savedItemGroup.getId(),
                EnemyType.ITEM_GROUP);
        final Enemy enemyToSave2 = DomainFactory.manufactureValidEnemy(this.savedAssessment.getId(), this.savedItem2.getTibIdentifier(), EnemyType.ITEM, this.savedItemGroup.getId(),
                EnemyType.ITEM_GROUP);
        final Enemy enemyToSave3 = DomainFactory.manufactureValidEnemy(this.savedAssessment.getId(), this.savedItem3.getTibIdentifier(), EnemyType.ITEM, this.savedItemGroup.getId(),
                EnemyType.ITEM_GROUP);
        final Enemy savedEnemy1 = this.enemyService.saveEnemy(null, enemyToSave1);
        final Enemy savedEnemy2 = this.enemyService.saveEnemy(null, enemyToSave2);
        final Enemy savedEnemy3 = this.enemyService.saveEnemy(null, enemyToSave3);

        this.enemyService.removeEnemiesByAssessmentId(this.savedAssessment.getId());

        final Enemy retrievedEnemy1 = this.enemyService.getEnemy(savedEnemy1.getId());
        assertThat(retrievedEnemy1, is(nullValue()));

        final Enemy retrievedEnemy2 = this.enemyService.getEnemy(savedEnemy2.getId());
        assertThat(retrievedEnemy2, is(nullValue()));

        final Enemy retrievedEnemy3 = this.enemyService.getEnemy(savedEnemy3.getId());
        assertThat(retrievedEnemy3, is(nullValue()));
    }

    @Test
    public void searchEnemies() {
        final Enemy enemyToSave1 = DomainFactory.manufactureValidEnemy(this.savedAssessment.getId(), this.savedItem.getTibIdentifier(), EnemyType.ITEM, this.savedItemGroup.getId(),
                EnemyType.ITEM_GROUP);
        final Enemy enemyToSave2 = DomainFactory.manufactureValidEnemy(this.savedAssessment.getId(), this.savedItem2.getTibIdentifier(), EnemyType.ITEM, this.savedItem3.getTibIdentifier(),
                EnemyType.ITEM);
        final Enemy savedEnemy1 = this.enemyService.saveEnemy(null, enemyToSave1);
        final Enemy savedEnemy2 = this.enemyService.saveEnemy(null, enemyToSave2);

        SearchResponse<Enemy> searchResponse = this.enemyService.searchEnemies(ImmutableMap.of("assessmentId", new String[] { "invalid-assessment-id" }));
        assertThat(searchResponse.getSearchResults().size(), is(0));

        searchResponse = this.enemyService.searchEnemies(ImmutableMap.of("assessmentId", new String[] { this.savedAssessment.getId() }));
        assertThat(searchResponse.getSearchResults().size(), is(2));

        searchResponse = this.enemyService.searchEnemies(ImmutableMap.of("objectId1", new String[] { savedEnemy1.getObjectId1() }));
        assertThat(searchResponse.getSearchResults().size(), is(1));

        searchResponse = this.enemyService.searchEnemies(ImmutableMap.of("objectId2", new String[] { savedEnemy2.getObjectId2() }));
        assertThat(searchResponse.getSearchResults().size(), is(1));
    }

    public void checkIsDuplicateEnemyReturnsFalseWhenNoDuplicates() {
        final Enemy enemyToSave1 = DomainFactory.manufactureValidEnemy(this.savedAssessment.getId(), this.savedItem.getTibIdentifier(), EnemyType.ITEM, this.savedItemGroup.getId(),
                EnemyType.ITEM_GROUP);
        this.enemyService.saveEnemy(null, enemyToSave1);

        final Enemy enemyToSave2 = DomainFactory.manufactureValidEnemy(this.savedAssessment.getId(), this.savedItem.getTibIdentifier(), EnemyType.ITEM, this.savedItemGroup.getId(),
                EnemyType.ITEM_GROUP);
        assertThat(this.enemyService.isDuplicateOfExistingEnemy(enemyToSave2), is(false));
    }

    public void checkIsDuplicateEnemyReturnsTrueForNewEnemyWhichIsDuplicate() {
        final Enemy enemyToSave1 = DomainFactory.manufactureValidEnemy(this.savedAssessment.getId(), this.savedItem.getTibIdentifier(), EnemyType.ITEM, this.savedItemGroup.getId(),
                EnemyType.ITEM_GROUP);
        this.enemyService.saveEnemy(null, enemyToSave1);

        final Enemy enemyToSave2 = DomainFactory.manufactureValidEnemy(this.savedAssessment.getId(), this.savedItem.getTibIdentifier(), EnemyType.ITEM, this.savedItemGroup.getId(),
                EnemyType.ITEM_GROUP);
        enemyToSave2.setObjectId1(enemyToSave1.getObjectId1());
        enemyToSave2.setObjectId2(enemyToSave1.getObjectId2());
        assertThat(this.enemyService.isDuplicateOfExistingEnemy(enemyToSave2), is(true));
    }

    public void checkIsDuplicateEnemyReturnsFalseWhenUpdating() {
        final Enemy enemyToSave1 = DomainFactory.manufactureValidEnemy(this.savedAssessment.getId(), this.savedItem.getTibIdentifier(), EnemyType.ITEM, this.savedItemGroup.getId(),
                EnemyType.ITEM_GROUP);
        final Enemy savedEnemy = this.enemyService.saveEnemy(null, enemyToSave1);

        assertThat(this.enemyService.isDuplicateOfExistingEnemy(savedEnemy), is(false));
    }

    public void checkIsDuplicateEnemyReturnsFalseWhenUpdatingToDuplicate() {
        final Enemy enemyToSave1 = DomainFactory.manufactureValidEnemy(this.savedAssessment.getId(), this.savedItem.getTibIdentifier(), EnemyType.ITEM, this.savedItemGroup.getId(),
                EnemyType.ITEM_GROUP);
        final Enemy savedEnemy1 = this.enemyService.saveEnemy(null, enemyToSave1);

        final Enemy enemyToSave2 = DomainFactory.manufactureValidEnemy(this.savedAssessment.getId(), this.savedItem.getTibIdentifier(), EnemyType.ITEM, this.savedItemGroup.getId(),
                EnemyType.ITEM_GROUP);
        final Enemy savedEnemy2 = this.enemyService.saveEnemy(null, enemyToSave2);

        savedEnemy2.setObjectId1(savedEnemy1.getObjectId1());
        savedEnemy2.setObjectId2(savedEnemy1.getObjectId2());
        assertThat(this.enemyService.isDuplicateOfExistingEnemy(savedEnemy2), is(true));
    }

    public void checkIsDuplicateEnemyReturnsTrueForNewEnemyWhichIsDuplicateInReverseOrder() {
        final Enemy enemyToSave1 = DomainFactory.manufactureValidEnemy(this.savedAssessment.getId(), this.savedItem.getTibIdentifier(), EnemyType.ITEM, this.savedItemGroup.getId(),
                EnemyType.ITEM_GROUP);
        this.enemyService.saveEnemy(null, enemyToSave1);

        final Enemy enemyToSave2 = DomainFactory.manufactureValidEnemy(this.savedAssessment.getId(), this.savedItem.getTibIdentifier(), EnemyType.ITEM, this.savedItemGroup.getId(),
                EnemyType.ITEM_GROUP);
        enemyToSave2.setObjectId2(enemyToSave1.getObjectId1());
        enemyToSave2.setObjectId1(enemyToSave1.getObjectId2());
        assertThat(this.enemyService.isDuplicateOfExistingEnemy(enemyToSave2), is(true));
    }
}
