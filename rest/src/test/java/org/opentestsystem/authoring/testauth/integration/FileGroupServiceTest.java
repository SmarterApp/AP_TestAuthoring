/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.integration;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.notNullValue;
import static org.hamcrest.CoreMatchers.nullValue;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.atLeast;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.opentestsystem.authoring.testauth.domain.PublishingStatus.PUBLISHED;

import java.nio.charset.Charset;
import java.util.List;

import javax.validation.ConstraintViolationException;

import org.apache.http.entity.ContentType;
import org.joda.time.DateTime;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;
import org.opentestsystem.authoring.testauth.domain.AdaptiveItemLocation;
import org.opentestsystem.authoring.testauth.domain.Approval;
import org.opentestsystem.authoring.testauth.domain.ApprovalStatus;
import org.opentestsystem.authoring.testauth.domain.Assessment;
import org.opentestsystem.authoring.testauth.domain.BlueprintElement;
import org.opentestsystem.authoring.testauth.domain.DomainFactory;
import org.opentestsystem.authoring.testauth.domain.FileGroup;
import org.opentestsystem.authoring.testauth.domain.GridFile;
import org.opentestsystem.authoring.testauth.domain.Item;
import org.opentestsystem.authoring.testauth.domain.ItemLocation;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionAlgorithm;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionAlgorithmType;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionPurpose;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionType;
import org.opentestsystem.authoring.testauth.domain.PsychometricRecord;
import org.opentestsystem.authoring.testauth.domain.Publication;
import org.opentestsystem.authoring.testauth.domain.PublishingRecord;
import org.opentestsystem.authoring.testauth.domain.PublishingStatus;
import org.opentestsystem.authoring.testauth.domain.Segment;
import org.opentestsystem.authoring.testauth.domain.SimulationRecord;
import org.opentestsystem.authoring.testauth.domain.Subject;
import org.opentestsystem.authoring.testauth.persistence.AssessmentRepository;
import org.opentestsystem.authoring.testauth.persistence.GridFsRepository;
import org.opentestsystem.authoring.testauth.persistence.PsychometricRecordRepository;
import org.opentestsystem.authoring.testauth.persistence.PublishingRecordRepository;
import org.opentestsystem.authoring.testauth.persistence.SimulationRecordRepository;
import org.opentestsystem.authoring.testauth.rest.AbstractRestEmbeddedMongoTest;
import org.opentestsystem.authoring.testauth.service.ApprovalService;
import org.opentestsystem.authoring.testauth.service.AssessmentService;
import org.opentestsystem.authoring.testauth.service.BlueprintElementService;
import org.opentestsystem.authoring.testauth.service.FileGroupService;
import org.opentestsystem.authoring.testauth.service.ItemSelectionAlgorithmService;
import org.opentestsystem.authoring.testauth.service.ItemService;
import org.opentestsystem.authoring.testauth.service.PublicationService;
import org.opentestsystem.authoring.testauth.service.PublishingRecordService;
import org.opentestsystem.authoring.testauth.service.SegmentService;
import org.opentestsystem.authoring.testauth.service.SubjectService;
import org.opentestsystem.authoring.testspecbank.client.TestSpecBankClientInterface;
import org.opentestsystem.authoring.testspecbank.client.domain.TestSpecBankClientObj;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.progman.client.ProgManClient;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.client.RestOperations;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.mongodb.DBObject;
import com.mongodb.gridfs.GridFSDBFile;
import com.mongodb.gridfs.GridFSFile;

public class FileGroupServiceTest extends AbstractRestEmbeddedMongoTest {

    @Autowired
    private AssessmentRepository assessmentRepository;

    @Autowired
    private PublishingRecordRepository publishingRecordRepository;

    @Autowired
    private SimulationRecordRepository simulationRecordRepository;

    @Autowired
    private PsychometricRecordRepository psychometricRecordRepository;

    @Autowired
    private GridFsRepository gridFsRepository;

    @Autowired
    private FileGroupService fileGroupService;

    @Autowired
    private SubjectService subjectService;

    @Autowired
    private PublicationService publicationService;

    @Autowired
    private AssessmentService assessmentService;

    @Autowired
    private PublishingRecordService publishingRecordService;

    @Autowired
    private ItemSelectionAlgorithmService itemSelectionAlgorithmService;

    @Autowired
    private BlueprintElementService blueprintElementService;

    @Autowired
    private SegmentService segmentService;

    @Autowired
    private ItemService itemService;

    @Autowired
    private ApprovalService approvalService;

    @Autowired
    private TestSpecBankClientInterface testSpecBankClient; // mocked client

    @Autowired
    private ProgManClient progManClient; // mocked client

    @Autowired
    private RestOperations restTemplate; // mocked rest template

    private Assessment savedAssessment;
    private Publication savedPublication;
    private Subject savedSubject;
    private PublishingRecord savedPublishingRecord;
    private SimulationRecord savedSimulationRecord;
    private PsychometricRecord savedPsychometricRecord;
    private ItemSelectionAlgorithm savedAlgorithm;
    private GridFSFile gridFsFile1;
    private GridFSFile gridFsFile2;
    private GridFSFile gridFsFile3;

    private static final String GRID_FILE1 = "test grid file values 1";
    private static final String GRID_FILE2 = "test grid file values 2";
    private static final String GRID_FILE3 = "test grid file values 3";

    @Before
    public void setupTestData() {
        this.savedSubject = this.subjectService.saveSubject(DomainFactory.manufactureValidSubject("abb"));
        this.savedPublication = this.publicationService.savePublication(DomainFactory.manufactureValidPublication(savedSubject.getTenantId(), ImmutableSet.of(savedSubject)));
        this.savedAssessment = this.assessmentRepository.save(DomainFactory.manufactureValidAssessment(this.savedSubject, this.savedPublication));
        this.savedPublishingRecord = this.publishingRecordRepository.save(DomainFactory.manufactureValidPublishingRecord(this.savedAssessment.getId()));

        final ItemSelectionAlgorithm algorithm = DomainFactory.manufactureValidItemSelectionAlgorithm(ItemSelectionPurpose.SCALAR, ItemSelectionType.BOOLEAN);
        algorithm.setItemSelectionAlgorithmType(ItemSelectionAlgorithmType.ADAPTIVE);
        this.savedAlgorithm = this.itemSelectionAlgorithmService.createItemSelectionAlgorithm(algorithm);

        this.savedSimulationRecord = this.simulationRecordRepository.save(DomainFactory.manufactureValidSimulationRecord(this.savedAssessment.getId()));
        this.savedPsychometricRecord = this.psychometricRecordRepository.save(DomainFactory.manufactureValidPsychometricRecord(this.savedPublishingRecord.getId()));

        final DBObject metadata = null;
        this.gridFsFile1 = this.gridFsRepository.save(GRID_FILE1.getBytes(Charset.forName("UTF-8")), "gridFsFile1", "plain/text", metadata);
        this.gridFsFile2 = this.gridFsRepository.save(GRID_FILE2.getBytes(Charset.forName("UTF-8")), "gridFsFile2", "plain/text", metadata);
        this.gridFsFile3 = this.gridFsRepository.save(GRID_FILE3.getBytes(Charset.forName("UTF-8")), "gridFsFile3", "plain/text", metadata);
    }

    @Test
    public void saveNewSimulationFileGroupTest() {
        final FileGroup fileGroupToSave = buildValidSimulationFileGroup("Simulation File Group");

        final FileGroup savedFileGroup = this.fileGroupService.saveFileGroup(fileGroupToSave);
        assertThat(savedFileGroup, is(notNullValue()));

        final FileGroup retrievedFileGroup = this.fileGroupService.getFileGroup(savedFileGroup.getId());
        assertThat(retrievedFileGroup, is(notNullValue()));
    }

    @Test
    public void saveNewPsychometricFileGroupTest() {
        final FileGroup fileGroupToSave = buildValidPsychometricFileGroup("Psychometric File Group", this.savedPsychometricRecord.getId());

        final FileGroup savedFileGroup = this.fileGroupService.saveFileGroup(fileGroupToSave);
        assertThat(savedFileGroup, is(notNullValue()));

        final FileGroup retrievedFileGroup = this.fileGroupService.getFileGroup(savedFileGroup.getId());
        assertThat(retrievedFileGroup, is(notNullValue()));
    }

    @Test
    public void saveNewFileGroupWithInvalidDataTest() {
        final FileGroup fileGroupToSave = buildValidFileGroup();
        fileGroupToSave.setName(""); // notBlank
        fileGroupToSave.setGridFiles(null); // notNull

        try {
            this.fileGroupService.saveFileGroup(fileGroupToSave);
            fail("exception should be thrown when trying to add a new fileGroup w/ missing data");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(2));
            assertThat(getConstraintViolation(e, "fileGroup.name.required").size(), is(1));
            assertThat(getConstraintViolation(e, "fileGroup.gridFile.required").size(), is(1));
        }
    }

    @Test
    public void saveExistingFileGroupTest() {
        final FileGroup fileGroupToSave = buildValidFileGroup();
        final FileGroup savedFileGroup = this.fileGroupService.saveFileGroup(fileGroupToSave);

        savedFileGroup.setName("New Group Name");
        final FileGroup resavedFileGroup = this.fileGroupService.saveFileGroup(savedFileGroup);
        assertThat(resavedFileGroup, is(notNullValue()));
        assertThat(resavedFileGroup.getName(), is(equalTo("New Group Name")));
    }

    @Test
    public void removeSimulationFileGroupTest() {
        final FileGroup fileGroupToSave = buildValidSimulationFileGroup("name1");
        final FileGroup savedFileGroup = this.fileGroupService.saveFileGroup(fileGroupToSave);
        savedFileGroup.setGridFiles(null);

        this.fileGroupService.removeFileGroup(savedFileGroup.getId());

        final FileGroup retrievedFileGroup = this.fileGroupService.getFileGroup(savedFileGroup.getId());
        assertThat(retrievedFileGroup, is(nullValue()));
    }

    @Test
    public void removePsychometricFileGroupTest() {
        saveGoodMinimalSegmentAndItemData();
        saveGoodMinimalBlueprintData();

        changePublishingStatusToPublished(this.savedPublishingRecord);

        final FileGroup fileGroupToSave = buildValidPsychometricFileGroup("name1", this.savedPsychometricRecord.getId());
        final FileGroup savedFileGroup = this.fileGroupService.saveFileGroup(fileGroupToSave);
        savedFileGroup.setGridFiles(null);

        this.fileGroupService.removeFileGroup(savedFileGroup.getId());

        final FileGroup retrievedFileGroup = this.fileGroupService.getFileGroup(savedFileGroup.getId());
        assertThat(retrievedFileGroup, is(nullValue()));
    }

    @Test
    public void removeSimulationFileGroupFailTest() {
        final FileGroup fileGroupToSave = buildValidSimulationFileGroup("name1");
        final FileGroup savedFileGroup = this.fileGroupService.saveFileGroup(fileGroupToSave);
        savedFileGroup.setGridFiles(null);

        saveGoodMinimalSegmentAndItemData();
        saveGoodMinimalBlueprintData();
        changePublishingStatusToPublished(this.savedPublishingRecord);

        try {
            this.fileGroupService.removeFileGroup(savedFileGroup.getId());
            fail("exception should be thrown when trying to remove a simulation record from an unpublished assessment");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("fileGroup.cannot.remove.simulation"));
        }
    }

    @Test
    public void removePsychometricFileGroupFailTest() {
        final FileGroup fileGroupToSave = buildValidPsychometricFileGroup("name1", this.savedPsychometricRecord.getId());
        final FileGroup savedFileGroup = this.fileGroupService.saveFileGroup(fileGroupToSave);
        savedFileGroup.setGridFiles(null);

        try {
            this.fileGroupService.removeFileGroup(savedFileGroup.getId());
            fail("exception should be thrown when trying to remove a psychometric record from a published assessment");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("fileGroup.cannot.remove.psychometric"));
        }
    }

    @Test
    public void searchFileGroupsBySimulationId() {
        final FileGroup fileGroupToSave1 = buildValidSimulationFileGroup("name1");
        final FileGroup fileGroupToSave2 = buildValidSimulationFileGroup("name2");
        final FileGroup savedFileGroup1 = this.fileGroupService.saveFileGroup(fileGroupToSave1);
        final FileGroup savedFileGroup2 = this.fileGroupService.saveFileGroup(fileGroupToSave2);

        SearchResponse<FileGroup> searchResponse = this.fileGroupService.searchFileGroups(ImmutableMap.of("simulationRecordId", new String[] { "invalid-simulation-record-id" }));
        assertThat(searchResponse.getSearchResults().size(), is(0));

        searchResponse = this.fileGroupService.searchFileGroups(ImmutableMap.of("simulationRecordId", new String[] { this.savedSimulationRecord.getId() }));
        assertThat(searchResponse.getSearchResults().size(), is(2));

        searchResponse = this.fileGroupService.searchFileGroups(ImmutableMap.of("name", new String[] { savedFileGroup1.getName() }));
        assertThat(searchResponse.getSearchResults().size(), is(1));

        searchResponse = this.fileGroupService.searchFileGroups(ImmutableMap.of("name", new String[] { savedFileGroup2.getName() }));
        assertThat(searchResponse.getSearchResults().size(), is(1));
    }

    @Test
    public void searchFileGroupsByPsychometricId() {
        final FileGroup fileGroupToSave1 = buildValidPsychometricFileGroup("name1", this.savedPsychometricRecord.getId());
        final FileGroup fileGroupToSave2 = buildValidPsychometricFileGroup("name2", this.savedPsychometricRecord.getId());
        final FileGroup savedFileGroup1 = this.fileGroupService.saveFileGroup(fileGroupToSave1);
        final FileGroup savedFileGroup2 = this.fileGroupService.saveFileGroup(fileGroupToSave2);

        SearchResponse<FileGroup> searchResponse = this.fileGroupService.searchFileGroups(ImmutableMap.of("psychometricRecordId", new String[] { "invalid-psychometric-record-id" }));
        assertThat(searchResponse.getSearchResults().size(), is(0));

        searchResponse = this.fileGroupService.searchFileGroups(ImmutableMap.of("psychometricRecordId", new String[] { this.savedPsychometricRecord.getId() }));
        assertThat(searchResponse.getSearchResults().size(), is(2));

        searchResponse = this.fileGroupService.searchFileGroups(ImmutableMap.of("name", new String[] { savedFileGroup1.getName() }));
        assertThat(searchResponse.getSearchResults().size(), is(1));

        searchResponse = this.fileGroupService.searchFileGroups(ImmutableMap.of("name", new String[] { savedFileGroup2.getName() }));
        assertThat(searchResponse.getSearchResults().size(), is(1));
    }

    @Test
    public void saveNewGridFsFileTest() {
        final GridFSFile savedGridFsFile = this.fileGroupService.saveGridFsFile("gridFsFile1", GRID_FILE1.getBytes(Charset.forName("UTF-8")), ContentType.APPLICATION_JSON.toString());
        assertThat(savedGridFsFile, is(notNullValue()));

        final GridFSDBFile retrievedGridFsFile = this.fileGroupService.getGridFsFile(savedGridFsFile.getId().toString());
        assertThat(retrievedGridFsFile, is(notNullValue()));
    }

    @Test
    public void deleteGridFsFileTest() {
        final GridFSFile savedGridFsFile = this.fileGroupService.saveGridFsFile("gridFsFile1", GRID_FILE1.getBytes(Charset.forName("UTF-8")), ContentType.APPLICATION_JSON.toString());
        assertThat(savedGridFsFile, is(notNullValue()));

        this.fileGroupService.deleteGridFsFile(savedGridFsFile.getId().toString());

        final GridFSDBFile retrievedGridFsFile = this.fileGroupService.getGridFsFile(savedGridFsFile.getId().toString());
        assertThat(retrievedGridFsFile, is(nullValue()));
    }

    private FileGroup buildValidFileGroup() {
        return buildValidSimulationFileGroup("name");
    }

    private FileGroup buildValidSimulationFileGroup(final String name) {
        final FileGroup fileGroup = new FileGroup();
        fileGroup.setId(null);
        fileGroup.setSimulationRecordId(this.savedSimulationRecord.getId());
        fileGroup.setName(name);
        fileGroup.setCreateDate(new DateTime());
        fileGroup.setGridFiles(getSampleGridFileList());
        return fileGroup;
    }

    private FileGroup buildValidPsychometricFileGroup(final String name, final String psychometricRecordId) {
        final FileGroup fileGroup = new FileGroup();
        fileGroup.setId(null);
        fileGroup.setPsychometricRecordId(psychometricRecordId);
        fileGroup.setName(name);
        fileGroup.setCreateDate(new DateTime());
        fileGroup.setGridFiles(getSampleGridFileList());
        return fileGroup;
    }

    private GridFile buildValidGridFile(final String filename, final String gridFsId) {
        final GridFile gridFile = new GridFile();
        gridFile.setFileName(filename);
        gridFile.setGridFsId(gridFsId);
        return gridFile;
    }

    private List<GridFile> getSampleGridFileList() {
        final List<GridFile> gridFileList = Lists.newArrayList();
        final GridFile gridFile1 = buildValidGridFile("filename1", this.gridFsFile1.getId().toString());
        final GridFile gridFile2 = buildValidGridFile("filename2", this.gridFsFile2.getId().toString());
        final GridFile gridFile3 = buildValidGridFile("filename3", this.gridFsFile3.getId().toString());

        gridFileList.add(gridFile1);
        gridFileList.add(gridFile2);
        gridFileList.add(gridFile3);
        return gridFileList;
    }

    private void saveGoodMinimalSegmentAndItemData() {
        final Segment savedSegment = this.segmentService.createSegment(DomainFactory.manufactureValidSegment(this.savedAssessment.getId(), this.savedAlgorithm, 1));
        buildItemsForSegment(12, savedSegment.getId());
    }

    private void saveGoodMinimalBlueprintData() {
        final List<Segment> segments = this.segmentService.findSegmentListByAssessmentId(this.savedAssessment.getId());
        this.segmentService.loadReferenceData(segments);
        final BlueprintElement bpe = DomainFactory.manufactureValidBlueprintElement(this.savedAssessment.getId(), segments);
        bpe.setGrade(this.savedAssessment.getGrade()[0]);
        bpe.setLevel("1");
        bpe.setStandardKey("CC-ELA-v1");
        bpe.setTextDescription("textDescription");
        bpe.setActive(true);
        this.blueprintElementService.saveBlueprintElement(null, bpe);
    }

    private void buildItemsForSegment(final int itemsToBuild, final String... segmentIdList) {
        for (int i = 0; i < itemsToBuild; i++) {
            final Item item = DomainFactory.manufactureValidItem(this.savedAssessment.getId());
            item.setId(null);
            final List<ItemLocation> itemLocationList = Lists.newArrayList();
            for (final String segmentId : segmentIdList) {
                itemLocationList.add(new AdaptiveItemLocation(segmentId, null, 0, 0));
            }
            item.setItemLocation(itemLocationList);
            this.itemService.saveItem(item);
        }
    }

    private PublishingRecord changePublishingStatusToPublished(final PublishingRecord publishingRecord) {
        when(this.progManClient.getTenantById(this.savedAssessment.getTenantId())).thenReturn(buildTenant("id1", "tenant1", "description1"));
        PublishingRecord updatedPublishingRecord = this.publishingRecordService.savePublishingRecord(publishingRecord, false);
        assertThat(publishingRecord.getPublishingStatus(), is(PublishingStatus.AWAITING_APPROVAL));

        when(this.testSpecBankClient.publishTestSpecification((TestSpecBankClientObj) Mockito.anyObject())).thenReturn(new TestSpecBankClientObj());
        getApprovedApprovals(updatedPublishingRecord.getId());

        // update from awaiting approval to published
        updatedPublishingRecord = this.publishingRecordService.savePublishingRecord(updatedPublishingRecord, false);

        verify(this.progManClient, atLeast(1)).getTenantById(this.savedAssessment.getTenantId());
        assertThat(updatedPublishingRecord, is(notNullValue()));

        if (updatedPublishingRecord.getPublishingStatus() != PUBLISHED) {
            updatedPublishingRecord.setPublishingStatus(PUBLISHED);
            this.publishingRecordRepository.save(updatedPublishingRecord);
        }
        assertThat(updatedPublishingRecord, is(notNullValue()));
        assertThat(updatedPublishingRecord.getPublishingStatus(), is(PUBLISHED));

        return updatedPublishingRecord;
    }

    @Test
    public void saveNewSimulationRecordTest() {
        final Assessment assessmentToSave = DomainFactory.manufactureValidAssessment(this.savedSubject, this.savedPublication);
        final Assessment aSavedAssessment = this.assessmentService.saveAssessment(assessmentToSave);

        final SimulationRecord simulationRecordToSave = DomainFactory.manufactureValidSimulationRecord(aSavedAssessment.getId());
        final SimulationRecord aSavedSimulationRecord = this.fileGroupService.saveSimulationRecord(simulationRecordToSave);

        assertThat(aSavedSimulationRecord, is(notNullValue()));
        final SimulationRecord retrievedSimulationRecord = this.fileGroupService.getSimulationRecord(this.savedSimulationRecord.getId());
        assertThat(retrievedSimulationRecord, is(notNullValue()));
    }

    @Test
    public void saveExistingSimulationRecordTest() {
        final SimulationRecord resavedSimulationRecord = this.fileGroupService.saveSimulationRecord(this.savedSimulationRecord);
        assertThat(resavedSimulationRecord, is(notNullValue()));
        final SimulationRecord retrievedSimulationRecord = this.fileGroupService.getSimulationRecord(this.savedSimulationRecord.getId());
        assertThat(retrievedSimulationRecord, is(notNullValue()));
    }

    @Test
    public void removeSimulationRecordTest() {
        assertThat(this.savedSimulationRecord, is(notNullValue()));

        this.fileGroupService.removeSimulationRecord(this.savedSimulationRecord.getId());

        final SimulationRecord retrievedSimulationRecord = this.fileGroupService.getSimulationRecord(this.savedSimulationRecord.getId());
        assertThat(retrievedSimulationRecord, is(nullValue()));
    }

    @Test
    public void saveNewPsychometricRecordTest() {
        saveGoodMinimalSegmentAndItemData();
        saveGoodMinimalBlueprintData();

        when(this.progManClient.getTenantById(this.savedAssessment.getTenantId())).thenReturn(buildTenant("id1", "tenant1", "description1"));
        final PublishingRecord publishingRecord = changePublishingStatusToPublished(this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(this.savedAssessment.getId()));

        final PsychometricRecord psychometricRecordToSave = DomainFactory.manufactureValidPsychometricRecord(publishingRecord.getId());
        final PsychometricRecord aSavedPsychometricRecord = this.fileGroupService.savePsychometricRecord(psychometricRecordToSave);

        assertThat(this.savedPsychometricRecord, is(notNullValue()));
        final PsychometricRecord retrievedPsychometricRecord = this.fileGroupService.getPsychometricRecord(aSavedPsychometricRecord.getId());
        assertThat(retrievedPsychometricRecord, is(notNullValue()));
    }

    @Test
    public void saveNewPsychometricRecordFailTest() {
        saveGoodMinimalSegmentAndItemData();
        saveGoodMinimalBlueprintData();

        when(this.progManClient.getTenantById(this.savedAssessment.getTenantId())).thenReturn(buildTenant("id1", "tenant1", "description1"));
        final PublishingRecord publishingRecord = this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(this.savedAssessment.getId());

        try {
            final PsychometricRecord psychometricRecordToSave = DomainFactory.manufactureValidPsychometricRecord(publishingRecord.getId());
            this.fileGroupService.savePsychometricRecord(psychometricRecordToSave);
            fail("exception should be thrown when trying to save a psychometric record to an unpublished assessment");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("assessment.must.be.published"));
        }
    }

    @Test
    public void saveExistingPsychometricRecordTest() {
        saveGoodMinimalSegmentAndItemData();
        saveGoodMinimalBlueprintData();

        when(this.progManClient.getTenantById(this.savedAssessment.getTenantId())).thenReturn(buildTenant("id1", "tenant1", "description1"));
        final PublishingRecord publishingRecord = changePublishingStatusToPublished(this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(this.savedAssessment.getId()));

        final PsychometricRecord psychometricRecordToSave = DomainFactory.manufactureValidPsychometricRecord(publishingRecord.getId());
        final PsychometricRecord aSavedPsychometricRecord = this.fileGroupService.savePsychometricRecord(psychometricRecordToSave);

        final PsychometricRecord resavedPsychometricRecord = this.fileGroupService.savePsychometricRecord(aSavedPsychometricRecord);
        assertThat(resavedPsychometricRecord, is(notNullValue()));
        final PsychometricRecord retrievedPsychometricRecord = this.fileGroupService.getPsychometricRecord(aSavedPsychometricRecord.getId());
        assertThat(retrievedPsychometricRecord, is(notNullValue()));
    }

    @Test
    public void removePsychometricRecordTest() {
        saveGoodMinimalSegmentAndItemData();
        saveGoodMinimalBlueprintData();

        when(this.progManClient.getTenantById(this.savedAssessment.getTenantId())).thenReturn(buildTenant("id1", "tenant1", "description1"));
        final PublishingRecord publishingRecord = changePublishingStatusToPublished(this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(this.savedAssessment.getId()));

        final PsychometricRecord psychometricRecordToSave = DomainFactory.manufactureValidPsychometricRecord(publishingRecord.getId());
        final PsychometricRecord aSavedPsychometricRecord = this.fileGroupService.savePsychometricRecord(psychometricRecordToSave);
        assertThat(this.savedPsychometricRecord, is(notNullValue()));

        this.fileGroupService.removePsychometricRecord(aSavedPsychometricRecord.getId());

        final PsychometricRecord retrievedPsychometricRecord = this.fileGroupService.getPsychometricRecord(aSavedPsychometricRecord.getId());
        assertThat(retrievedPsychometricRecord, is(nullValue()));
    }

    @Test
    public void searchPsychometricRecordFileGroupsByVersionTest() {
        final FileGroup fileGroupToSave1 = buildValidPsychometricFileGroup("name1", this.savedPsychometricRecord.getId());
        final FileGroup fileGroupToSave2 = buildValidPsychometricFileGroup("name2", this.savedPsychometricRecord.getId());
        this.fileGroupService.saveFileGroup(fileGroupToSave1);
        this.fileGroupService.saveFileGroup(fileGroupToSave2);

        SearchResponse<FileGroup> searchResponse = this.fileGroupService.searchPsychometricRecordFileGroupsByVersion(ImmutableMap.of("assessmentId", new String[] { this.savedAssessment.getId() },
                "version", new String[] { "1.0" }));
        assertThat(searchResponse.getSearchResults().size(), is(2));

        searchResponse = this.fileGroupService.searchPsychometricRecordFileGroupsByVersion(ImmutableMap.of("assessmentId", new String[] { this.savedAssessment.getId() }, "version",
                new String[] { "1.2" }));
        assertThat(searchResponse.getSearchResults().size(), is(0));
    }

    @Test
    public void getPsychometricRecordVersionsTest() {
        saveGoodMinimalSegmentAndItemData();
        saveGoodMinimalBlueprintData();

        when(this.progManClient.getTenantById(this.savedAssessment.getTenantId())).thenReturn(buildTenant("id1", "tenant1", "description1"));
        PublishingRecord publishingRecord = changePublishingStatusToPublished(this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(this.savedAssessment.getId()));

        // process next version
        this.publishingRecordService.savePublishingRecord(publishingRecord, false);
        publishingRecord = changePublishingStatusToPublished(publishingRecord);

        // process next version
        this.publishingRecordService.savePublishingRecord(publishingRecord, false);
        changePublishingStatusToPublished(publishingRecord);

        final List<String> versionList = this.fileGroupService.getPsychometricRecordVersions(this.savedAssessment.getId());
        assertThat(versionList, is(notNullValue()));
        assertThat(versionList.size(), is(3));
        assertThat(versionList.get(0), is("1.0"));
        assertThat(versionList.get(2), is("1.2"));
    }

    private List<Approval> getApprovedApprovals(final String publishingRecordId) {
        final List<Approval> initialApprovals = this.approvalService.createInitialApprovals(publishingRecordId);

        for (final Approval approval : initialApprovals) {
            approval.setStatus(ApprovalStatus.APPROVED);
            approval.setMessage("approval message");
            this.approvalService.updateApproval(approval);
        }
        return initialApprovals;
    }

}
