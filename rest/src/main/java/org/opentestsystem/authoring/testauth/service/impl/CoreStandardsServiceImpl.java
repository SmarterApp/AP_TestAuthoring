/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.service.impl;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.authoring.testauth.domain.CoreStandardPublicationResponse;
import org.opentestsystem.authoring.testauth.domain.CoreStandardPublicationSockResponse;
import org.opentestsystem.authoring.testauth.service.CoreStandardsService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.client.RestOperations;

@Service
public class CoreStandardsServiceImpl implements CoreStandardsService {
    private static final Logger LOGGER = LoggerFactory.getLogger(CoreStandardsServiceImpl.class);

    @Autowired
    private RestOperations restTemplate;

    @Value("${testauth.core.standards.url}")
    private String baseCoreStandardsUri;

    @Override
    public String getCoreStandardsData(final String hierarchy, final String publisher, final String subject, final String grade) {
        if (LOGGER.isDebugEnabled()) {
            final StringBuilder sb = new StringBuilder("Finding coreStandards " + hierarchy);
            if (StringUtils.isNotEmpty(publisher)) {
                sb.append(" for publisher: " + publisher);
            }
            if (StringUtils.isNotEmpty(subject)) {
                sb.append(", subject: " + subject);
            }
            if (StringUtils.isNotEmpty(grade)) {
                sb.append(", grade: " + grade);
            }
            LOGGER.debug(sb.toString());
        }
        final StringBuilder url = new StringBuilder(this.baseCoreStandardsUri);
        url.append(hierarchy);
        if (StringUtils.isNotEmpty(publisher)) {
            url.append("?publisher=" + publisher);
        }
        if (StringUtils.isNotEmpty(subject)) {
            url.append(StringUtils.isNotEmpty(publisher) ? "&" : "?");
            url.append("subject=" + subject);
        }
        if (StringUtils.isNotEmpty(grade)) {
            url.append(StringUtils.isNotEmpty(publisher) || StringUtils.isNotEmpty(subject) ? "&" : "?");
            url.append("grade=" + grade);
        }
        return this.restTemplate.getForObject(url.toString(), String.class);
    }

    @Override
    public CoreStandardPublicationResponse getCoreStandardsForPublication(final String publicationKey) {
        return this.restTemplate.getForObject(this.baseCoreStandardsUri + "publication/" + publicationKey + "/standard", CoreStandardPublicationResponse.class);
    }

    @Override
    public CoreStandardPublicationResponse getCoreStandardsGradeResponse(@PathVariable final String publicationKey) {
        return this.restTemplate.getForObject(this.baseCoreStandardsUri + "publication/" + publicationKey + "/grade", CoreStandardPublicationResponse.class);
    }

    @Override
    public CoreStandardPublicationResponse getCoreStandardsCategoriesForPublication(final String publicationKey) {
        return this.restTemplate.getForObject(this.baseCoreStandardsUri + "publication/" + publicationKey + "/category", CoreStandardPublicationResponse.class);
    }

    @Override
    public CoreStandardPublicationSockResponse getCoreStandardsSocksForPublication(final String publicationKey) {
        return this.restTemplate.getForObject(this.baseCoreStandardsUri + "publication/" + publicationKey + "/sock", CoreStandardPublicationSockResponse.class);
    }
}
