/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.integration;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.instanceOf;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.not;
import static org.hamcrest.CoreMatchers.notNullValue;
import static org.hamcrest.CoreMatchers.nullValue;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.when;
import static org.opentestsystem.authoring.testauth.domain.PublishingStatus.AWAITING_APPROVAL;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.validation.ConstraintViolationException;

import org.joda.time.DateTime;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;
import org.opentestsystem.authoring.testauth.domain.AdaptiveItemLocation;
import org.opentestsystem.authoring.testauth.domain.Approval;
import org.opentestsystem.authoring.testauth.domain.ApprovalStatus;
import org.opentestsystem.authoring.testauth.domain.Assessment;
import org.opentestsystem.authoring.testauth.domain.BlueprintElement;
import org.opentestsystem.authoring.testauth.domain.DomainFactory;
import org.opentestsystem.authoring.testauth.domain.Item;
import org.opentestsystem.authoring.testauth.domain.ItemLocation;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionAlgorithm;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionAlgorithmType;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionPurpose;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionType;
import org.opentestsystem.authoring.testauth.domain.Permissions;
import org.opentestsystem.authoring.testauth.domain.Publication;
import org.opentestsystem.authoring.testauth.domain.PublishingRecord;
import org.opentestsystem.authoring.testauth.domain.Segment;
import org.opentestsystem.authoring.testauth.domain.Subject;
import org.opentestsystem.authoring.testauth.persistence.ApprovalRepository;
import org.opentestsystem.authoring.testauth.persistence.AssessmentRepository;
import org.opentestsystem.authoring.testauth.persistence.PublishingRecordRepository;
import org.opentestsystem.authoring.testauth.rest.AbstractRestEmbeddedMongoTest;
import org.opentestsystem.authoring.testauth.service.ApprovalService;
import org.opentestsystem.authoring.testauth.service.BlueprintElementService;
import org.opentestsystem.authoring.testauth.service.ItemSelectionAlgorithmService;
import org.opentestsystem.authoring.testauth.service.ItemService;
import org.opentestsystem.authoring.testauth.service.PublicationService;
import org.opentestsystem.authoring.testauth.service.PublishingRecordService;
import org.opentestsystem.authoring.testauth.service.SegmentService;
import org.opentestsystem.authoring.testauth.service.SubjectService;
import org.opentestsystem.shared.progman.client.ProgManClient;
import org.opentestsystem.shared.progman.client.domain.Tenant;
import org.opentestsystem.shared.progman.client.domain.TenantSubscription;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.opentestsystem.shared.security.domain.SbacPermission;
import org.opentestsystem.shared.security.domain.SbacRole;
import org.opentestsystem.shared.security.domain.SbacUser;
import org.opentestsystem.shared.security.domain.TenantContainer;
import org.opentestsystem.shared.security.service.TenancyService;
import org.opentestsystem.shared.security.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.google.common.collect.Multimap;
import com.mongodb.DBObject;

public class ApprovalServiceTest extends AbstractRestEmbeddedMongoTest {

    @Autowired
    private ApprovalService approvalService;

    @Autowired
    private SubjectService subjectService;

    @Autowired
    private PublicationService publicationService;

    @Autowired
    private PublishingRecordService publishingRecordService;

    @Autowired
    private BlueprintElementService blueprintElementService;

    @Autowired
    private ItemSelectionAlgorithmService itemSelectionAlgorithmService;

    @Autowired
    private SegmentService segmentService;

    @Autowired
    private ItemService itemService;

    @Autowired
    private AssessmentRepository assessmentRepository;

    @Autowired
    private PublishingRecordRepository publishingRecordRepository;

    @Autowired
    private ApprovalRepository approvalRepository;

    @Autowired
    private UserService userService;

    @Autowired
    private TenancyService tenancyService;

    @Autowired
    private ProgManClient progManClient;

    private Assessment savedAssessment;
    private ItemSelectionAlgorithm savedAlgorithm;
    private PublishingRecord savedPublishingRecord;
    private final Tenant tenant1 = buildTenant("id1", "tenant1", "description1");

    private TenantContainer tenantContainer;

    private static final String COMPONENT_NAME = "TestAuthoring";

    @Before
    public void setupTestData() {
        final Subject savedSubject = this.subjectService.saveSubject(DomainFactory.manufactureValidSubject("abb"));
        final Publication savedPublication = this.publicationService.savePublication(DomainFactory.manufactureValidPublication(savedSubject.getTenantId(), ImmutableSet.of(savedSubject)));
        this.savedAssessment = this.assessmentRepository.save(DomainFactory.manufactureValidAssessment(savedSubject, savedPublication));

        final ItemSelectionAlgorithm algorithm = DomainFactory.manufactureValidItemSelectionAlgorithm(ItemSelectionPurpose.SCALAR, ItemSelectionType.BOOLEAN);
        algorithm.setItemSelectionAlgorithmType(ItemSelectionAlgorithmType.ADAPTIVE);
        this.savedAlgorithm = this.itemSelectionAlgorithmService.createItemSelectionAlgorithm(algorithm);

        this.savedPublishingRecord = this.publishingRecordRepository.save(DomainFactory.manufactureValidPublishingRecord(this.savedAssessment.getId()));

        final Tenant myTenant = PODAM_FACTORY.manufacturePojo(Tenant.class);
        final TenantSubscription tenantSubscription = PODAM_FACTORY.manufacturePojo(TenantSubscription.class);
        tenantSubscription.getComponent().setName(COMPONENT_NAME);
        tenantSubscription.setEffectiveDate(new DateTime().minusWeeks(1));
        tenantSubscription.setExpirationDate(null);
        tenantSubscription.setInGoodStanding(true);
        myTenant.setTenantSubscriptions(ImmutableList.of(tenantSubscription));
        this.tenantContainer = PODAM_FACTORY.manufacturePojo(TenantContainer.class);
        this.tenantContainer.addAllTenants(ImmutableList.of(myTenant));

        final SbacPermission permission = new SbacPermission();
        permission.setComponentName(COMPONENT_NAME);
        permission.setName("Content Lead");
        final Multimap<String, SbacPermission> permissions = ArrayListMultimap.create();
        final String roleName = "Test Content Lead";
        permissions.put(roleName, permission);

        final Map<String, Collection<SbacPermission>> permissionsMap = new HashMap<String, Collection<SbacPermission>>();
        final Collection<SbacPermission> permissionCollection = new ArrayList<SbacPermission>();
        permissionCollection.add(permission);
        permissionsMap.put(roleName, permissionCollection);
        permissions.put(roleName, permission);

        final SbacRole role = new SbacRole();
        role.setRoleName(roleName);
        role.setRoleEntityLevel(myTenant.getType().name());
        role.addEntityValue(myTenant.getType(), myTenant.getId(), myTenant.getName());
        role.setPermissions(permissionCollection);
        final Multimap<String, SbacRole> roles = ArrayListMultimap.create();
        roles.put(role.getRoleName(), role);
        final SbacUser user = new SbacUser(roles, null);

        when(this.progManClient.getTenantById(Mockito.anyString())).thenReturn(this.tenant1);
        when(this.userService.getCurrentUser()).thenReturn(user);
    }

    @Test
    public void saveNewApprovalPersistsJodaDatesAsJavaUtilDateTest() {
        final Approval approvalToSave = DomainFactory.manufactureValidApproval(this.savedAssessment.getId(), this.savedPublishingRecord.getId());
        final Approval savedApproval = this.approvalRepository.save(approvalToSave);
        assertThat(savedApproval, is(notNullValue()));
        final Approval retrievedApproval = this.approvalService.getApproval(savedApproval.getId());
        assertThat(retrievedApproval, is(notNullValue()));

        final DBObject foundObject = this.mongoTemplate.getDb().getCollection("approval").findOne(retrievedApproval.getId());
        final Object lastUpdatedDate = foundObject.get("lastUpdatedDate");
        assertThat(lastUpdatedDate, is(instanceOf(java.util.Date.class)));
    }

    @Test
    public void saveApprovalWithMissingFieldsTest() {
        final Approval approvalToSave = DomainFactory.manufactureValidApproval(this.savedAssessment.getId(), this.savedPublishingRecord.getId());
        approvalToSave.setId(null);
        approvalToSave.setAssessmentId(""); // NotBlank
        approvalToSave.setPublishingRecordId(""); // NotBlank
        approvalToSave.setStatus(null); // NotNull
        approvalToSave.setPermission(null); // NotNull
        approvalToSave.setUsername(null); // NotNull

        try {
            this.approvalRepository.save(approvalToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(5));
            assertThat(getConstraintViolation(e, "assessmentId.required").size(), is(1));
            assertThat(getConstraintViolation(e, "approval.publishingRecord.required").size(), is(1));
            assertThat(getConstraintViolation(e, "approval.status.required").size(), is(1));
            assertThat(getConstraintViolation(e, "approval.permission.required").size(), is(1));
            assertThat(getConstraintViolation(e, "approval.username.required").size(), is(1));
        }
    }

    @Test
    public void removeApprovalByAssessmentIdTest() {
        final Approval approvalToSave = DomainFactory.manufactureValidApproval(this.savedAssessment.getId(), this.savedPublishingRecord.getId());
        final Approval savedApproval = this.approvalRepository.save(approvalToSave);
        assertThat(savedApproval, is(notNullValue()));
        final Approval retrievedApproval = this.approvalService.getApproval(savedApproval.getId());
        assertThat(retrievedApproval, is(notNullValue()));

        this.approvalService.removeByAssessmentId(this.savedAssessment.getId());
        final Approval reRetrievedApproval = this.approvalService.getApproval(savedApproval.getId());
        assertThat(reRetrievedApproval, is(nullValue()));
    }

    @Test
    public void getApproval() {
        final Approval approvalToSave = DomainFactory.manufactureValidApproval(this.savedAssessment.getId(), this.savedPublishingRecord.getId());
        final Approval savedApproval = this.approvalRepository.save(approvalToSave);
        assertThat(savedApproval, is(not(nullValue())));

        assertThat(this.approvalService.getApproval(savedApproval.getId()), is(not(nullValue())));
        assertThat(this.approvalService.getApproval("invalid-id"), is(nullValue()));
    }

    @Test
    public void searchApprovals() {
        final Approval approvalToSave = DomainFactory.manufactureValidApproval(this.savedAssessment.getId(), this.savedPublishingRecord.getId());
        final Approval savedApproval = this.approvalRepository.save(approvalToSave);
        assertThat(savedApproval, is(not(nullValue())));

        final Approval approvalToSave2 = DomainFactory.manufactureValidApproval(this.savedAssessment.getId(), this.savedPublishingRecord.getId());
        approvalToSave2.setPublishingRecordId("id_12345");
        final Approval savedApproval2 = this.approvalRepository.save(approvalToSave2);
        assertThat(savedApproval2, is(not(nullValue())));

        final Map<String, String[]> params = ImmutableMap.of("publishingRecordId", new String[] {savedApproval.getPublishingRecordId() });
        final SearchResponse<Approval> searchResponse = this.approvalService.searchApprovals(params);
        assertThat(searchResponse.getReturnCount(), is(1));
        assertThat(searchResponse.getSearchResults().size(), is(1));
    }

    @Test
    public void updateApprovalTest() {
        final Approval approvalToSave = DomainFactory.manufactureValidApproval(this.savedAssessment.getId(), this.savedPublishingRecord.getId());
        final Approval savedApproval = this.approvalRepository.save(approvalToSave);
        assertThat(savedApproval, is(notNullValue()));

        saveGoodMinimalSegmentAndItemData();
        saveGoodMinimalBlueprintData();
        when(this.progManClient.getTenantById(this.savedAssessment.getTenantId())).thenReturn(buildTenant("id1", "tenant1", "description1"));

        final PublishingRecord updatedPublishingRecord = this.publishingRecordService.savePublishingRecord(this.savedPublishingRecord, false);
        assertThat(updatedPublishingRecord, is(notNullValue()));
        assertThat(updatedPublishingRecord.getPublishingStatus(), is(AWAITING_APPROVAL));

        final Approval retrievedApproval = this.approvalService.getApproval(savedApproval.getId());
        assertThat(retrievedApproval, is(notNullValue()));
        retrievedApproval.setMessage("New Message");
        final Approval resavedApproval = this.approvalService.updateApproval(retrievedApproval);
        assertThat(resavedApproval, is(notNullValue()));
        assertThat(resavedApproval.getMessage(), is(equalTo("New Message")));
    }

    @Test
    public void createInitialApprovalsTest() {
        this.approvalService.createInitialApprovals(this.savedPublishingRecord.getId());

        final Map<String, String[]> params = ImmutableMap.of("publishingRecordId", new String[] {this.savedPublishingRecord.getId() });
        final SearchResponse<Approval> searchResponse = this.approvalService.searchApprovals(params);

        assertThat(searchResponse.getReturnCount(), is(3));
        assertThat(searchResponse.getSearchResults().size(), is(3));
        assertThat(searchResponse.getSearchResults().get(0).getPermission(), is(Permissions.CONTENT_LEAD.toSpringRoleName()));
        assertThat(searchResponse.getSearchResults().get(2).getLevel(), is(2));
    }

    @Test
    public void retrieveLatestApprovalsTest() {
        final Approval approvalToSave = DomainFactory.manufactureValidApproval(this.savedAssessment.getId(), this.savedPublishingRecord.getId());
        approvalToSave.setPermission(Permissions.CONTENT_LEAD.toSpringRoleName());
        approvalToSave.setUsername("Content Lead");
        approvalToSave.setStatus(ApprovalStatus.APPROVED);
        final Approval savedApproval = this.approvalRepository.save(approvalToSave);
        assertThat(savedApproval, is(not(nullValue())));

        final Approval approvalToSave2 = DomainFactory.manufactureValidApproval(this.savedAssessment.getId(), this.savedPublishingRecord.getId());
        approvalToSave2.setPermission(Permissions.PSYCHOMETRIC_LEAD.toSpringRoleName());
        approvalToSave2.setUsername("Psychometric Lead");
        approvalToSave2.setStatus(ApprovalStatus.APPROVED);
        final Approval savedApproval2 = this.approvalRepository.save(approvalToSave2);
        assertThat(savedApproval2, is(not(nullValue())));

        final Approval approvalToSave3 = DomainFactory.manufactureValidApproval(this.savedAssessment.getId(), this.savedPublishingRecord.getId());
        approvalToSave3.setPermission(Permissions.QA_LEAD.toSpringRoleName());
        approvalToSave3.setUsername("QA Lead");
        approvalToSave3.setStatus(ApprovalStatus.REJECTED);
        final Approval savedApproval3 = this.approvalRepository.save(approvalToSave3);
        assertThat(savedApproval3, is(not(nullValue())));

        final Approval approvalToSave4 = DomainFactory.manufactureValidApproval(this.savedAssessment.getId(), this.savedPublishingRecord.getId());
        approvalToSave4.setPermission(Permissions.CONTENT_LEAD.toSpringRoleName());
        approvalToSave4.setUsername("Content Lead");
        approvalToSave4.setStatus(ApprovalStatus.PENDING);
        final Approval savedApproval4 = this.approvalRepository.save(approvalToSave4);
        assertThat(savedApproval4, is(not(nullValue())));

        final Approval approvalToSave5 = DomainFactory.manufactureValidApproval(this.savedAssessment.getId(), this.savedPublishingRecord.getId());
        approvalToSave5.setPermission(Permissions.PSYCHOMETRIC_LEAD.toSpringRoleName());
        approvalToSave5.setUsername("Psychometric Lead");
        approvalToSave5.setStatus(ApprovalStatus.PENDING);
        final Approval savedApproval5 = this.approvalRepository.save(approvalToSave5);
        assertThat(savedApproval5, is(not(nullValue())));

        final Approval approvalToSave6 = DomainFactory.manufactureValidApproval(this.savedAssessment.getId(), this.savedPublishingRecord.getId());
        approvalToSave6.setPermission(Permissions.QA_LEAD.toSpringRoleName());
        approvalToSave6.setUsername("QA Lead");
        approvalToSave6.setStatus(ApprovalStatus.PENDING);
        final Approval savedApproval6 = this.approvalRepository.save(approvalToSave6);
        assertThat(savedApproval6, is(not(nullValue())));

        final List<Approval> latestApprovals = this.approvalService.retrieveLatestApprovals(this.savedPublishingRecord.getId());

        assertThat(latestApprovals.size(), is(3));
        assertThat(latestApprovals.get(0).getStatus(), is(ApprovalStatus.PENDING));
        assertThat(latestApprovals.get(1).getStatus(), is(ApprovalStatus.PENDING));
        assertThat(latestApprovals.get(2).getStatus(), is(ApprovalStatus.PENDING));
    }

    @Test
    public void isAdminTest() {
        this.approvalService.createInitialApprovals(this.savedPublishingRecord.getId());
        assertThat(this.approvalService.isAdminUser(), is(true));
    }

    @Test
    public void canPublishToSpecBankTest() {
        this.approvalService.createInitialApprovals(this.savedPublishingRecord.getId());

        final Map<String, String[]> params = ImmutableMap.of("publishingRecordId", new String[] {this.savedPublishingRecord.getId() });
        final SearchResponse<Approval> searchResponse = this.approvalService.searchApprovals(params);
        final List<Approval> approvalList = searchResponse.getSearchResults();

        for (final Approval approval : approvalList) {
            approval.setStatus(ApprovalStatus.APPROVED);
            this.approvalRepository.save(approval);
        }

        assertThat(this.approvalService.canPublishToSpecBank(this.savedPublishingRecord.getId()), is(true));
    }

    @Test
    public void cannotPublishToSpecBankTest() {
        this.approvalService.createInitialApprovals(this.savedPublishingRecord.getId());
        assertThat(this.approvalService.canPublishToSpecBank(this.savedPublishingRecord.getId()), is(false));
    }

    private void saveGoodMinimalBlueprintData() {
        final List<Segment> segments = segmentService.findSegmentListByAssessmentId(this.savedAssessment.getId());
        segmentService.loadReferenceData(segments);
        final BlueprintElement bpe = DomainFactory.manufactureValidBlueprintElement(this.savedAssessment.getId(), segments);
        bpe.setGrade(this.savedAssessment.getGrade()[0]);
        bpe.setLevel("1");
        bpe.setStandardKey("CC-ELA-v1");
        bpe.setTextDescription("textDescription");
        bpe.setActive(true);
        this.blueprintElementService.saveBlueprintElement(null, bpe);
    }

    private void saveGoodMinimalSegmentAndItemData() {
        final Segment savedSegment = this.segmentService.createSegment(DomainFactory.manufactureValidSegment(this.savedAssessment.getId(), this.savedAlgorithm, 1));
        buildItemsForSegment(12, savedSegment.getId());
    }

    private void buildItemsForSegment(final int itemsToBuild, final String... segmentIdList) {
        for (int i = 0; i < itemsToBuild; i++) {
            final Item item = DomainFactory.manufactureValidItem(this.savedAssessment.getId());
            item.setId(null);
            final List<ItemLocation> itemLocationList = Lists.newArrayList();
            for (final String segmentId : segmentIdList) {
                itemLocationList.add(new AdaptiveItemLocation(segmentId, null, 0, 0));
            }
            item.setItemLocation(itemLocationList);
            this.itemService.saveItem(item);
        }
    }

}
