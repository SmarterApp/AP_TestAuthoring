/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.integration;

import static org.hamcrest.CoreMatchers.hasItem;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.not;
import static org.hamcrest.CoreMatchers.notNullValue;
import static org.hamcrest.CoreMatchers.startsWith;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.atLeast;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.opentestsystem.authoring.testauth.domain.PublishingStatus.AWAITING_APPROVAL;
import static org.opentestsystem.authoring.testauth.domain.PublishingStatus.INPROGRESS;
import static org.opentestsystem.authoring.testauth.domain.PublishingStatus.PUBLISHED;
import static org.opentestsystem.authoring.testauth.domain.PublishingStatus.PUBLISHING;
import static org.opentestsystem.authoring.testauth.domain.PublishingStatus.REJECT;

import java.io.IOException;
import java.io.StringWriter;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import javax.validation.ConstraintViolationException;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;

import org.eclipse.persistence.jaxb.JAXBContextProperties;
import org.joda.time.DateTime;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;
import org.mockito.Mockito;
import org.opentestsystem.authoring.testauth.config.TestAuthUtil;
import org.opentestsystem.authoring.testauth.domain.AdaptiveItemLocation;
import org.opentestsystem.authoring.testauth.domain.Approval;
import org.opentestsystem.authoring.testauth.domain.ApprovalStatus;
import org.opentestsystem.authoring.testauth.domain.Assessment;
import org.opentestsystem.authoring.testauth.domain.BlueprintElement;
import org.opentestsystem.authoring.testauth.domain.BlueprintReferenceType;
import org.opentestsystem.authoring.testauth.domain.ComputationRule;
import org.opentestsystem.authoring.testauth.domain.ComputationRuleMultiplicityType;
import org.opentestsystem.authoring.testauth.domain.ComputationRuleParameter;
import org.opentestsystem.authoring.testauth.domain.ComputationRuleType;
import org.opentestsystem.authoring.testauth.domain.ConversionTableType;
import org.opentestsystem.authoring.testauth.domain.DomainFactory;
import org.opentestsystem.authoring.testauth.domain.FixedFormItemLocation;
import org.opentestsystem.authoring.testauth.domain.Form;
import org.opentestsystem.authoring.testauth.domain.FormPartition;
import org.opentestsystem.authoring.testauth.domain.Item;
import org.opentestsystem.authoring.testauth.domain.ItemLocation;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionAlgorithm;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionAlgorithmType;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionPurpose;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionType;
import org.opentestsystem.authoring.testauth.domain.PerformanceLevel;
import org.opentestsystem.authoring.testauth.domain.Publication;
import org.opentestsystem.authoring.testauth.domain.PublishingRecord;
import org.opentestsystem.authoring.testauth.domain.ReportingMeasure;
import org.opentestsystem.authoring.testauth.domain.ScoringRule;
import org.opentestsystem.authoring.testauth.domain.ScoringRuleParameter;
import org.opentestsystem.authoring.testauth.domain.Segment;
import org.opentestsystem.authoring.testauth.domain.Subject;
import org.opentestsystem.authoring.testauth.persistence.PublishingRecordRepository;
import org.opentestsystem.authoring.testauth.publish.domain.Administration;
import org.opentestsystem.authoring.testauth.publish.domain.AdministrationSegment;
import org.opentestsystem.authoring.testauth.publish.domain.Identifier;
import org.opentestsystem.authoring.testauth.publish.domain.ItemPool;
import org.opentestsystem.authoring.testauth.publish.domain.PoolProperty;
import org.opentestsystem.authoring.testauth.publish.domain.Property;
import org.opentestsystem.authoring.testauth.publish.domain.Purpose;
import org.opentestsystem.authoring.testauth.publish.domain.Registration;
import org.opentestsystem.authoring.testauth.publish.domain.RegistrationForm;
import org.opentestsystem.authoring.testauth.publish.domain.RegistrationSegment;
import org.opentestsystem.authoring.testauth.publish.domain.TestBlueprintElement;
import org.opentestsystem.authoring.testauth.publish.domain.TestForm;
import org.opentestsystem.authoring.testauth.publish.domain.TestSpecification;
import org.opentestsystem.authoring.testauth.rest.AbstractRestEmbeddedMongoTest;
import org.opentestsystem.authoring.testauth.service.ApprovalService;
import org.opentestsystem.authoring.testauth.service.AssessmentService;
import org.opentestsystem.authoring.testauth.service.BlueprintElementService;
import org.opentestsystem.authoring.testauth.service.ComputationRuleService;
import org.opentestsystem.authoring.testauth.service.FormPartitionService;
import org.opentestsystem.authoring.testauth.service.FormService;
import org.opentestsystem.authoring.testauth.service.ItemSelectionAlgorithmService;
import org.opentestsystem.authoring.testauth.service.ItemService;
import org.opentestsystem.authoring.testauth.service.PerformanceLevelService;
import org.opentestsystem.authoring.testauth.service.PublicationService;
import org.opentestsystem.authoring.testauth.service.PublishingRecordService;
import org.opentestsystem.authoring.testauth.service.ReportingMeasureService;
import org.opentestsystem.authoring.testauth.service.ScoringRuleService;
import org.opentestsystem.authoring.testauth.service.SegmentService;
import org.opentestsystem.authoring.testauth.service.SubjectService;
import org.opentestsystem.authoring.testspecbank.client.TestSpecBankClientInterface;
import org.opentestsystem.authoring.testspecbank.client.domain.TestSpecBankClientObj;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.progman.client.ProgManClient;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.util.CollectionUtils;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;

public class PublishingRecordServiceTest extends AbstractRestEmbeddedMongoTest {

    private static final Logger LOGGER = LoggerFactory.getLogger(PublishingRecordServiceTest.class);
    private static final String LINE_SEPARATOR = System.getProperty("line.separator");

    @Autowired
    private PublishingRecordService publishingRecordService;

    @Autowired
    private PublishingRecordRepository publishingRecordRepository;

    @Autowired
    PublicationService publicationService;

    @Autowired
    SubjectService subjectService;

    @Autowired
    private AssessmentService assessmentService;

    @Autowired
    private ItemSelectionAlgorithmService itemSelectionAlgorithmService;

    @Autowired
    private SegmentService segmentService;

    @Autowired
    private ItemService itemService;

    @Autowired
    private ApprovalService approvalService;

    @Autowired
    private ComputationRuleService computationRuleService;

    @Autowired
    private ScoringRuleService scoringRuleService;

    @Autowired
    private BlueprintElementService blueprintElementService;

    @Autowired
    private TestSpecBankClientInterface testSpecBankClient; // mocked client

    @Autowired
    private ProgManClient progManClient; // mocked client

    @Autowired
    private FormService formService;

    @Autowired
    private FormPartitionService formPartitionService;

    @Autowired
    private PerformanceLevelService performanceLevelService;

    @Autowired
    private ReportingMeasureService reportingMeasureService;

    private Assessment savedAssessment;
    private PublishingRecord savedPublishingRecord;
    private ItemSelectionAlgorithm savedAlgorithm;
    private static Marshaller MARSHALLER = null;

    static {
        try {
            final Map<String, Object> properties = ImmutableMap.of(JAXBContextProperties.OXM_METADATA_SOURCE, (Object) "publish-binding-metadata.xml");
            final JAXBContext jaxbContext = JAXBContext.newInstance(new Class[] { TestSpecification.class }, properties);
            MARSHALLER = jaxbContext.createMarshaller();
            MARSHALLER.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
        } catch (final JAXBException e) {
            LOGGER.error("JAXB error", e);
        }
    }

    @Before
    public void setupTestData() {
        final Subject savedSubject = this.subjectService.saveSubject(DomainFactory.manufactureValidSubject("ABB"));
        final Publication publication = this.publicationService.savePublication(DomainFactory.manufactureValidPublication(savedSubject.getTenantId(), ImmutableSet.of(savedSubject)));
        final Publication savedPublication = this.publicationService.savePublication(publication);
        this.savedAssessment = this.assessmentService.saveAssessment(DomainFactory.manufactureValidAssessment(savedSubject, savedPublication));
        this.savedPublishingRecord = this.publishingRecordService.retrieveCurrentPublishingRecord(this.savedAssessment.getId());

        final ItemSelectionAlgorithm algorithm = DomainFactory.manufactureValidItemSelectionAlgorithm(ItemSelectionPurpose.SCALAR, ItemSelectionType.BOOLEAN);
        algorithm.setItemSelectionAlgorithmType(ItemSelectionAlgorithmType.ADAPTIVE);
        this.savedAlgorithm = this.itemSelectionAlgorithmService.createItemSelectionAlgorithm(algorithm);
    }

    @Test
    public void publishRegistrationXmlWithMoxyMarshallerConfigTest() throws IOException {
        assertThat(MARSHALLER, is(notNullValue()));
        final TestSpecification<Registration> testSpecification = new TestSpecification<Registration>();
        final Registration registration = new Registration();
        registration.setComment("comment");
        registration.setRegistrationFormList(ImmutableList.of(PODAM_FACTORY.manufacturePojo(RegistrationForm.class)));
        registration.setPoolPropertyList(ImmutableList.of(PODAM_FACTORY.manufacturePojo(PoolProperty.class)));
        registration.setRegistrationSegmentList(ImmutableList.of(PODAM_FACTORY.manufacturePojo(RegistrationSegment.class)));
        testSpecification.setIdentifier(PODAM_FACTORY.manufacturePojo(Identifier.class));
        testSpecification.setPropertyList(Lists.newArrayList(PODAM_FACTORY.manufacturePojo(Property.class)));
        testSpecification.setDescription("descriptive text");
        testSpecification.setPublishDate(new DateTime());
        testSpecification.setPurpose(Purpose.REGISTRATION.name());
        testSpecification.setContent(registration);

        final StringWriter writer = new StringWriter();
        try {
            assertThat(MARSHALLER, is(notNullValue()));
            MARSHALLER.marshal(testSpecification, writer);
            LOGGER.info("Registration XML generated from external metadata config:" + LINE_SEPARATOR + "" + writer.toString());
            assertThat(writer.toString(), is(notNullValue()));
        } catch (final JAXBException e) {
            LOGGER.error("JAXB error", e);
            fail("JAXB marshalling failed");
        }
    }

    @Test
    public void publishAdministrationXmlWithMoxyMarshallerConfigTest() throws IOException {
        assertThat(MARSHALLER, is(notNullValue()));
        final TestSpecification<Administration> testSpecification = new TestSpecification<Administration>();
        final Administration administration = new Administration();
        administration.setComment("comment");
        administration.setItemPool(PODAM_FACTORY.manufacturePojo(ItemPool.class));
        administration.setTestFormList(ImmutableList.of(PODAM_FACTORY.manufacturePojo(TestForm.class)));
        administration.setTestBlueprintList(ImmutableList.of(PODAM_FACTORY.manufacturePojo(TestBlueprintElement.class)));
        administration.setPoolPropertyList(ImmutableList.of(PODAM_FACTORY.manufacturePojo(PoolProperty.class)));
        administration.setAdministrationSegmentList(ImmutableList.of(PODAM_FACTORY.manufacturePojo(AdministrationSegment.class)));
        testSpecification.setIdentifier(PODAM_FACTORY.manufacturePojo(Identifier.class));
        testSpecification.setPropertyList(Lists.newArrayList(PODAM_FACTORY.manufacturePojo(Property.class)));
        testSpecification.setDescription("descriptive text");
        testSpecification.setPublishDate(new DateTime());
        testSpecification.setPurpose(Purpose.ADMINISTRATION.name());
        testSpecification.setContent(administration);

        final StringWriter writer = new StringWriter();
        try {
            assertThat(MARSHALLER, is(notNullValue()));
            MARSHALLER.marshal(testSpecification, writer);
            LOGGER.info("Administration XML generated from external metadata config:" + LINE_SEPARATOR + "" + writer.toString());
            assertThat(writer.toString(), is(notNullValue()));
        } catch (final JAXBException e) {
            LOGGER.error("JAXB error", e);
            fail("JAXB marshalling failed");
        }
    }

    @Test
    public void registrationUpdatePublishingStatusFromInprogressToAwaitingApproval() throws InterruptedException {
        saveGoodMinimalSegmentAndItemData();
        saveGoodMinimalBlueprintData();
        when(this.progManClient.getTenantById(this.savedAssessment.getTenantId())).thenReturn(buildTenant("id1", "tenant1", "description1"));

        final PublishingRecord publishingRecord = this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(this.savedAssessment.getId());
        final PublishingRecord updatedPublishingRecord = this.publishingRecordService.savePublishingRecord(publishingRecord, false);
        assertThat(updatedPublishingRecord, is(notNullValue()));
        assertThat(updatedPublishingRecord.getPublishingStatus(), is(AWAITING_APPROVAL));

        assertThat(this.assessmentService.getAssessment(this.savedAssessment.getId()).isLocked(), is(true));
    }

    @Test
    public void registrationUpdatePublishingStatusFromAwaitingApprovalToPublished() throws InterruptedException {

        buildValidFixedFormData();
        saveGoodMinimalBlueprintData();
        when(this.progManClient.getTenantById(this.savedAssessment.getTenantId())).thenReturn(buildTenant("id1", "tenant1", "description1"));

        // update from in progress to awaiting approval
        final PublishingRecord publishingRecord = this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(this.savedAssessment.getId());
        PublishingRecord updatedPublishingRecord = this.publishingRecordService.savePublishingRecord(publishingRecord, false);
        assertThat(updatedPublishingRecord, is(notNullValue()));
        assertThat(updatedPublishingRecord.getPublishingStatus(), is(AWAITING_APPROVAL));

        assertThat(this.testSpecBankClient, is(notNullValue()));
        assertThat(this.progManClient, is(notNullValue()));
        assertThat(this.savedAssessment, is(notNullValue()));

        when(this.testSpecBankClient.publishTestSpecification((TestSpecBankClientObj) Mockito.anyObject())).thenReturn(new TestSpecBankClientObj());
        // this.approvalService.saveApproval(DomainFactory.manufactureValidApproval(this.savedAssessment.getId(), this.savedPublishingRecord.getId()));
        getApprovedApprovals(updatedPublishingRecord.getId());
        // List<Approval> initialApprovals = this.approvalService.createInitialApprovals(updatedPublishingRecord.getId());

        // update from awaiting approval to published
        updatedPublishingRecord = this.publishingRecordService.savePublishingRecord(updatedPublishingRecord, false);

        // verify(this.testSpecBankClient).publishTestSpecification(new TestSpecBankClientObj());
        verify(this.progManClient, atLeast(1)).getTenantById(this.savedAssessment.getTenantId());
        assertThat(updatedPublishingRecord, is(notNullValue()));
        // assertThat(updatedPublishingRecord.getPublishingStatus(), is(PUBLISHING));

        assertThat(this.assessmentService.getAssessment(this.savedAssessment.getId()).isLocked(), is(true));
    }

    @Test
    public void registrationUpdatePublishingStatusFromPublishedToInprogress() throws InterruptedException {

        saveGoodMinimalSegmentAndItemData();
        saveGoodMinimalBlueprintData();
        when(this.progManClient.getTenantById(this.savedAssessment.getTenantId())).thenReturn(buildTenant("id1", "tenant1", "description1"));
        when(this.testSpecBankClient.publishTestSpecification((TestSpecBankClientObj) Mockito.anyObject())).thenReturn(new TestSpecBankClientObj());

        // update from in progress to awaiting approval
        final PublishingRecord publishingRecord = this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(this.savedAssessment.getId());
        PublishingRecord updatedPublishingRecord = this.publishingRecordService.savePublishingRecord(publishingRecord, false);
        assertThat(updatedPublishingRecord, is(notNullValue()));
        assertThat(updatedPublishingRecord.getPublishingStatus(), is(AWAITING_APPROVAL));

        // update from awaiting approval to published
        // update from published to in progress
        final PublishingRecord currentPublishingRecord = this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(this.savedAssessment.getId());
        if (currentPublishingRecord.getPublishingStatus() != PUBLISHED) {
            currentPublishingRecord.setPublishingStatus(PUBLISHED);
            this.publishingRecordRepository.save(currentPublishingRecord);
        }
        updatedPublishingRecord = this.publishingRecordService.savePublishingRecord(currentPublishingRecord, false);
        assertThat(updatedPublishingRecord, is(notNullValue()));
        assertThat(updatedPublishingRecord.getPublishingStatus(), is(INPROGRESS));
        assertThat(updatedPublishingRecord.getVersion(), is("1.1"));
    }

    @Test
    public void registrationUpdatePublishingStatusFromPublishedToInprogressNextMajor() throws InterruptedException {

        saveGoodMinimalSegmentAndItemData();
        saveGoodMinimalBlueprintData();
        when(this.progManClient.getTenantById(this.savedAssessment.getTenantId())).thenReturn(buildTenant("id1", "tenant1", "description1"));
        when(this.testSpecBankClient.publishTestSpecification((TestSpecBankClientObj) Mockito.anyObject())).thenReturn(new TestSpecBankClientObj());

        // update from in progress to awaiting approval
        final PublishingRecord publishingRecord = this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(this.savedAssessment.getId());
        PublishingRecord updatedPublishingRecord = this.publishingRecordService.savePublishingRecord(publishingRecord, false);
        assertThat(updatedPublishingRecord, is(notNullValue()));
        assertThat(updatedPublishingRecord.getPublishingStatus(), is(AWAITING_APPROVAL));

        // update from awaiting approval to published
        // update from published to in progress
        final PublishingRecord currentPublishingRecord = this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(this.savedAssessment.getId());
        if (currentPublishingRecord.getPublishingStatus() != PUBLISHED) {
            currentPublishingRecord.setPublishingStatus(PUBLISHED);
            this.publishingRecordRepository.save(currentPublishingRecord);
        }
        updatedPublishingRecord = this.publishingRecordService.savePublishingRecord(currentPublishingRecord, true);
        assertThat(updatedPublishingRecord, is(notNullValue()));
        assertThat(updatedPublishingRecord.getPublishingStatus(), is(INPROGRESS));
        assertThat(updatedPublishingRecord.getVersion(), is("2.0"));
    }

    @Test
    public void updatePublishingNextMajorFromPointNine() throws InterruptedException {

        saveGoodMinimalSegmentAndItemData();
        saveGoodMinimalBlueprintData();
        when(this.progManClient.getTenantById(this.savedAssessment.getTenantId())).thenReturn(buildTenant("id1", "tenant1", "description1"));
        when(this.testSpecBankClient.publishTestSpecification((TestSpecBankClientObj) Mockito.anyObject())).thenReturn(new TestSpecBankClientObj());

        // update from in progress to awaiting approval
        final PublishingRecord publishingRecord = this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(this.savedAssessment.getId());
        PublishingRecord updatedPublishingRecord = this.publishingRecordService.savePublishingRecord(publishingRecord, false);
        assertThat(updatedPublishingRecord, is(notNullValue()));
        assertThat(updatedPublishingRecord.getPublishingStatus(), is(AWAITING_APPROVAL));

        // update from awaiting approval to published
        // update from published to in progress
        final PublishingRecord currentPublishingRecord = this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(this.savedAssessment.getId());
        if (currentPublishingRecord.getPublishingStatus() != PUBLISHED) {
            currentPublishingRecord.setPublishingStatus(PUBLISHED);
            this.publishingRecordRepository.save(currentPublishingRecord);
        }
        currentPublishingRecord.setVersion("1.9");
        this.publishingRecordRepository.save(currentPublishingRecord);
        updatedPublishingRecord = this.publishingRecordService.savePublishingRecord(currentPublishingRecord, true);
        assertThat(updatedPublishingRecord, is(notNullValue()));
        assertThat(updatedPublishingRecord.getPublishingStatus(), is(INPROGRESS));
        assertThat(updatedPublishingRecord.getVersion(), is("2.0"));
    }

    @Test
    public void registrationUpdatePublishingStatusFromPublishedToInprogressNextMajorAfter10() throws InterruptedException {

        saveGoodMinimalSegmentAndItemData();
        saveGoodMinimalBlueprintData();
        when(this.progManClient.getTenantById(this.savedAssessment.getTenantId())).thenReturn(buildTenant("id1", "tenant1", "description1"));
        when(this.testSpecBankClient.publishTestSpecification((TestSpecBankClientObj) Mockito.anyObject())).thenReturn(new TestSpecBankClientObj());

        // update from in progress to awaiting approval
        final PublishingRecord publishingRecord = this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(this.savedAssessment.getId());
        PublishingRecord updatedPublishingRecord = this.publishingRecordService.savePublishingRecord(publishingRecord, false);
        assertThat(updatedPublishingRecord, is(notNullValue()));
        assertThat(updatedPublishingRecord.getPublishingStatus(), is(AWAITING_APPROVAL));

        // update from awaiting approval to published
        // update from published to in progress
        final PublishingRecord currentPublishingRecord = this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(this.savedAssessment.getId());
        if (currentPublishingRecord.getPublishingStatus() != PUBLISHED) {
            currentPublishingRecord.setPublishingStatus(PUBLISHED);
            currentPublishingRecord.setVersion("10.0");
            this.publishingRecordRepository.save(currentPublishingRecord);
        }
        updatedPublishingRecord = this.publishingRecordService.savePublishingRecord(currentPublishingRecord, true);
        assertThat(updatedPublishingRecord, is(notNullValue()));
        assertThat(updatedPublishingRecord.getPublishingStatus(), is(INPROGRESS));
        assertThat(updatedPublishingRecord.getVersion(), is("11.0"));
    }

    @Test
    public void registrationUpdatePublishingStatusWithAlteredStatusShouldFail() throws InterruptedException {
        saveGoodMinimalSegmentAndItemData();
        saveGoodMinimalBlueprintData();
        when(this.progManClient.getTenantById(this.savedAssessment.getTenantId())).thenReturn(buildTenant("id1", "tenant1", "description1"));

        // update from in progress to awaiting approval
        final PublishingRecord publishingRecord = this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(this.savedAssessment.getId());
        final PublishingRecord updatedPublishingRecord = this.publishingRecordService.savePublishingRecord(publishingRecord, false);
        assertThat(updatedPublishingRecord, is(notNullValue()));
        assertThat(updatedPublishingRecord.getPublishingStatus(), is(AWAITING_APPROVAL));

        try {
            updatedPublishingRecord.setPublishingStatus(PUBLISHING);
            this.publishingRecordService.savePublishingRecord(updatedPublishingRecord, false);
            fail("exception should be thrown when trying to save publishing record with altered publishing status");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("publishingRecord.publishingStatus.mismatch"));
        }
    }

    @Test
    public void registrationUpdatePublishingStatusWithAlteredStatusOfRejectShouldWork() throws InterruptedException {
        saveGoodMinimalSegmentAndItemData();
        saveGoodMinimalBlueprintData();
        when(this.progManClient.getTenantById(this.savedAssessment.getTenantId())).thenReturn(buildTenant("id1", "tenant1", "description1"));

        // update from in progress to awaiting approval
        final PublishingRecord publishingRecord = this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(this.savedAssessment.getId());
        PublishingRecord updatedPublishingRecord = this.publishingRecordService.savePublishingRecord(publishingRecord, false);
        assertThat(updatedPublishingRecord, is(notNullValue()));
        assertThat(updatedPublishingRecord.getPublishingStatus(), is(AWAITING_APPROVAL));

        updatedPublishingRecord.setPublishingStatus(REJECT);
        updatedPublishingRecord = this.publishingRecordService.savePublishingRecord(updatedPublishingRecord, false);
        assertThat(updatedPublishingRecord, is(notNullValue()));
        assertThat(updatedPublishingRecord.getPublishingStatus(), is(INPROGRESS));
    }

    @Test
    public void registrationUpdatePublishingStatusWithAlteredVersionFail() throws InterruptedException {
        saveGoodMinimalSegmentAndItemData();
        saveGoodMinimalBlueprintData();
        when(this.progManClient.getTenantById(this.savedAssessment.getTenantId())).thenReturn(buildTenant("id1", "tenant1", "description1"));

        // update from in progress to awaiting approval
        final PublishingRecord publishingRecord = this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(this.savedAssessment.getId());
        final PublishingRecord updatedPublishingRecord = this.publishingRecordService.savePublishingRecord(publishingRecord, false);
        assertThat(updatedPublishingRecord, is(notNullValue()));
        assertThat(updatedPublishingRecord.getVersion(), is("1.0"));

        try {
            updatedPublishingRecord.setVersion("1.1");
            this.publishingRecordService.savePublishingRecord(updatedPublishingRecord, false);
            fail("exception should be thrown when trying to save publishing record with altered version");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("publishingRecord.version.mismatch"));
        }
    }

    @Test
    @Ignore
    public void publishSansTenantShouldFailTest() throws InterruptedException {

        saveGoodMinimalSegmentAndItemData();
        saveGoodMinimalBlueprintData();

        this.savedAssessment.setTenantId("asfasdffad");
        this.assessmentService.updateAssessment(this.savedAssessment);
        // update from in progress to awaiting approval
        final PublishingRecord currentPublishingRecord = this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(this.savedAssessment.getId());
        assertThat(currentPublishingRecord, is(notNullValue()));
        assertThat(currentPublishingRecord.getPublishingStatus(), is(INPROGRESS));

        try {
            this.publishingRecordService.savePublishingRecord(currentPublishingRecord, false);
            fail("exception should be thrown when trying to publish an assessment sans tenant");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "publishingRecord.testspec.tenant.retrieval.failed").size(), is(1));
        }
    }

    @Test
    public void publishHasBlueprintErrorsTest() throws InterruptedException {
        when(this.progManClient.getTenantById(this.savedAssessment.getTenantId())).thenReturn(buildTenant("id1", "tenant1", "description1"));

        saveGoodMinimalSegmentAndItemData();

        final List<Segment> segments = this.segmentService.findSegmentListByAssessmentId(this.savedAssessment.getId());
        this.segmentService.loadReferenceData(segments);
        final BlueprintElement bpe = DomainFactory.manufactureValidBlueprintElement(this.savedAssessment.getId(), segments);
        bpe.setGrade(this.savedAssessment.getGrade()[0]);
        bpe.setLevel("1");
        bpe.setStandardKey("CC-ELA-v1");
        bpe.setTextDescription("textDescription");
        bpe.setActive(true);
        bpe.getBlueprintElementValueMap().get(segments.get(0).getId()).setOperationalItemMinValue(99);
        bpe.getBlueprintElementValueMap().get(segments.get(0).getId()).setOperationalItemMaxValue(10);
        this.blueprintElementService.saveBlueprintElement(null, bpe);

        final PublishingRecord returnedPublishingRecord = this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(this.savedAssessment.getId());
        if (CollectionUtils.isEmpty(returnedPublishingRecord.getValidationResultList())) {
            fail("exception should be thrown when trying to publish an assessment w/ blueprint validation errors");
        } else {
            assertThat(returnedPublishingRecord.getValidationResultList().size(), is(2));
            assertThat(returnedPublishingRecord.getValidationResultList().get(0).getMessage(), startsWith("Item Pool data validation error: Segment:"));
        }
    }

    @Test
    public void publishHasNoSegmentDataTest() throws InterruptedException {
        when(this.progManClient.getTenantById(this.savedAssessment.getTenantId())).thenReturn(buildTenant("id1", "tenant1", "description1"));

        final PublishingRecord returnedPublishingRecord = this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(this.savedAssessment.getId());
        if (CollectionUtils.isEmpty(returnedPublishingRecord.getValidationResultList())) {
            fail("exception should be thrown when trying to publish an assessment w/o segment data");
        } else {
            assertThat(returnedPublishingRecord.getValidationResultList().size(), is(1));
            assertThat(returnedPublishingRecord.getValidationResultList().get(0).getMessage(), is("Segment data is required."));
        }
    }

    @Test
    public void publishHasNoBlueprintDataTest() throws InterruptedException {
        when(this.progManClient.getTenantById(this.savedAssessment.getTenantId())).thenReturn(buildTenant("id1", "tenant1", "description1"));

        saveGoodMinimalSegmentAndItemData();

        this.savedPublishingRecord.setPurpose(new Purpose[] { Purpose.ADMINISTRATION });
        final PublishingRecord returnedPublishingRecord = this.publishingRecordService.savePublishingRecord(this.savedPublishingRecord, false);
        if (CollectionUtils.isEmpty(returnedPublishingRecord.getValidationResultList())) {
            fail("exception should be thrown when trying to publish an assessment w/o blueprint data");
        } else {
            assertThat(returnedPublishingRecord.getValidationResultList().size(), is(1));
            assertThat(returnedPublishingRecord.getValidationResultList().get(0).getMessage(),
                    is("Blueprint data is required.  Matching blueprints for this assessment's grade(s) need to be added."));
        }
    }

    @Test
    public void determineAvailableSpecTypesForAssessmentHasSegmentOnly() throws InterruptedException {

        saveGoodMinimalSegmentAndItemData();

        final PublishingRecord publishingRecord = this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(this.savedAssessment.getId());
        final List<Purpose> specTypes = Arrays.asList(publishingRecord.getPurpose());

        assertThat(specTypes, is(notNullValue()));
        assertThat(specTypes, hasItem(Purpose.REGISTRATION));
        assertThat(specTypes, not(hasItem(Purpose.ADMINISTRATION)));
        assertThat(specTypes, not(hasItem(Purpose.SCORING)));
        assertThat(specTypes, not(hasItem(Purpose.REPORTING)));
        assertThat(specTypes, not(hasItem(Purpose.COMPLETE)));
        assertThat(specTypes, not(hasItem(Purpose.SIMULATION)));
    }

    @Test
    public void determineAvailableSpecTypesForAssessmentHasSegmentBlueprint() throws InterruptedException {

        saveGoodMinimalSegmentAndItemData();
        saveGoodMinimalBlueprintData();

        final PublishingRecord publishingRecord = this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(this.savedAssessment.getId());
        final List<Purpose> specTypes = Arrays.asList(publishingRecord.getPurpose());

        assertThat(specTypes, is(notNullValue()));
        assertThat(specTypes, hasItem(Purpose.REGISTRATION));
        assertThat(specTypes, hasItem(Purpose.ADMINISTRATION));
        assertThat(specTypes, not(hasItem(Purpose.REPORTING)));
        assertThat(specTypes, not(hasItem(Purpose.SCORING)));
        assertThat(specTypes, not(hasItem(Purpose.COMPLETE)));
        assertThat(specTypes, not(hasItem(Purpose.SIMULATION)));
    }

    @Test
    public void determineAvailableSpecTypesForAssessmentHasSegmentBlueprintItemScoringRulePerformance() throws InterruptedException {

        saveGoodMinimalSegmentAndItemData();
        saveGoodMinimalBlueprintData();
        saveGoodMinimalScoringRuleData();
        saveGoodMinimalPerformanceLevelData();

        final PublishingRecord publishingRecord = this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(this.savedAssessment.getId());
        final List<Purpose> specTypes = Arrays.asList(publishingRecord.getPurpose());

        assertThat(specTypes, is(notNullValue()));
        assertThat(specTypes, hasItem(Purpose.REGISTRATION));
        assertThat(specTypes, hasItem(Purpose.ADMINISTRATION));
        assertThat(specTypes, hasItem(Purpose.SCORING));
        assertThat(specTypes, not(hasItem(Purpose.REPORTING)));
        assertThat(specTypes, not(hasItem(Purpose.COMPLETE)));
        assertThat(specTypes, not(hasItem(Purpose.SIMULATION)));
    }

    @Test
    public void determineAvailableSpecTypesForAssessmentHasSegmentBlueprintItemScoringRulePerformanceReporting() throws InterruptedException {

        saveGoodMinimalSegmentAndItemData();
        saveGoodMinimalBlueprintData();
        final ScoringRule scoringRule = saveGoodMinimalScoringRuleData();
        saveGoodMinimalPerformanceLevelData();
        saveGoodMinimalReportingMeasureData(scoringRule);

        final PublishingRecord publishingRecord = this.publishingRecordService.retrievePublishingRecordWithAllowablePurposes(this.savedAssessment.getId());
        final List<Purpose> specTypes = Arrays.asList(publishingRecord.getPurpose());

        assertThat(specTypes, is(notNullValue()));
        assertThat(specTypes, hasItem(Purpose.REGISTRATION));
        assertThat(specTypes, hasItem(Purpose.ADMINISTRATION));
        assertThat(specTypes, hasItem(Purpose.SCORING));
        assertThat(specTypes, hasItem(Purpose.REPORTING));
        assertThat(specTypes, hasItem(Purpose.COMPLETE));
        assertThat(specTypes, not(hasItem(Purpose.SIMULATION)));
    }

    private void saveGoodMinimalSegmentAndItemData() {
        final Segment savedSegment = this.segmentService.createSegment(DomainFactory.manufactureValidSegment(this.savedAssessment.getId(), this.savedAlgorithm, 1));
        buildItemsForSegment(12, savedSegment.getId());
    }

    private ScoringRule saveGoodMinimalScoringRuleData() {
        final ComputationRule computationRule = new ComputationRule();
        computationRule.setConversionTableType(ConversionTableType.NONE);
        computationRule.setName("name");
        computationRule.setVersion("1.0");
        final ComputationRuleParameter computationRuleParameter = new ComputationRuleParameter();
        computationRuleParameter.setParameterName("parameterName");
        computationRuleParameter.setComputationRuleType(ComputationRuleType.STRING);
        computationRuleParameter.setDefaultValue("defaultValue");
        computationRuleParameter.setComputationRuleMultiplicityType(ComputationRuleMultiplicityType.SCALAR);
        computationRuleParameter.setPosition(1);
        computationRule.setParameters(ImmutableList.of(computationRuleParameter));
        final ComputationRule savedComputationRule = this.computationRuleService.createComputationRule(computationRule);
        final ScoringRule scoringRule = new ScoringRule();
        scoringRule.setAssessmentId(this.savedAssessment.getId());
        scoringRule.setLabel("label");
        scoringRule.setOrder(1);
        scoringRule.setComputationRuleId(savedComputationRule.getId());
        scoringRule.setBlueprintReferenceType(BlueprintReferenceType.SEGMENT);
        final Segment savedSegment = this.segmentService.searchSegments(TestAuthUtil.searchParamsByAssessmentIdSmall(this.savedAssessment.getId())).getSearchResults().get(0);
        scoringRule.setBlueprintReferenceId(savedSegment.getId());
        final ScoringRuleParameter scoringRuleParameter = new ScoringRuleParameter();
        scoringRuleParameter.setComputationRuleParameterName(computationRuleParameter.getParameterName());
        scoringRuleParameter.setComputationRuleParameterMultiplicity(ComputationRuleMultiplicityType.SCALAR);
        scoringRuleParameter.setScalarValue("scalarValue");
        scoringRule.setParameters(ImmutableList.of(scoringRuleParameter));
        return this.scoringRuleService.saveScoringRule(null, scoringRule);
    }

    private void saveGoodMinimalBlueprintData() {
        final List<Segment> segments = this.segmentService.findSegmentListByAssessmentId(this.savedAssessment.getId());
        this.segmentService.loadReferenceData(segments);
        final BlueprintElement bpe = DomainFactory.manufactureValidBlueprintElement(this.savedAssessment.getId(), segments);
        bpe.setGrade(this.savedAssessment.getGrade()[0]);
        bpe.setLevel("1");
        bpe.setStandardKey("CC-ELA-v1");
        bpe.setTextDescription("textDescription");
        bpe.setActive(true);
        this.blueprintElementService.saveBlueprintElement(null, bpe);
    }

    private void saveGoodMinimalPerformanceLevelData() {
        final PerformanceLevel performanceLevel = DomainFactory.manufactureValidPerformanceLevel(this.savedAssessment.getId());
        this.performanceLevelService.savePerformanceLevel(null, performanceLevel);
    }

    private void saveGoodMinimalReportingMeasureData(final ScoringRule scoringRule) {
        final ReportingMeasure reportingMeasure = manufactureValidReportingMeasure(this.savedAssessment.getId(), scoringRule);
        this.reportingMeasureService.saveReportingMeasure(null, reportingMeasure);
    }

    private void buildValidFixedFormData() {
        final ItemSelectionAlgorithm algorithm = DomainFactory.manufactureValidItemSelectionAlgorithm(ItemSelectionPurpose.SCALAR, ItemSelectionType.BOOLEAN);
        algorithm.setItemSelectionAlgorithmType(ItemSelectionAlgorithmType.FIXEDFORM);
        final ItemSelectionAlgorithm savedAlgorithm2 = this.itemSelectionAlgorithmService.createItemSelectionAlgorithm(algorithm);

        final Segment savedSegment2 = this.segmentService.createSegment(DomainFactory.manufactureValidSegment(this.savedAssessment.getId(), savedAlgorithm2, 1));
        final Segment savedSegment3 = this.segmentService.createSegment(DomainFactory.manufactureValidSegment(this.savedAssessment.getId(), savedAlgorithm2, 2));

        final Form savedForm = this.formService.saveForm(null, DomainFactory.manufactureValidForm(this.savedAssessment.getId()));

        final FormPartition savedFormPartition = this.formPartitionService.saveFormPartition(null,
                DomainFactory.manufactureValidFormPartition(this.savedAssessment.getId(), "partition1", savedForm.getId(), savedSegment2.getId()));
        final FormPartition savedFormPartition2 = this.formPartitionService.saveFormPartition(null,
                DomainFactory.manufactureValidFormPartition(this.savedAssessment.getId(), "partition2", savedForm.getId(), savedSegment3.getId()));

        buildItemsForPartition(12, savedFormPartition.getId(), savedFormPartition2.getId());
    }

    private void buildItemsForPartition(final int itemsToBuild, final String... partitionIdList) {
        for (int i = 0; i < itemsToBuild; i++) {
            final Item item = DomainFactory.manufactureValidItem(this.savedAssessment.getId());
            item.setId(null);
            final List<ItemLocation> itemLocationList = Lists.newArrayList();
            for (final String partitionId : partitionIdList) {
                itemLocationList.add(new FixedFormItemLocation(partitionId, null, i + 1, 1));
            }
            item.setItemLocation(itemLocationList);
            this.itemService.saveItem(item);
        }
    }

    private void buildItemsForSegment(final int itemsToBuild, final String... segmentIdList) {
        for (int i = 0; i < itemsToBuild; i++) {
            final Item item = DomainFactory.manufactureValidItem(this.savedAssessment.getId());
            item.setId(null);
            final List<ItemLocation> itemLocationList = Lists.newArrayList();
            for (final String segmentId : segmentIdList) {
                itemLocationList.add(new AdaptiveItemLocation(segmentId, null, 0, 0));
            }
            item.setItemLocation(itemLocationList);
            this.itemService.saveItem(item);
        }
    }

    private ReportingMeasure manufactureValidReportingMeasure(final String assessmentId, final ScoringRule scoringRule) {
        final ReportingMeasure reportingMeasure = new ReportingMeasure();
        reportingMeasure.setId(null);
        reportingMeasure.setBlueprintReferenceType(scoringRule.getBlueprintReferenceType());
        reportingMeasure.setBlueprintReferenceId(scoringRule.getBlueprintReferenceId());
        reportingMeasure.setAssessmentId(assessmentId);
        reportingMeasure.setScoringRuleIdList(Lists.newArrayList(scoringRule.getId()));
        return reportingMeasure;
    }

    private List<Approval> getApprovedApprovals(final String publishingRecordId) {
        final List<Approval> initialApprovals = this.approvalService.createInitialApprovals(publishingRecordId);

        for (final Approval approval : initialApprovals) {
            approval.setStatus(ApprovalStatus.APPROVED);
            approval.setMessage("approval message");
            this.approvalService.updateApproval(approval);
        }
        return initialApprovals;
    }

}
