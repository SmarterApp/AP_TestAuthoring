/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.publish;

import static org.opentestsystem.authoring.testauth.config.TestAuthUtil.nullsafeListTransform;
import static org.opentestsystem.authoring.testauth.config.TestAuthUtil.paramArray;
import static org.opentestsystem.authoring.testauth.config.TestAuthUtil.searchParamsByAssessmentIdLarge;
import static org.opentestsystem.authoring.testauth.domain.BlueprintReferenceType.AFFINITY_GROUP;
import static org.opentestsystem.authoring.testauth.domain.BlueprintReferenceType.SEGMENT;
import static org.opentestsystem.authoring.testauth.domain.BlueprintReferenceType.STANDARD;
import static org.opentestsystem.authoring.testauth.domain.BlueprintReferenceType.TEST;
import static org.opentestsystem.authoring.testauth.publish.PublisherUtil.BP_PARENT_KEY_TRANSFORMER;
import static org.opentestsystem.authoring.testauth.publish.PublisherUtil.COMPUTATION_RULE_ORDER;
import static org.opentestsystem.authoring.testauth.publish.PublisherUtil.LEAF_NODE_TYPE_FILTER;
import static org.opentestsystem.authoring.testauth.publish.PublisherUtil.LEVEL_TYPE_FILTER;
import static org.opentestsystem.authoring.testauth.publish.PublisherUtil.PARENT_KEY_FILTER;

import java.util.List;
import java.util.Map;

import org.opentestsystem.authoring.testauth.domain.AffinityGroup;
import org.opentestsystem.authoring.testauth.domain.Assessment;
import org.opentestsystem.authoring.testauth.domain.BlueprintElement;
import org.opentestsystem.authoring.testauth.domain.BlueprintReferenceType;
import org.opentestsystem.authoring.testauth.domain.ScoringRule;
import org.opentestsystem.authoring.testauth.domain.Segment;
import org.opentestsystem.authoring.testauth.persistence.GridFsRepository;
import org.opentestsystem.authoring.testauth.publish.PublisherUtil.COMP_RULE_REORDER_TRANSFORMER;
import org.opentestsystem.authoring.testauth.publish.PublisherUtil.CONVERSION_TABLE_TRANSFORMER;
import org.opentestsystem.authoring.testauth.publish.PublisherUtil.LEAF_NODE_LEVEL_SCORING_RULE_TRANSFORMER;
import org.opentestsystem.authoring.testauth.publish.PublisherUtil.LEVEL_FILTER;
import org.opentestsystem.authoring.testauth.publish.PublisherUtil.NON_LEAF_NODE_FILTER;
import org.opentestsystem.authoring.testauth.publish.PublisherUtil.SCORING_RULE_TRANSFORMER;
import org.opentestsystem.authoring.testauth.publish.domain.ScoringRuleData;
import org.opentestsystem.authoring.testauth.publish.domain.TestComputationRule;
import org.opentestsystem.authoring.testauth.service.AffinityGroupService;
import org.opentestsystem.authoring.testauth.service.BlueprintElementService;
import org.opentestsystem.authoring.testauth.service.ComputationRuleService;
import org.opentestsystem.authoring.testauth.service.ScoringRuleService;
import org.opentestsystem.authoring.testauth.service.SegmentService;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.google.common.base.Predicates;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Multimap;
import com.google.common.collect.Multimaps;
import com.mongodb.gridfs.GridFSFile;

@Component
public class SharedPublisherHelper {

    @Autowired
    private transient SegmentService segmentService;

    @Autowired
    private transient BlueprintElementService blueprintElementService;

    @Autowired
    private transient AffinityGroupService affinityGroupService;

    @Autowired
    private transient ScoringRuleService scoringRuleService;

    @Autowired
    private transient ComputationRuleService computationRuleService;

    @Autowired
    private transient GridFsRepository gridFsRepository;

    public List<BlueprintElement> getActiveBlueprintElements(final String assessmentId) {
        final List<BlueprintElement> blueprintElements = Lists.newArrayList();
        final Map<String, String[]> parameterMap = searchParamsByAssessmentIdLarge(assessmentId);
        parameterMap.put("active", paramArray("true"));
        final SearchResponse<BlueprintElement> blueprintElementList = this.blueprintElementService.searchBlueprintElements(parameterMap);
        blueprintElements.addAll(blueprintElementList.getSearchResults());
        return blueprintElements;
    }

    public List<AffinityGroup> getActiveAffinityGroups(final String assessmentId) {
        final List<AffinityGroup> affinityGroups = Lists.newArrayList();
        final Map<String, String[]> parameterMap = searchParamsByAssessmentIdLarge(assessmentId);
        parameterMap.put("active", paramArray("true"));
        final SearchResponse<AffinityGroup> affinityGroupList = this.affinityGroupService.search(parameterMap);
        affinityGroups.addAll(affinityGroupList.getSearchResults());
        return affinityGroups;
    }

    // ========================================================================================================================================================================
    // segment construction
    public List<Segment> retrieveSegmentList(final String assessmentId) {
        final SearchResponse<Segment> segmentResponse = this.segmentService.searchSegments(searchParamsByAssessmentIdLarge(assessmentId));
        this.segmentService.loadReferenceData(segmentResponse.getSearchResults());
        return segmentResponse.getSearchResults();
    }

    // ========================================================================================================================================================================
    // scoring rule construction
    public List<ScoringRule> retrieveScoringRules(final String assessmentId) {
        final List<ScoringRule> scoringRuleList = this.scoringRuleService.getScoringRulesByAssessmentId(assessmentId);
        for (final ScoringRule scoringRule : scoringRuleList) {
            if (scoringRule != null && scoringRule.getComputationRuleId() != null) {
                scoringRule.setComputationRule(this.computationRuleService.getComputationRule(scoringRule.getComputationRuleId()));
            }
            if (scoringRule != null && scoringRule.getValueConversionTableGridFsId() != null) {
                final GridFSFile gridFsFile = this.gridFsRepository.getById(scoringRule.getValueConversionTableGridFsId());
                scoringRule.setValueConversionTableFilename(gridFsFile.getFilename());
            }
            if (scoringRule != null && scoringRule.getStandardErrorConversionTableGridFsId() != null) {
                final GridFSFile gridFsFile = this.gridFsRepository.getById(scoringRule.getStandardErrorConversionTableGridFsId());
                scoringRule.setStandardErrorConversionTableFilename(gridFsFile.getFilename());
            }
        }
        return scoringRuleList;
    }

    public ScoringRuleData setupScoringRuleData(final String assessmentId, final Map<BlueprintReferenceType, Map<String, String>> blueprintReferenceMap, final List<ScoringRule> scoringRuleList,
            final List<BlueprintElement> blueprintElementList, final boolean processConversionTableFiles) {

        final ScoringRuleData scoringRuleData = new ScoringRuleData();
        final List<TestComputationRule> testComputationRuleList = nullsafeListTransform(scoringRuleList, SCORING_RULE_TRANSFORMER.getInstance(blueprintReferenceMap));
        final List<TestComputationRule> leafNodeTestComputationRuleList = buildTestComputationRulesForLeafNodeRules(scoringRuleList, Lists.newArrayList(blueprintElementList));
        final List<TestComputationRule> levelTestComputationRuleList = buildTestComputationRulesForLevelRules(scoringRuleList, Lists.newArrayList(blueprintElementList));
        final int orderIncr = 1;
        scoringRuleData.setComputationRuleList(Lists.transform(
                COMPUTATION_RULE_ORDER.sortedCopy(Iterables.concat(testComputationRuleList, leafNodeTestComputationRuleList, levelTestComputationRuleList)),
                COMP_RULE_REORDER_TRANSFORMER.getInstance(orderIncr)));
        if (processConversionTableFiles) {
            scoringRuleData.setConversionTableList(
                    Lists.newArrayList(Iterables.concat(nullsafeListTransform(scoringRuleList, CONVERSION_TABLE_TRANSFORMER.getInstance(this.gridFsRepository)))));
        }
        return scoringRuleData;
    }

    // leaf node stuff
    private List<TestComputationRule> buildTestComputationRulesForLeafNodeRules(final List<ScoringRule> scoringRuleList, final List<BlueprintElement> blueprintElementList) {
        final List<TestComputationRule> testComputationRuleList = Lists.newArrayList();
        if (Iterables.any(scoringRuleList, LEAF_NODE_TYPE_FILTER)) {
            // winnow blueprintElement list down to parentedChildren only
            Iterables.removeIf(blueprintElementList, PARENT_KEY_FILTER);
            // build multimap of bpe keyed by parent key
            final Multimap<String, BlueprintElement> blueprintElementParentKeyMultimap = Multimaps.index(blueprintElementList, BP_PARENT_KEY_TRANSFORMER);

            // filter bpe objects that are parents from parentedChildren
            Iterables.removeIf(blueprintElementList, NON_LEAF_NODE_FILTER.getInstance(blueprintElementParentKeyMultimap.keySet()));

            // construct each leaf node into a separate scoring rule
            final List<ScoringRule> leafNodeScoringRules = Lists.newArrayList(Iterables.filter(scoringRuleList, LEAF_NODE_TYPE_FILTER));
            for (final ScoringRule scoringRule : leafNodeScoringRules) {
                final int i = 1;
                // transform every leaf node bp element into a scoring rule mimicking this scoringRule
                testComputationRuleList.addAll(Lists.transform(blueprintElementList, LEAF_NODE_LEVEL_SCORING_RULE_TRANSFORMER.getInstance(scoringRule, i)));
            }
        }
        return testComputationRuleList;
    }

    // level stuff
    private List<TestComputationRule> buildTestComputationRulesForLevelRules(final List<ScoringRule> scoringRuleList, final List<BlueprintElement> blueprintElementList) {
        final List<TestComputationRule> testComputationRuleList = Lists.newArrayList();
        if (Iterables.any(scoringRuleList, LEVEL_TYPE_FILTER)) {

            // construct each leaf node into a separate scoring rule
            final List<ScoringRule> levelScoringRules = Lists.newArrayList(Iterables.filter(scoringRuleList, LEVEL_TYPE_FILTER));
            for (final ScoringRule scoringRule : levelScoringRules) {
                final int i = 1;
                // winnow blueprintElement list down to matching levels only
                Iterables.removeIf(blueprintElementList, Predicates.not(LEVEL_FILTER.getInstance(scoringRule.getBlueprintReferenceId())));
                // transform every leaf node bp element into a scoring rule mimicking this scoringRule
                testComputationRuleList.addAll(Lists.transform(blueprintElementList, LEAF_NODE_LEVEL_SCORING_RULE_TRANSFORMER.getInstance(scoringRule, i)));
            }
        }
        return testComputationRuleList;
    }

    // ========================================================================================================================================================================
    // general

    public Map<BlueprintReferenceType, Map<String, String>> buildBlueprintReferenceMap(final Assessment assessment, final List<Segment> segmentList,
            final List<BlueprintElement> blueprintElementList, final List<AffinityGroup> affinityGroupList) {
        final Map<BlueprintReferenceType, Map<String, String>> blueprintReferenceMap = Maps.newHashMap();
        blueprintReferenceMap.put(TEST, ImmutableMap.of(assessment.getId(), assessment.getName()));
        for (final Segment segment : segmentList) {
            if (blueprintReferenceMap.get(SEGMENT) == null) {
                final Map<String, String> seedMap = Maps.newHashMap();
                blueprintReferenceMap.put(SEGMENT, seedMap);
            }
            blueprintReferenceMap.get(SEGMENT).put(segment.getId(), segment.getLabel());
        }
        for (final BlueprintElement blueprintElement : blueprintElementList) {
            if (blueprintReferenceMap.get(STANDARD) == null) {
                final Map<String, String> seedMap = Maps.newHashMap();
                blueprintReferenceMap.put(STANDARD, seedMap);
            }
            blueprintReferenceMap.get(STANDARD).put(blueprintElement.getId(), blueprintElement.getStandardKey());
        }
        for (final AffinityGroup affinityGroup : affinityGroupList) {
            if (blueprintReferenceMap.get(AFFINITY_GROUP) == null) {
                final Map<String, String> seedMap = Maps.newHashMap();
                blueprintReferenceMap.put(AFFINITY_GROUP, seedMap);
            }
            blueprintReferenceMap.get(AFFINITY_GROUP).put(affinityGroup.getId(), affinityGroup.getGroupName());
        }
        return blueprintReferenceMap;
    }
}
