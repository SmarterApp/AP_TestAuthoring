/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.service.impl;

import static org.opentestsystem.authoring.testauth.config.TestAuthUtil.ASSESSMENT_CHILD_KEYMAP_XFORMER;
import static org.opentestsystem.authoring.testauth.config.TestAuthUtil.nullsafeListTransform;

import java.util.AbstractMap.SimpleEntry;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.opentestsystem.authoring.testauth.config.TestAuthUtil.ASSESSMENT_CHILD_COPY_XFORMER;
import org.opentestsystem.authoring.testauth.domain.AdaptiveItemLocation;
import org.opentestsystem.authoring.testauth.domain.AffinityGroup;
import org.opentestsystem.authoring.testauth.domain.AffinityGroupItemLocation;
import org.opentestsystem.authoring.testauth.domain.AffinityGroupValue;
import org.opentestsystem.authoring.testauth.domain.BlueprintElement;
import org.opentestsystem.authoring.testauth.domain.BlueprintElementValue;
import org.opentestsystem.authoring.testauth.domain.Enemy;
import org.opentestsystem.authoring.testauth.domain.Form;
import org.opentestsystem.authoring.testauth.domain.FormPartition;
import org.opentestsystem.authoring.testauth.domain.Item;
import org.opentestsystem.authoring.testauth.domain.ItemGroup;
import org.opentestsystem.authoring.testauth.domain.ItemLocation;
import org.opentestsystem.authoring.testauth.domain.ItemMetadataConfig;
import org.opentestsystem.authoring.testauth.domain.ItemMetadataKeys;
import org.opentestsystem.authoring.testauth.domain.PerformanceLevel;
import org.opentestsystem.authoring.testauth.domain.ReportingMeasure;
import org.opentestsystem.authoring.testauth.domain.ScoringRule;
import org.opentestsystem.authoring.testauth.domain.Segment;
import org.opentestsystem.authoring.testauth.persistence.AssessmentCounterRepository;
import org.opentestsystem.authoring.testauth.persistence.AssessmentRepository;
import org.opentestsystem.authoring.testauth.persistence.ItemMetadataKeysRepository;
import org.opentestsystem.authoring.testauth.service.AffinityGroupService;
import org.opentestsystem.authoring.testauth.service.AssessmentChildCopier;
import org.opentestsystem.authoring.testauth.service.BlueprintElementService;
import org.opentestsystem.authoring.testauth.service.EnemyService;
import org.opentestsystem.authoring.testauth.service.FileGroupService;
import org.opentestsystem.authoring.testauth.service.FormPartitionService;
import org.opentestsystem.authoring.testauth.service.FormService;
import org.opentestsystem.authoring.testauth.service.ItemGroupService;
import org.opentestsystem.authoring.testauth.service.ItemMetadataConfigService;
import org.opentestsystem.authoring.testauth.service.ItemService;
import org.opentestsystem.authoring.testauth.service.PerformanceLevelService;
import org.opentestsystem.authoring.testauth.service.PublicationService;
import org.opentestsystem.authoring.testauth.service.PublishingRecordService;
import org.opentestsystem.authoring.testauth.service.ReportingMeasureService;
import org.opentestsystem.authoring.testauth.service.ScoringRuleService;
import org.opentestsystem.authoring.testauth.service.SegmentService;
import org.opentestsystem.authoring.testauth.service.SubjectService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;

@SuppressWarnings("unchecked")
@Service
public class AssessmentChildCopierImpl implements AssessmentChildCopier {

    @Autowired
    private transient AssessmentRepository assessmentRepository;

    @Autowired
    private transient AssessmentCounterRepository assessmentCounterRepository;

    @Autowired
    private SubjectService subjectService;

    @Autowired
    private PublicationService publicationService;

    @Autowired
    private transient BlueprintElementService blueprintElementService;

    @Autowired
    private AffinityGroupService affinityGroupService;

    @Autowired
    private SegmentService segmentService;

    @Autowired
    private PublishingRecordService publishingRecordService;

    @Autowired
    private EnemyService enemyService;

    @Autowired
    private FileGroupService fileGroupService;

    @Autowired
    private ItemService itemService;

    @Autowired
    private ItemGroupService itemGroupService;

    @Autowired
    private ItemMetadataConfigService itemMetadataConfigService;

    @Autowired
    private ItemMetadataKeysRepository itemMetadataKeysRepository;

    @Autowired
    private FormService formService;

    @Autowired
    private FormPartitionService formPartitionService;

    @Autowired
    private PerformanceLevelService performanceLevelService;

    @Autowired
    private ScoringRuleService scoringRuleService;

    @Autowired
    private ReportingMeasureService reportingMeasureService;

    @Override
    public void copyAssessmentChildren(final String oldAssessmentId, final String newAssessmentId) {

        final Map<String, String> oldNewKeyLookupMap = Maps.newHashMap();

        copySegmentData(oldNewKeyLookupMap, oldAssessmentId, newAssessmentId);

        copyBlueprintElementData(oldNewKeyLookupMap, oldAssessmentId, newAssessmentId);

        copyAffinityGroupData(oldNewKeyLookupMap, oldAssessmentId, newAssessmentId);

        copyFormData(oldNewKeyLookupMap, oldAssessmentId, newAssessmentId);

        copyFormPartitionData(oldNewKeyLookupMap, oldAssessmentId, newAssessmentId);

        copyItemGroupData(oldNewKeyLookupMap, oldAssessmentId, newAssessmentId);

        copyItemData(oldNewKeyLookupMap, oldAssessmentId, newAssessmentId);

        copyItemMetadataConfigData(oldAssessmentId, newAssessmentId);

        copyItemMetadataKeysData(oldAssessmentId, newAssessmentId);

        copyScoringRuleData(oldNewKeyLookupMap, oldAssessmentId, newAssessmentId);

        copyEnemyData(oldNewKeyLookupMap, oldAssessmentId, newAssessmentId);

        copyPerformanceLevelData(oldNewKeyLookupMap, oldAssessmentId, newAssessmentId);

        copyReportingMeasureData(oldNewKeyLookupMap, oldAssessmentId, newAssessmentId);
    }

    // segment -------------------------------------------------------------------------------------------------------------------------------------------------------------
    private void copySegmentData(final Map<String, String> oldNewKeyLookupMap, final String oldAssessmentId, final String newAssessmentId) {
        final List<Segment> newSegmentList = this.segmentService.saveSegmentList(
                nullsafeListTransform(this.segmentService.findSegmentListByAssessmentId(oldAssessmentId), ASSESSMENT_CHILD_COPY_XFORMER.getInstance(newAssessmentId)), false);
        // populate map w/ old:new segment IDs
        stuffEntriesIntoMap(oldNewKeyLookupMap, nullsafeListTransform(newSegmentList, ASSESSMENT_CHILD_KEYMAP_XFORMER));
    }

    // blueprint element ---------------------------------------------------------------------------------------------------------------------------------------------------
    private void copyBlueprintElementData(final Map<String, String> oldNewKeyLookupMap, final String oldAssessmentId, final String newAssessmentId) {
        final List<BlueprintElement> newBlueprintElementList =
                nullsafeListTransform(this.blueprintElementService.getBlueprintElementsByAssessmentId(oldAssessmentId), ASSESSMENT_CHILD_COPY_XFORMER.getInstance(newAssessmentId));
        if (!CollectionUtils.isEmpty(newBlueprintElementList)) {
            for (final BlueprintElement blueprintElement : newBlueprintElementList) {
                final Map<String, BlueprintElementValue> replacementMap = Maps.newHashMap();
                for (final Map.Entry<String, BlueprintElementValue> bpElementValueEntry : blueprintElement.getBlueprintElementValueMap().entrySet()) {
                    replacementMap.put(findIdInTranslatorMap(oldNewKeyLookupMap, bpElementValueEntry.getKey()), blueprintElement.getBlueprintElementValueMap().get(bpElementValueEntry.getKey()));
                }
                blueprintElement.setBlueprintElementValueMap(replacementMap);
            }
            this.blueprintElementService.saveBlueprintElementList(newBlueprintElementList);
            // populate map w/ old:new blueprint IDs
            stuffEntriesIntoMap(oldNewKeyLookupMap, nullsafeListTransform(newBlueprintElementList, ASSESSMENT_CHILD_KEYMAP_XFORMER));
        }
    }

    // affinity group ---------------------------------------------------------------------------------------------------------------------------------------------------
    private void copyAffinityGroupData(final Map<String, String> oldNewKeyLookupMap, final String oldAssessmentId, final String newAssessmentId) {
        final List<AffinityGroup> newAffinityGroupList =
                nullsafeListTransform(this.affinityGroupService.getAffinityGroupsByAssessment(oldAssessmentId), ASSESSMENT_CHILD_COPY_XFORMER.getInstance(newAssessmentId));

        for (final AffinityGroup newGroup : newAffinityGroupList) {
            // translate segmentIds
            final Map<String, AffinityGroupValue> newValueMap = new HashMap<String, AffinityGroupValue>();
            for (final Entry<String, AffinityGroupValue> entry : newGroup.getAffinityGroupValueMap().entrySet()) {
                final String newKey = findIdInTranslatorMap(oldNewKeyLookupMap, entry.getKey());
                newValueMap.put(newKey, entry.getValue());
            }
            newGroup.setAffinityGroupValueMap(newValueMap);

            this.affinityGroupService.saveNewAffinityGroup(newGroup);
        }

        stuffEntriesIntoMap(oldNewKeyLookupMap, nullsafeListTransform(newAffinityGroupList, ASSESSMENT_CHILD_KEYMAP_XFORMER));
    }

    // form ----------------------------------------------------------------------------------------------------------------------------------------------------------------
    private void copyFormData(final Map<String, String> oldNewKeyLookupMap, final String oldAssessmentId, final String newAssessmentId) {
        final List<Form> newFormList = nullsafeListTransform(this.formService.getFormsByAssessmentId(oldAssessmentId),
                ASSESSMENT_CHILD_COPY_XFORMER.getInstance(newAssessmentId));
        if (!CollectionUtils.isEmpty(newFormList)) {
            // populate map w/ old:new form IDs
            this.formService.saveFormList(newFormList);
            stuffEntriesIntoMap(oldNewKeyLookupMap, nullsafeListTransform(newFormList, ASSESSMENT_CHILD_KEYMAP_XFORMER));
        }
    }

    // form partition-------------------------------------------------------------------------------------------------------------------------------------------------------
    private void copyFormPartitionData(final Map<String, String> oldNewKeyLookupMap, final String oldAssessmentId, final String newAssessmentId) {
        final List<FormPartition> newFormPartitionList = nullsafeListTransform(this.formPartitionService.getFormPartitionsByAssessmentId(oldAssessmentId),
                ASSESSMENT_CHILD_COPY_XFORMER.getInstance(newAssessmentId));
        if (!CollectionUtils.isEmpty(newFormPartitionList)) {
            // utilize map of old:new form IDs, segment IDs
            List<FormPartition> updatedList = Lists.newArrayList();
            for (final FormPartition formPartition : newFormPartitionList) {
                formPartition.setFormId(findIdInTranslatorMap(oldNewKeyLookupMap, formPartition.getFormId()));
                formPartition.setSegmentId(findIdInTranslatorMap(oldNewKeyLookupMap, formPartition.getSegmentId()));
                updatedList.add(formPartition);
            }
            updatedList = this.formPartitionService.saveFormPartitionList(updatedList);
            // populate map w/ old:new form partition IDs
            stuffEntriesIntoMap(oldNewKeyLookupMap, nullsafeListTransform(updatedList, ASSESSMENT_CHILD_KEYMAP_XFORMER));
        }
    }

    // item group ----------------------------------------------------------------------------------------------------------------------------------------------------------
    private void copyItemGroupData(final Map<String, String> oldNewKeyLookupMap, final String oldAssessmentId, final String newAssessmentId) {
        final List<ItemGroup> newItemGroupList = nullsafeListTransform(this.itemGroupService.getItemGroupsByAssessment(oldAssessmentId),
                ASSESSMENT_CHILD_COPY_XFORMER.getInstance(newAssessmentId));
        if (!CollectionUtils.isEmpty(newItemGroupList)) {
            // utilize map of old:new form partition IDs, segment IDs
            List<ItemGroup> updatedList = Lists.newArrayList();
            for (final ItemGroup itemGroup : newItemGroupList) {
                itemGroup.setLocationId(findIdInTranslatorMap(oldNewKeyLookupMap, itemGroup.getLocationId()));
                updatedList.add(itemGroup);
            }
            updatedList = this.itemGroupService.saveItemGroupList(updatedList);
            // populate map w/ old:new item group IDs
            stuffEntriesIntoMap(oldNewKeyLookupMap, nullsafeListTransform(updatedList, ASSESSMENT_CHILD_KEYMAP_XFORMER));
        }
    }

    // item ----------------------------------------------------------------------------------------------------------------------------------------------------------------
    private void copyItemData(final Map<String, String> oldNewKeyLookupMap, final String oldAssessmentId, final String newAssessmentId) {
        final List<Item> newItemList = nullsafeListTransform(this.itemService.getItemsByAssessmentId(oldAssessmentId), ASSESSMENT_CHILD_COPY_XFORMER.getInstance(newAssessmentId));
        // utilize map of old:new item group IDs
        List<Item> updatedList = Lists.newArrayList();
        for (final Item item : newItemList) {
            // TODO - affinity group locations
            final List<ItemLocation> updatedItemLocationList = Lists.newArrayList();
            for (final ItemLocation itemLocation : item.getItemLocation()) {
                itemLocation.setItemGroupId(findIdInTranslatorMap(oldNewKeyLookupMap, itemLocation.getItemGroupId()));
                if (itemLocation instanceof AdaptiveItemLocation) {
                    itemLocation.setSegmentId(findIdInTranslatorMap(oldNewKeyLookupMap, itemLocation.getSegmentId()));
                } else if (itemLocation instanceof AffinityGroupItemLocation) {
                    itemLocation.setAffinityGroupId(findIdInTranslatorMap(oldNewKeyLookupMap, itemLocation.getAffinityGroupId()));
                } else {
                    itemLocation.setFormPartitionId(findIdInTranslatorMap(oldNewKeyLookupMap, itemLocation.getFormPartitionId()));
                }
                updatedItemLocationList.add(itemLocation);
            }
            item.setItemLocation(updatedItemLocationList);
            updatedList.add(item);
        }
        updatedList = this.itemService.saveItemList(updatedList);
        // populate map w/ old:new item IDs
        stuffEntriesIntoMap(oldNewKeyLookupMap, nullsafeListTransform(updatedList, ASSESSMENT_CHILD_KEYMAP_XFORMER));
    }

    // item metadata config ------------------------------------------------------------------------------------------------------------------------------------------------
    private void copyItemMetadataConfigData(final String oldAssessmentId, final String newAssessmentId) {
        final ItemMetadataConfig oldItemMetadataConfig = this.itemMetadataConfigService.getItemMetadataConfigByAssessment(oldAssessmentId);
        if (oldItemMetadataConfig != null) {
            final ItemMetadataConfig newItemMetadataConfig = new ItemMetadataConfig();
            newItemMetadataConfig.setId(null);
            newItemMetadataConfig.setAssessmentId(newAssessmentId);
            newItemMetadataConfig.setItemMetadataReckonSet(Sets.newHashSet(oldItemMetadataConfig.getItemMetadataReckonSet()));
            this.itemMetadataConfigService.saveItemMetadataConfig(newItemMetadataConfig);
        }
    }

    // item metadata keys __------------------------------------------------------------------------------------------------------------------------------------------------
    private void copyItemMetadataKeysData(final String oldAssessmentId, final String newAssessmentId) {
        final ItemMetadataKeys oldItemMetadataKeys = this.itemMetadataKeysRepository.findByAssessmentId(oldAssessmentId);
        if (oldItemMetadataKeys != null) {
            final ItemMetadataKeys newItemMetadataKeys = new ItemMetadataKeys();
            newItemMetadataKeys.setId(null);
            newItemMetadataKeys.setAssessmentId(newAssessmentId);
            newItemMetadataKeys.setItemMetadataKeys(Sets.newHashSet(oldItemMetadataKeys.getItemMetadataKeys()));
            this.itemMetadataKeysRepository.save(newItemMetadataKeys);
        }
    }

    // scoring rule --------------------------------------------------------------------------------------------------------------------------------------------------------
    private void copyScoringRuleData(final Map<String, String> oldNewKeyLookupMap, final String oldAssessmentId, final String newAssessmentId) {
        final List<ScoringRule> newScoringRuleList = nullsafeListTransform(this.scoringRuleService.getScoringRulesByAssessmentId(oldAssessmentId),
                ASSESSMENT_CHILD_COPY_XFORMER.getInstance(newAssessmentId));
        if (!CollectionUtils.isEmpty(newScoringRuleList)) {
            // utilize map of old:new blueprint IDs, affinityGroup IDs, segment IDs
            List<ScoringRule> updatedList = Lists.newArrayList();
            for (final ScoringRule scoringRule : newScoringRuleList) {
                scoringRule.setBlueprintReferenceId(findIdInTranslatorMap(oldNewKeyLookupMap, scoringRule.getBlueprintReferenceId()));
                updatedList.add(scoringRule);
            }
            updatedList = this.scoringRuleService.saveScoringRuleList(updatedList, false);
            // populate map w/ old:new scoring rule IDs
            stuffEntriesIntoMap(oldNewKeyLookupMap, nullsafeListTransform(updatedList, ASSESSMENT_CHILD_KEYMAP_XFORMER));
        }
    }

    // enemy ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    private void copyEnemyData(final Map<String, String> oldNewKeyLookupMap, final String oldAssessmentId, final String newAssessmentId) {
        final List<Enemy> newEnemyList = nullsafeListTransform(this.enemyService.getEnemiesByAssessmentId(oldAssessmentId), ASSESSMENT_CHILD_COPY_XFORMER.getInstance(newAssessmentId));
        if (!CollectionUtils.isEmpty(newEnemyList)) {
            // utilize map of old:new object (item/itemGroup) IDs
            final List<Enemy> updatedList = Lists.newArrayList();
            for (final Enemy enemy : newEnemyList) {
                enemy.setObjectId1(findIdInTranslatorMap(oldNewKeyLookupMap, enemy.getObjectId1()));
                enemy.setObjectId2(findIdInTranslatorMap(oldNewKeyLookupMap, enemy.getObjectId2()));
                updatedList.add(enemy);
            }
            this.enemyService.saveEnemyList(updatedList);
        }
    }

    // performance level ---------------------------------------------------------------------------------------------------------------------------------------------------
    private void copyPerformanceLevelData(final Map<String, String> oldNewKeyLookupMap, final String oldAssessmentId, final String newAssessmentId) {
        final List<PerformanceLevel> newPerformanceLevelList = nullsafeListTransform(this.performanceLevelService.getPerformanceLevelsByAssessmentId(oldAssessmentId),
                ASSESSMENT_CHILD_COPY_XFORMER.getInstance(newAssessmentId));
        if (!CollectionUtils.isEmpty(newPerformanceLevelList)) {
            // utilize map of old:new blueprint IDs, affinityGroup IDs, segment IDs
            final List<PerformanceLevel> updatedList = Lists.newArrayList();
            for (final PerformanceLevel performanceLevel : newPerformanceLevelList) {
                performanceLevel.setBlueprintReferenceId(findIdInTranslatorMap(oldNewKeyLookupMap, performanceLevel.getBlueprintReferenceId()));
                updatedList.add(performanceLevel);
            }
            this.performanceLevelService.savePerformanceLevelList(updatedList);
        }
    }

    // reporting measure ---------------------------------------------------------------------------------------------------------------------------------------------------
    private void copyReportingMeasureData(final Map<String, String> oldNewKeyLookupMap, final String oldAssessmentId, final String newAssessmentId) {
        final List<ReportingMeasure> newReportingMeasureList = nullsafeListTransform(this.reportingMeasureService.getReportingMeasuresByAssessmentId(oldAssessmentId),
                ASSESSMENT_CHILD_COPY_XFORMER.getInstance(newAssessmentId));
        if (!CollectionUtils.isEmpty(newReportingMeasureList)) {
            // utilize map of old:new blueprint IDs, affinityGroup IDs, segment IDs, scoring rule IDs
            final List<ReportingMeasure> updatedList = Lists.newArrayList();
            for (final ReportingMeasure reportingMeasure : newReportingMeasureList) {
                reportingMeasure.setBlueprintReferenceId(findIdInTranslatorMap(oldNewKeyLookupMap, reportingMeasure.getBlueprintReferenceId()));
                final List<String> newScoringRuleIdList = Lists.newArrayList();
                for (final String scoringRuleId : reportingMeasure.getScoringRuleIdList()) {
                    newScoringRuleIdList.add(findIdInTranslatorMap(oldNewKeyLookupMap, scoringRuleId));
                }
                reportingMeasure.setScoringRuleIdList(newScoringRuleIdList);
                updatedList.add(reportingMeasure);
            }
            this.reportingMeasureService.saveReportingMeasureList(updatedList);
        }
    }

    private String findIdInTranslatorMap(final Map<String, String> oldNewKeyLookupMap, final String idToFind) {
        return oldNewKeyLookupMap.get(idToFind) != null ? oldNewKeyLookupMap.get(idToFind) : idToFind;
    }

    private void stuffEntriesIntoMap(final Map<String, String> oldNewKeyLookupMap, final List<SimpleEntry<String, String>> entryList) {
        for (final SimpleEntry<String, String> simpleEntry : entryList) {
            oldNewKeyLookupMap.put(simpleEntry.getKey(), simpleEntry.getValue());
        }
    }
}
