/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.integration;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.not;
import static org.hamcrest.CoreMatchers.notNullValue;
import static org.hamcrest.CoreMatchers.nullValue;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.Assert.fail;

import java.util.List;
import java.util.Map;

import javax.validation.ConstraintViolationException;

import org.junit.Test;
import org.opentestsystem.authoring.testauth.domain.ComputationRule;
import org.opentestsystem.authoring.testauth.domain.ComputationRuleMultiplicityType;
import org.opentestsystem.authoring.testauth.domain.ComputationRuleParameter;
import org.opentestsystem.authoring.testauth.domain.ComputationRuleType;
import org.opentestsystem.authoring.testauth.rest.AbstractRestEmbeddedMongoTest;
import org.opentestsystem.authoring.testauth.service.ComputationRuleService;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.springframework.beans.factory.annotation.Autowired;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;

public class ComputationRuleServiceTest extends AbstractRestEmbeddedMongoTest {

    @Autowired
    private ComputationRuleService computationRuleService;

    @Test
    public void saveNewComputationRuleTest() {
        final ComputationRule computationRuleToSave = manufactureValidComputationRule();
        computationRuleToSave.setId(null);
        final ComputationRule savedComputationRule = this.computationRuleService.createComputationRule(computationRuleToSave);
        assertThat(savedComputationRule, is(notNullValue()));
        final ComputationRule retrievedComputationRule = this.computationRuleService.getComputationRule(savedComputationRule.getId());
        assertThat(retrievedComputationRule, is(notNullValue()));
    }

    @Test
    public void saveExistingComputationRuleTest() {
        final ComputationRule computationRuleToSave = manufactureValidComputationRule();
        computationRuleToSave.setId(null);
        final ComputationRule savedComputationRule = this.computationRuleService.createComputationRule(computationRuleToSave);
        assertThat(savedComputationRule, is(notNullValue()));
        final ComputationRule retrievedComputationRule = this.computationRuleService.getComputationRule(savedComputationRule.getId());
        assertThat(retrievedComputationRule, is(notNullValue()));
        retrievedComputationRule.setDescription("changedDescription");
        final ComputationRule resavedComputationRule = this.computationRuleService.updateComputationRule(retrievedComputationRule);
        assertThat(resavedComputationRule, is(notNullValue()));
        assertThat(resavedComputationRule.getDescription(), is(equalTo("changedDescription")));
    }

    @Test
    public void saveNonUniqueComputationRuleTest() {
        final ComputationRule computationRuleToSave = manufactureValidComputationRule();
        computationRuleToSave.setId(null);
        final ComputationRule savedComputationRule = this.computationRuleService.createComputationRule(computationRuleToSave);
        assertThat(savedComputationRule, is(notNullValue()));

        final ComputationRule newComputationRule = manufactureValidComputationRule();
        newComputationRule.setId(null);
        newComputationRule.setName(savedComputationRule.getName());
        newComputationRule.setVersion(savedComputationRule.getVersion());

        try {
            this.computationRuleService.createComputationRule(newComputationRule);
            fail("should have thrown exception");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("computationRule.already.exists"));
        }
    }

    @Test
    public void saveComputationRuleWithoutParametersTest() {
        final ComputationRule computationRuleToSave = manufactureValidComputationRule();
        computationRuleToSave.setId(null);
        computationRuleToSave.getParameters().clear();

        final ComputationRule savedComputationRule = this.computationRuleService.createComputationRule(computationRuleToSave);
        assertThat(savedComputationRule, is(notNullValue()));
        final ComputationRule retrievedComputationRule = this.computationRuleService.getComputationRule(savedComputationRule.getId());
        assertThat(retrievedComputationRule, is(notNullValue()));
    }

    @Test
    public void saveComputationRuleWithMissingFieldsTest() {
        final ComputationRule computationRuleToSave = manufactureValidComputationRule();
        computationRuleToSave.setId(null);
        computationRuleToSave.setName(null); // NotBlank
        computationRuleToSave.setVersion(""); // NotBlank
        computationRuleToSave.setConversionTableType(null); // NotNull
        computationRuleToSave.setParameters(null); // NotNull
        try {
            this.computationRuleService.createComputationRule(computationRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(3));
            assertThat(getConstraintViolation(e, "NotBlank").size(), is(2));
            assertThat(getConstraintViolation(e, "NotNull").size(), is(1));
        }
    }

    @Test
    public void saveComputationRuleWithDuplicateParametersTest() {
        final ComputationRule computationRuleToSave = manufactureValidComputationRule();
        computationRuleToSave.setId(null);
        computationRuleToSave.getParameters().clear();

        final List<ComputationRuleParameter> params = manufactureValidComputationRuleParameter(5);
        params.get(0).setParameterName("name1");
        params.get(1).setParameterName("nameX");
        params.get(2).setParameterName("name1");
        params.get(3).setParameterName("name2");
        params.get(4).setParameterName("name2");

        computationRuleToSave.getParameters().clear();
        computationRuleToSave.getParameters().addAll(params);

        try {
            this.computationRuleService.createComputationRule(computationRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "computationRule.parameters.parameterName.duplicates").size(), is(1));
        }
    }

    @Test
    public void saveComputationRuleWithDuplicateParameterPositionsTest() {
        final ComputationRule computationRuleToSave = manufactureValidComputationRule();
        computationRuleToSave.setId(null);
        computationRuleToSave.getParameters().clear();

        final List<ComputationRuleParameter> params = manufactureValidComputationRuleParameter(5);
        params.get(4).setPosition(4);

        computationRuleToSave.getParameters().clear();
        computationRuleToSave.getParameters().addAll(params);

        try {
            this.computationRuleService.createComputationRule(computationRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "computationRule.parameters.position.duplicates").size(), is(1));
        }
    }

    @Test
    public void saveComputationRuleWithInvalidParameterPositionTest() {
        final ComputationRule computationRuleToSave = manufactureValidComputationRule();
        computationRuleToSave.setId(null);
        computationRuleToSave.getParameters().clear();

        final List<ComputationRuleParameter> params = manufactureValidComputationRuleParameter(5);
        params.get(4).setPosition(44);

        computationRuleToSave.getParameters().clear();
        computationRuleToSave.getParameters().addAll(params);

        try {
            this.computationRuleService.createComputationRule(computationRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "computationRule.parameters.position.invalid").size(), is(1));
        }
    }

    @Test
    public void saveComputationRuleWithIncompleteParametersTest() {
        final ComputationRule computationRuleToSave = manufactureValidComputationRule();
        computationRuleToSave.setId(null);
        computationRuleToSave.getParameters().clear();

        computationRuleToSave.getParameters().add(new ComputationRuleParameter());
        try {
            this.computationRuleService.createComputationRule(computationRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(4));
            assertThat(getConstraintViolation(e, "NotNull").size(), is(2));
            assertThat(getConstraintViolation(e, "NotBlank").size(), is(1));
            assertThat(getConstraintViolation(e, "Min").size(), is(1));
        }
    }

    @Test
    public void saveComputationRuleWithIncompleteIntegerParametersTest() {
        final ComputationRule computationRuleToSave = manufactureValidComputationRule();
        computationRuleToSave.setId(null);
        computationRuleToSave.getParameters().clear();

        final ComputationRuleParameter param1 = manufactureValidComputationRuleParameter();
        param1.setComputationRuleType(ComputationRuleType.INTEGER);
        param1.setDefaultValue(null);
        param1.setMinimumValue("");
        param1.setMaximumValue(null);
        computationRuleToSave.getParameters().add(param1);

        final ComputationRule savedComputationRule = this.computationRuleService.createComputationRule(computationRuleToSave);
        assertThat(savedComputationRule, is(notNullValue()));
        final ComputationRule retrievedComputationRule = this.computationRuleService.getComputationRule(savedComputationRule.getId());
        assertThat(retrievedComputationRule, is(notNullValue()));
    }

    @Test
    public void saveComputationRuleWithUnparseableIntegerParametersTest() {
        final ComputationRule computationRuleToSave = manufactureValidComputationRule();
        computationRuleToSave.setId(null);
        computationRuleToSave.getParameters().clear();

        final ComputationRuleParameter param1 = manufactureValidComputationRuleParameter();
        param1.setComputationRuleType(ComputationRuleType.INTEGER);
        param1.setDefaultValue("abc");
        param1.setMinimumValue("11.45");
        param1.setMaximumValue("1.2");
        computationRuleToSave.getParameters().add(param1);
        try {
            this.computationRuleService.createComputationRule(computationRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(3));
            assertThat(getConstraintViolation(e, "computationRule.parameters.defaultValue.parseable.number").size(), is(1));
            assertThat(getConstraintViolation(e, "computationRule.parameters.minimumValue.parseable.number").size(), is(1));
            assertThat(getConstraintViolation(e, "computationRule.parameters.maximumValue.parseable.number").size(), is(1));
        }
    }

    @Test
    public void saveComputationRuleWithUnparseableFloatParametersTest() {
        final ComputationRule computationRuleToSave = manufactureValidComputationRule();
        computationRuleToSave.setId(null);
        computationRuleToSave.getParameters().clear();

        final ComputationRuleParameter param1 = manufactureValidComputationRuleParameter();
        param1.setComputationRuleType(ComputationRuleType.FLOAT);
        param1.setDefaultValue("abc");
        param1.setMinimumValue("1.3a4");
        param1.setMaximumValue("1.a");
        computationRuleToSave.getParameters().add(param1);
        try {
            this.computationRuleService.createComputationRule(computationRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(3));
            assertThat(getConstraintViolation(e, "computationRule.parameters.defaultValue.parseable.number").size(), is(1));
            assertThat(getConstraintViolation(e, "computationRule.parameters.minimumValue.parseable.number").size(), is(1));
            assertThat(getConstraintViolation(e, "computationRule.parameters.maximumValue.parseable.number").size(), is(1));
        }
    }

    @Test
    public void saveComputationRuleWithInvalidStringParametersTest() {
        final ComputationRule computationRuleToSave = manufactureValidComputationRule();
        computationRuleToSave.setId(null);
        computationRuleToSave.getParameters().clear();

        final ComputationRuleParameter param1 = manufactureValidComputationRuleParameter();
        param1.setComputationRuleType(ComputationRuleType.STRING);
        param1.setDefaultValue("1");
        param1.setMinimumValue("2");
        param1.setMaximumValue("3");
        computationRuleToSave.getParameters().add(param1);
        try {
            this.computationRuleService.createComputationRule(computationRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(2));
            assertThat(getConstraintViolation(e, "computationRule.parameters.minimumValue.required.empty").size(), is(1));
            assertThat(getConstraintViolation(e, "computationRule.parameters.maximumValue.required.empty").size(), is(1));
        }
    }

    @Test
    public void saveComputationRuleWithInvalidBooleanParametersTest() {
        final ComputationRule computationRuleToSave = manufactureValidComputationRule();
        computationRuleToSave.setId(null);
        computationRuleToSave.getParameters().clear();

        final ComputationRuleParameter param1 = manufactureValidComputationRuleParameter();
        param1.setComputationRuleType(ComputationRuleType.BOOLEAN);
        param1.setDefaultValue("1");
        computationRuleToSave.getParameters().add(param1);
        try {
            this.computationRuleService.createComputationRule(computationRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "computationRule.parameters.defaultValue.parseable.boolean").size(), is(1));
        }
    }

    @Test
    public void saveComputationRuleWithIntegerMinNotLessThanMaxParametersTest() {
        final ComputationRule computationRuleToSave = manufactureValidComputationRule();
        computationRuleToSave.setId(null);
        computationRuleToSave.getParameters().clear();

        final ComputationRuleParameter param1 = manufactureValidComputationRuleParameter();
        param1.setComputationRuleType(ComputationRuleType.INTEGER);
        param1.setDefaultValue("12");
        param1.setMinimumValue("12");
        param1.setMaximumValue("12");
        computationRuleToSave.getParameters().add(param1);
        try {
            this.computationRuleService.createComputationRule(computationRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "computationRule.parameters.minimumValue.lessthan.max").size(), is(1));
        }
    }

    @Test
    public void saveComputationRuleWithIntegerDefaultNotInMinMaxRangeParametersTest() {
        final ComputationRule computationRuleToSave = manufactureValidComputationRule();
        computationRuleToSave.setId(null);
        computationRuleToSave.getParameters().clear();

        final ComputationRuleParameter param1 = manufactureValidComputationRuleParameter();
        param1.setComputationRuleType(ComputationRuleType.INTEGER);
        param1.setDefaultValue("13");
        param1.setMinimumValue("1");
        param1.setMaximumValue("12");
        computationRuleToSave.getParameters().add(param1);
        try {
            this.computationRuleService.createComputationRule(computationRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "computationRule.parameters.defaultValue.within.minmax").size(), is(1));
        }
    }

    @Test
    public void saveComputationRuleWithIntegerLargeDefaultNotInMinMaxRangeParametersTest() {
        final ComputationRule computationRuleToSave = manufactureValidComputationRule();
        computationRuleToSave.setId(null);
        computationRuleToSave.getParameters().clear();

        final ComputationRuleParameter param1 = manufactureValidComputationRuleParameter();
        param1.setComputationRuleType(ComputationRuleType.INTEGER);
        param1.setDefaultValue("2147483647");
        param1.setMinimumValue("1");
        param1.setMaximumValue("2147483646");
        computationRuleToSave.getParameters().add(param1);
        try {
            this.computationRuleService.createComputationRule(computationRuleToSave);
            fail("should have thrown exception");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(1));
            assertThat(getConstraintViolation(e, "computationRule.parameters.defaultValue.within.minmax").size(), is(1));
        }
    }

    @Test
    public void deleteComputationRuleTest() {
        final ComputationRule computationRuleToSave = manufactureValidComputationRule();
        computationRuleToSave.setId(null);
        final ComputationRule savedComputationRule = this.computationRuleService.createComputationRule(computationRuleToSave);
        assertThat(savedComputationRule, is(notNullValue()));
        final ComputationRule retrievedComputationRule = this.computationRuleService.getComputationRule(savedComputationRule.getId());
        assertThat(retrievedComputationRule, is(notNullValue()));

        this.computationRuleService.removeComputationRule(retrievedComputationRule.getId());
        final ComputationRule reRetrievedComputationRule = this.computationRuleService.getComputationRule(savedComputationRule.getId());
        assertThat(reRetrievedComputationRule, is(nullValue()));
    }

    @Test
    public void getComputationRule() {
        final ComputationRule computationRuleToSave = manufactureValidComputationRule();
        computationRuleToSave.setId(null);
        final ComputationRule savedComputationRule = this.computationRuleService.createComputationRule(computationRuleToSave);
        assertThat(savedComputationRule, is(not(nullValue())));

        assertThat(this.computationRuleService.getComputationRule(savedComputationRule.getId()), is(not(nullValue())));
        assertThat(this.computationRuleService.getComputationRule("invalid-id"), is(nullValue()));
    }

    @Test
    public void searchComputationRules() {
        final ComputationRule computationRuleToSave = manufactureValidComputationRule();
        computationRuleToSave.setId(null);
        final ComputationRule savedComputationRule = this.computationRuleService.createComputationRule(computationRuleToSave);
        assertThat(savedComputationRule, is(not(nullValue())));

        final ComputationRule computationRuleToSave2 = manufactureValidComputationRule();
        computationRuleToSave2.setId(null);
        final ComputationRule savedComputationRule2 = this.computationRuleService.createComputationRule(computationRuleToSave2);
        assertThat(savedComputationRule2, is(not(nullValue())));

        final Map<String, String[]> params = ImmutableMap.of("name", new String[] { savedComputationRule.getName() });
        final SearchResponse<ComputationRule> searchResponse = this.computationRuleService.searchComputationRules(params);
        assertThat(searchResponse.getReturnCount(), is(1));
        assertThat(searchResponse.getSearchResults().size(), is(1));
    }

    private ComputationRule manufactureValidComputationRule() {
        final ComputationRule computationRule = PODAM_FACTORY.manufacturePojo(ComputationRule.class);
        computationRule.getParameters().clear();
        computationRule.getParameters().add(manufactureValidComputationRuleParameter());
        computationRule.setVersion("1.0");
        return computationRule;
    }

    private ComputationRuleParameter manufactureValidComputationRuleParameter() {
        return manufactureValidComputationRuleParameter(1).get(0);
    }

    private List<ComputationRuleParameter> manufactureValidComputationRuleParameter(final int position) {
        final List<ComputationRuleParameter> computationRuleParameterList = Lists.newArrayList();
        for (int i = 0; i < position; i++) {
            final ComputationRuleParameter parameter = new ComputationRuleParameter();
            parameter.setParameterName("parameter" + String.valueOf(i + 1));
            parameter.setComputationRuleType(ComputationRuleType.STRING);
            parameter.setDefaultValue("defaultValue" + String.valueOf(i + 1));
            parameter.setComputationRuleMultiplicityType(ComputationRuleMultiplicityType.SCALAR);
            parameter.setPosition(i + 1);
            computationRuleParameterList.add(parameter);
        }
        return computationRuleParameterList;
    }
}
