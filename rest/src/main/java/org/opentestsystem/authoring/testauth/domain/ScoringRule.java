/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.domain;

import java.io.Serializable;
import java.util.List;

import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;

import org.hibernate.validator.constraints.NotBlank;
import org.springframework.data.annotation.Transient;
import org.springframework.data.mongodb.core.index.CompoundIndex;
import org.springframework.data.mongodb.core.index.CompoundIndexes;
import org.springframework.data.mongodb.core.mapping.Document;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@Document
@JsonIgnoreProperties(ignoreUnknown = true)
@CompoundIndexes(value = {
        @CompoundIndex(name = ScoringRule.ORDER_INDEX_NAME, def = "{'assessmentId':1, 'order':1}", unique = true),
        @CompoundIndex(name = ScoringRule.LABEL_INDEX_NAME, def = "{'assessmentId':1, 'label':1}", unique = true)
})
public class ScoringRule extends AssessmentChild implements Serializable, TenantedByAssessment {

    public static final String ORDER_INDEX_NAME = "scoringRule_order_indx";
    public static final String LABEL_INDEX_NAME = "scoringRule_label_indx";

    private static final long serialVersionUID = 1693202958911228485L;

    @NotNull(message = "scoringRule.order.required")
    @Min(value = 1, message = "scoringRule.order.min")
    private Integer order;

    // contents of this scoring rule must adhere to the ComputationRule from which it derives
    @NotBlank(message = "scoringRule.computationRuleId.required")
    private String computationRuleId;

    @NotBlank(message = "scoringRule.label.required")
    private String label;

    // indicating Assessment, Segment, AffinityGroup, or Standard Key
    @NotNull(message = "blueprintReferenceType.required")
    private BlueprintReferenceType blueprintReferenceType;

    private BlueprintDenotationType blueprintDenotationType;

    // value can be assessment.id, segment.id, affinityGroup.id, blueprintElement.id, or empty
    private String blueprintReferenceId;

    // CSV file gridFs ID
    private String valueConversionTableGridFsId;

    // CSV file gridFs ID
    private String standardErrorConversionTableGridFsId;

    // ComputationRule.parameter[#].name = ComputationRuleParameter.computationRuleParameterName
    // ComputationRule.parameter[#].computationRuleMultiplicityType = ComputationRuleParameter.computationRuleParameterMultiplicity
    // if multiplicity = scalar: ScoringRuleParameter.scalarValue is required
    // if multiplicity = dictionary: ScoringRuleParameter.dictionaryValue is required
    // ScoringRuleParameter.dictionaryValue.key data type is defined by ComputationRule.parameter[#].dictionaryIndexType (integer or string)
    // ScoringRuleParameter.scalarValue & ScoringRuleParameter.dictionaryValue.value data type are defined by
    // ComputationRule.parameter[#].computationRuleType (if integer/float, default/min/max constraints apply)
    private List<ScoringRuleParameter> parameters;

    @Transient
    private transient ComputationRule computationRule;

    @Transient
    private transient String blueprintReferenceName;

    // CSV file uploads
    @Transient
    private transient String valueConversionTableFilename;

    // CSV file upload
    @Transient
    private transient String standardErrorConversionTableFilename;

    public Integer getOrder() {
        return this.order;
    }

    public void setOrder(final Integer anOrder) {
        this.order = anOrder;
    }

    public String getComputationRuleId() {
        return this.computationRuleId;
    }

    public void setComputationRuleId(final String aComputationRuleId) {
        this.computationRuleId = aComputationRuleId;
    }

    public String getLabel() {
        return this.label;
    }

    public void setLabel(final String aLabel) {
        this.label = aLabel;
    }

    public BlueprintReferenceType getBlueprintReferenceType() {
        return this.blueprintReferenceType;
    }

    public void setBlueprintReferenceType(final BlueprintReferenceType aBlueprintReferenceType) {
        this.blueprintReferenceType = aBlueprintReferenceType;
    }

    public String getBlueprintReferenceId() {
        return this.blueprintReferenceId;
    }

    public void setBlueprintReferenceId(final String aBlueprintReferenceId) {
        this.blueprintReferenceId = aBlueprintReferenceId;
    }

    public BlueprintDenotationType getBlueprintDenotationType() {
        return this.blueprintDenotationType;
    }

    public void setBlueprintDenotationType(final BlueprintDenotationType blueprintDenotationType) {
        this.blueprintDenotationType = blueprintDenotationType;
    }

    public String getValueConversionTableGridFsId() {
        return this.valueConversionTableGridFsId;
    }

    public void setValueConversionTableGridFsId(final String aValueConversionTableGridFsId) {
        this.valueConversionTableGridFsId = aValueConversionTableGridFsId;
    }

    public String getStandardErrorConversionTableGridFsId() {
        return this.standardErrorConversionTableGridFsId;
    }

    public void setStandardErrorConversionTableGridFsId(final String aStandardErrorConversionTableGridFsId) {
        this.standardErrorConversionTableGridFsId = aStandardErrorConversionTableGridFsId;
    }

    public List<ScoringRuleParameter> getParameters() {
        return this.parameters;
    }

    public void setParameters(final List<ScoringRuleParameter> parameterList) {
        this.parameters = parameterList;
    }

    public ComputationRule getComputationRule() {
        return this.computationRule;
    }

    public void setComputationRule(final ComputationRule computationRule) {
        this.computationRule = computationRule;
    }

    public String getBlueprintReferenceName() {
        return this.blueprintReferenceName;
    }

    public void setBlueprintReferenceName(final String aBlueprintReferenceName) {
        this.blueprintReferenceName = aBlueprintReferenceName;
    }

    public String getValueConversionTableFilename() {
        return this.valueConversionTableFilename;
    }

    public void setValueConversionTableFilename(final String aValueConversionTableFilename) {
        this.valueConversionTableFilename = aValueConversionTableFilename;
    }

    public String getStandardErrorConversionTableFilename() {
        return this.standardErrorConversionTableFilename;
    }

    public void setStandardErrorConversionTableFilename(final String aStandardErrorConversionTableFilename) {
        this.standardErrorConversionTableFilename = aStandardErrorConversionTableFilename;
    }
}
