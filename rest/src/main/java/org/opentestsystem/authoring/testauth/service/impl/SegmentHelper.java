/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.service.impl;

import java.util.List;
import java.util.Map;

import org.opentestsystem.authoring.testauth.domain.Segment;

import com.google.common.base.Function;
import com.google.common.base.Predicate;
import com.google.common.collect.Maps;

public final class SegmentHelper {

    private SegmentHelper() {
        // do not instantiate
    }

    protected static final class SEGMENT_POSITION_TRANSFORMER implements Function<Segment, Segment> {
        private final String modifiedSegmentId;
        private final Integer newSegmentPosition;
        private final Integer previousSegmentPosition;

        public static SEGMENT_POSITION_TRANSFORMER getInstance(final String modifiedSegmentId, final Integer newSegmentPosition, final Integer previousSegmentPosition) {
            return new SEGMENT_POSITION_TRANSFORMER(modifiedSegmentId, newSegmentPosition, previousSegmentPosition);
        }

        private SEGMENT_POSITION_TRANSFORMER(final String modifiedSegmentId, final Integer newSegmentPosition, final Integer previousSegmentPosition) {
            this.modifiedSegmentId = modifiedSegmentId;
            this.newSegmentPosition = newSegmentPosition;
            this.previousSegmentPosition = previousSegmentPosition;
        }

        @Override
        public Segment apply(final Segment segment) {
            if (segment.getId().equals(this.modifiedSegmentId)) {
                segment.setPosition(this.newSegmentPosition);
                return segment;
            }

            if (this.newSegmentPosition < this.previousSegmentPosition) {
                if (segment.getPosition() >= this.newSegmentPosition && segment.getPosition() <= this.previousSegmentPosition) {
                    segment.setPosition(segment.getPosition() + 1);
                    return segment;
                }
            } else {
                if (segment.getPosition() >= this.previousSegmentPosition && segment.getPosition() <= this.newSegmentPosition) {
                    segment.setPosition(segment.getPosition() - 1);
                    return segment;
                }
            }

            return null;
        }
    };

    protected static final Predicate<Segment> SEGMENT_NOTNULL_FILTER = new Predicate<Segment>() {
        @Override
        public boolean apply(final Segment input) {
            return input != null;
        }
    };

    protected static Map<String, Segment> createSegmentIdKeyMap(final List<Segment> segmentList) {
        return Maps.uniqueIndex(segmentList, new Function<Segment, String>() {
            @Override
            public String apply(final Segment input) {
                return input.getId();
            }
        });
    }
}
