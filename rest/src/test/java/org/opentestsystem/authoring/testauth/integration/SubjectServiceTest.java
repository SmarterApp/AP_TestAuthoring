/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.integration;

import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.not;
import static org.hamcrest.CoreMatchers.nullValue;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.Assert.fail;

import java.util.Map;

import javax.validation.ConstraintViolationException;

import org.junit.Test;
import org.opentestsystem.authoring.testauth.domain.Assessment;
import org.opentestsystem.authoring.testauth.domain.DomainFactory;
import org.opentestsystem.authoring.testauth.domain.Publication;
import org.opentestsystem.authoring.testauth.domain.Subject;
import org.opentestsystem.authoring.testauth.domain.search.SubjectSearchRequest;
import org.opentestsystem.authoring.testauth.rest.AbstractRestEmbeddedMongoTest;
import org.opentestsystem.authoring.testauth.service.AssessmentService;
import org.opentestsystem.authoring.testauth.service.PublicationService;
import org.opentestsystem.authoring.testauth.service.SubjectService;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.springframework.beans.factory.annotation.Autowired;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;

public class SubjectServiceTest extends AbstractRestEmbeddedMongoTest {

    @Autowired
    private SubjectService subjectService;

    @Autowired
    private PublicationService publicationService;

    @Autowired
    private AssessmentService assessmentService;

    @Test
    public void saveSubject() {
        final Subject subject = new Subject("name", "abb", "tenant1", "description");
        final Subject savedSubject = this.subjectService.saveSubject(subject);
        assertThat(savedSubject.getId(), is(not(nullValue())));
    }

    @Test
    public void updateSubjectAssignedToAssessment() {
        final Subject savedSubject = this.subjectService.saveSubject(DomainFactory.manufactureValidSubject("ABB"));
        final Publication savedPublication = this.publicationService.savePublication(DomainFactory.manufactureValidPublication(savedSubject.getTenantId(), ImmutableSet.of(savedSubject)));
        final Assessment assessment = DomainFactory.manufactureValidAssessment(savedSubject, savedPublication);
        assessment.setTenantId(savedSubject.getTenantId());
        this.assessmentService.saveAssessment(assessment);

        savedSubject.setName("new-name");
        try {
            this.subjectService.saveSubject(savedSubject);
            fail("should throw exception");
        } catch (final Exception e) {
            assertThat(e.getMessage(), is("subject.on.assessment"));
        }
    }

    @Test
    public void updateSubjectTenantAssignedToPublication() {
        final Subject savedSubject = this.subjectService.saveSubject(DomainFactory.manufactureValidSubject("ABB"));
        this.publicationService.savePublication(DomainFactory.manufactureValidPublication(savedSubject.getTenantId(), ImmutableSet.of(savedSubject)));

        savedSubject.setTenantId("new-tenant-id");
        try {
            this.subjectService.saveSubject(savedSubject);
            fail("should throw exception");
        } catch (final Exception e) {
            assertThat(e.getMessage(), is("subject.on.publication"));
        }
    }

    @Test
    public void saveDuplicateSubjects() {
        final Subject subject = new Subject("name", "abb", "tenant1", "description");
        this.subjectService.saveSubject(subject);

        final Subject subject2 = new Subject("name", "abb", "tenant1", "description2");
        try {
            this.subjectService.saveSubject(subject2);
            fail("DuplicateKeyException should be thrown");
        } catch (final Exception e) {
            // expected behavior
        }

        final Subject subject3 = new Subject("name", "ab2", "tenant1", "description2");
        try {
            this.subjectService.saveSubject(subject3);
            fail("DuplicateKeyException should be thrown");
        } catch (final Exception e) {
            // expected behavior
        }

        final Subject subject4 = new Subject("name2", "abb", "tenant1", "description2");
        try {
            this.subjectService.saveSubject(subject4);
            fail("DuplicateKeyException should be thrown");
        } catch (final Exception e) {
            // expected behavior
        }

        final Subject subject5 = new Subject("name", "abb", "tenant2", "description2");
        try {
            this.subjectService.saveSubject(subject5);
        } catch (final Exception e) {
            fail("DuplicateKeyException should NOT be thrown because subject is in different tenant");
        }
    }

    @Test
    public void retireSubject() {
        final Subject subject = new Subject("name", "abb", "tenant1", "description");
        final Subject savedSubject = this.subjectService.saveSubject(subject);

        final Subject retiredSubject = this.subjectService.retireSubject(savedSubject.getId(), false);
        assertThat(retiredSubject.isInactive(), is(true));
    }

    @Test
    public void restoreSubject() {
        final Subject subject = new Subject("name", "abb", "tenant1", "description");
        final Subject savedSubject = this.subjectService.saveSubject(subject);

        final Subject retiredSubject = this.subjectService.retireSubject(savedSubject.getId(), false);
        assertThat(retiredSubject.isInactive(), is(true));

        final Subject unretiredSubject = this.subjectService.retireSubject(savedSubject.getId(), true);
        assertThat(unretiredSubject.isInactive(), is(false));
    }

    @Test
    public void saveInvalidSubject() {
        final Subject subject = new Subject("name", "abbreviation", "tenant1", "description");
        try {
            this.subjectService.saveSubject(subject);
            fail("Abbreviation size exception should be thrown");
        } catch (final Exception e) {
            // expected behavior
        }

        final Subject subject2 = new Subject("name", "a", "tenant1", "description");
        try {
            this.subjectService.saveSubject(subject2);
        } catch (final Exception e) {
            fail("Abbreviation size exception should NOT be thrown");
        }
    }

    @Test
    public void saveInvalidSubjectAbbreviation() {
        final Subject subject = new Subject("name", "A B", "tenant1", "description");
        try {
            this.subjectService.saveSubject(subject);
            fail("Abbreviation alphanumeric exception should be thrown");
        } catch (final ConstraintViolationException e) {
            // expected behavior
        }

        subject.setAbbreviation("12 ");
        try {
            this.subjectService.saveSubject(subject);
            fail("Abbreviation alphanumeric exception should be thrown");
        } catch (final ConstraintViolationException e) {
            // expected behavior
        }

        subject.setAbbreviation("1*2");
        try {
            this.subjectService.saveSubject(subject);
            fail("Abbreviation alphanumeric exception should be thrown");
        } catch (final ConstraintViolationException e) {
            // expected behavior
        }

        subject.setAbbreviation("A12");
        assertThat(this.subjectService.saveSubject(subject), is(not(nullValue())));
    }

    @Test
    public void getSubject() {
        Subject subject = new Subject("name1", "ab1", "tenant1", "description1");
        subject = this.subjectService.saveSubject(subject);
        assertThat(subject, is(not(nullValue())));

        Subject anotherSubject = new Subject("name2", "ab2", "tenant1", "description2");
        anotherSubject = this.subjectService.saveSubject(anotherSubject);
        assertThat(anotherSubject, is(not(nullValue())));

        final Subject foundSubject = this.subjectService.getSubject(anotherSubject.getId());
        assertThat(foundSubject, is(not(nullValue())));
        assertThat(foundSubject.getId(), is(anotherSubject.getId()));
        assertThat(foundSubject.getName(), is("name2"));
    }

    @Test
    public void deleteSubject() {
        Subject subject = new Subject("name1", "ab1", "tenant1", "description1");
        subject = this.subjectService.saveSubject(subject);
        assertThat(subject, is(not(nullValue())));

        Subject anotherSubject = new Subject("name2", "ab2", "tenant1", "description2");
        anotherSubject = this.subjectService.saveSubject(anotherSubject);
        assertThat(anotherSubject, is(not(nullValue())));

        final Map<String, String[]> params = ImmutableMap.of("name", new String[] { "" }, "inactive", new String[] { "false" });
        final SubjectSearchRequest searchRequest = new SubjectSearchRequest(params);
        SearchResponse<Subject> searchResponse = this.subjectService.searchSubjects(searchRequest);

        assertThat(searchResponse.getSearchResults().size(), is(2));
        subject.setInactive(true);
        this.subjectService.saveSubject(subject);
        searchResponse = this.subjectService.searchSubjects(searchRequest);
        assertThat(searchResponse.getSearchResults().size(), is(1));
        assertThat(subject.isInactive(), is(true));
        assertThat(this.subjectService.getSubject(subject.getId()), is(subject));
    }

    @Test
    public void searchSubjects() {
        Subject subject = new Subject("name1", "ab1", "tenant1", "description1");
        subject = this.subjectService.saveSubject(subject);
        assertThat(subject, is(not(nullValue())));

        Subject anotherSubject = new Subject("name2", "ab2", "tenant1", "description2");
        anotherSubject = this.subjectService.saveSubject(anotherSubject);
        assertThat(anotherSubject, is(not(nullValue())));

        final Map<String, String[]> params = ImmutableMap.of("name", new String[] { "name1" });
        final SubjectSearchRequest searchRequest = new SubjectSearchRequest(params);
        final SearchResponse<Subject> searchResponse = this.subjectService.searchSubjects(searchRequest);
        assertThat(searchResponse.getReturnCount(), is(1));
    }
}
