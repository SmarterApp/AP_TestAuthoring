/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.validation;

import java.math.BigDecimal;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.authoring.testauth.domain.ComputationRuleMultiplicityType;
import org.opentestsystem.authoring.testauth.domain.ComputationRuleParameter;
import org.opentestsystem.authoring.testauth.domain.ComputationRuleType;
import org.springframework.stereotype.Component;
import org.springframework.validation.Errors;

@Component
public class ComputationRuleParameterValidator extends AbstractDomainValidator {
    private static final String COMPUTATION_RULE_ROOT = "computationRule.parameters.";
    private static final String DEFAULT = "defaultValue";
    private static final String MINIMUM = "minimumValue";
    private static final String MAXIMUM = "maximumValue";
    private static final String COMPUTATION_RULE_TYPE = "computationRuleType";
    private static final String DICTIONARY_INDEX_TYPE = "dictionaryIndexType";

    @Override
    public boolean supports(final Class<?> clazz) {
        return ComputationRuleParameter.class.equals(clazz);
    }

    @Override
    public void validate(final Object obj, final Errors errors) {
        final ComputationRuleParameter parameter = (ComputationRuleParameter) obj;
        if (parameter.getComputationRuleType() != null) {
            final Object[] errorArgs = new String[] { parameter.getComputationRuleType().name(), parameter.getParameterName() };
            switch (parameter.getComputationRuleType()) {
            case FLOAT:
            case INTEGER:
                final boolean isFloat = parameter.getComputationRuleType() == ComputationRuleType.FLOAT;
                rejectIfNotFloatOrIntegerParseable(errors, DEFAULT, isFloat, errorArgs);
                rejectIfNotFloatOrIntegerParseable(errors, MINIMUM, isFloat, errorArgs);
                rejectIfNotFloatOrIntegerParseable(errors, MAXIMUM, isFloat, errorArgs);
                if (!errors.hasErrors()) {
                    boolean compareDefaultToMinMax = true;
                    final BigDecimal minimumBigDecimal = StringUtils.isNotBlank(parameter.getMinimumValue()) ? new BigDecimal(parameter.getMinimumValue()) : null;
                    final BigDecimal maximumBigDecimal = StringUtils.isNotBlank(parameter.getMaximumValue()) ? new BigDecimal(parameter.getMaximumValue()) : null;
                    final BigDecimal defaultBigDecimal = StringUtils.isNotBlank(parameter.getDefaultValue()) ? new BigDecimal(parameter.getDefaultValue()) : null;
                    if (minimumBigDecimal != null && maximumBigDecimal != null && minimumBigDecimal.compareTo(maximumBigDecimal) > -1) {
                        rejectValue(errors, MINIMUM, getErrorMessageRoot() + MINIMUM + MSG_LESS_THAN_MAX, errorArgs);
                        compareDefaultToMinMax = false;
                    }
                    // don't even bother validating default if the min-max range is bogus
                    if (compareDefaultToMinMax && defaultBigDecimal != null) {
                        if (minimumBigDecimal != null && defaultBigDecimal.compareTo(minimumBigDecimal) < 0) {
                            rejectValue(errors, DEFAULT, getErrorMessageRoot() + DEFAULT + MSG_WITHIN_MIN_MAX, errorArgs);
                        }
                        if (maximumBigDecimal != null && defaultBigDecimal.compareTo(maximumBigDecimal) > 0) {
                            rejectValue(errors, DEFAULT, getErrorMessageRoot() + DEFAULT + MSG_WITHIN_MIN_MAX, errorArgs);
                        }
                    }
                }
                break;
            case STRING:
                rejectIfTooLong(errors, DEFAULT, MAX_STRING_LENGTH, errorArgs);
                rejectIfNotEmpty(errors, MINIMUM, errorArgs);
                rejectIfNotEmpty(errors, MAXIMUM, errorArgs);
                break;
            case BOOLEAN:
                rejectIfNotBooleanParseable(errors, DEFAULT, errorArgs);
                rejectIfNotEmpty(errors, MINIMUM, errorArgs);
                rejectIfNotEmpty(errors, MAXIMUM, errorArgs);
                break;
            default:
                rejectValue(errors, COMPUTATION_RULE_TYPE, getErrorMessageRoot() + COMPUTATION_RULE_TYPE + MSG_INVALID, errorArgs);
                break;
            }
            if (ComputationRuleMultiplicityType.DICTIONARY.equals(parameter.getComputationRuleMultiplicityType())) {
                rejectIfEmpty(errors, DICTIONARY_INDEX_TYPE, errorArgs);
            } else {
                rejectIfNotEmpty(errors, DICTIONARY_INDEX_TYPE, errorArgs);
            }
        }
    }

    @Override
    protected String getErrorMessageRoot() {
        return COMPUTATION_RULE_ROOT;
    }

}
