/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.service.impl;

import static org.opentestsystem.authoring.testauth.service.impl.ItemHelper.FT_OR_ADAPTIVE_SEGMENT_FILTER;

import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.opentestsystem.authoring.testauth.domain.AffinityGroup;
import org.opentestsystem.authoring.testauth.domain.BlueprintElement;
import org.opentestsystem.authoring.testauth.domain.BlueprintElementValue;
import org.opentestsystem.authoring.testauth.domain.FormPartition;
import org.opentestsystem.authoring.testauth.domain.Item;
import org.opentestsystem.authoring.testauth.domain.ItemCountSummary;
import org.opentestsystem.authoring.testauth.domain.ItemLocation;
import org.opentestsystem.authoring.testauth.domain.Segment;
import org.opentestsystem.authoring.testauth.domain.search.ItemSearchRequest;
import org.opentestsystem.authoring.testauth.persistence.ItemRepository;
import org.opentestsystem.authoring.testauth.persistence.SegmentRepository;
import org.opentestsystem.authoring.testauth.service.AffinityGroupService;
import org.opentestsystem.authoring.testauth.service.BlueprintElementService;
import org.opentestsystem.authoring.testauth.service.FormPartitionService;
import org.opentestsystem.authoring.testauth.service.SegmentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.google.common.collect.Iterables;
import com.google.common.collect.Maps;

@Component
public class ItemCountHelper extends ItemBaseHelper {

    @Autowired
    private transient ItemRepository itemRepository;

    @Autowired
    private SegmentRepository segmentRepository;

    @Autowired
    private SegmentService segmentService;

    @Autowired
    private AffinityGroupService affinityGroupService;

    @Autowired
    private BlueprintElementService blueprintElementService;

    @Autowired
    private FormPartitionService formPartitionService;

    // standardKey - > grade -> itemCounts
    protected Map<String, Map<String, ItemCountSummary>> getSegmentItemCounts(final String segmentId) {
        final Map<String, Map<String, ItemCountSummary>> itemCountsMap = Maps.newHashMap();
        final Segment segment = this.segmentRepository.findOne(segmentId);
        if (segment != null) {
            final List<BlueprintElement> blueprintElements = this.blueprintElementService.getBlueprintElementsByAssessmentId(segment.getAssessmentId());
            final List<Item> items = this.itemRepository.findAllBySegmentId(segmentId);

            for (final BlueprintElement blueprintElement : blueprintElements) {

                final BlueprintElementValue bpElementValue = blueprintElement.getBlueprintElementValueMap().get(segmentId);
                int opCount = 0;
                int ftCount = 0;
                for (final Item item : items) {
                    if (isItemAlignedToBlueprintElement(item, blueprintElement)) {
                        for (final ItemLocation itemLocation : item.getItemLocation()) {
                            if (itemLocation.isFieldTestItem()) {
                                ftCount++;
                            } else {
                                opCount++;
                            }
                        }
                    }
                }

                final ItemCountSummary itemCount = new ItemCountSummary();
                itemCount.setOpMin(bpElementValue.getOperationalItemMinValue());
                itemCount.setOpMax(bpElementValue.getOperationalItemMaxValue());
                itemCount.setOpCount(opCount);
                itemCount.setFtMin(bpElementValue.getFieldTestItemMinValue());
                itemCount.setFtMax(bpElementValue.getFieldTestItemMaxValue());
                itemCount.setFtCount(ftCount);

                if (itemCountsMap.get(blueprintElement.getStandardKey()) == null) {
                    itemCountsMap.put(blueprintElement.getStandardKey(), new HashMap<String, ItemCountSummary>());
                }
                itemCountsMap.get(blueprintElement.getStandardKey()).put(blueprintElement.getGrade(), itemCount);
            }
        }
        return itemCountsMap;
    }

    @SuppressWarnings("unchecked")
    private static final boolean isItemAlignedToBlueprintElement(final Item item, final BlueprintElement blueprintElement) {
        final String itemIntendedGrade = (String) item.getAllIncludedMetadata().get("IntendedGrade");

        if (itemIntendedGrade.equals(blueprintElement.getGrade())) { // grade aligned
            final List<Map<String, Object>> itemPublicationList = (List<Map<String, Object>>) item.getAllIncludedMetadata().get("StandardPublication");

            if (CollectionUtils.isNotEmpty(itemPublicationList)) {
                for (final Map<String, Object> publication : itemPublicationList) {
                    final String primaryStandard = (String) publication.get("PrimaryStandard");
                    if (StringUtils.isNotBlank(primaryStandard) && primaryStandard.contains(blueprintElement.getStandardKey())) { // standard aligned
                        return true;
                    }
                }
            }
        }

        return false;
    }

    protected Map<String, Map<BlueprintElement, ItemCountSummary>> getAdaptiveSegmentStandardItemCounts(final String assessmentId) {
        final Map<String, Map<BlueprintElement, ItemCountSummary>> itemCountsMap = Maps.newLinkedHashMap();

        final List<Segment> allSegments = this.segmentService.findSegmentListByAssessmentId(assessmentId);
        this.segmentService.loadReferenceData(allSegments);
        final List<BlueprintElement> blueprintElements = this.blueprintElementService.getBlueprintElementsByAssessmentId(assessmentId);

        for (final Segment segment : Iterables.filter(allSegments, FT_OR_ADAPTIVE_SEGMENT_FILTER)) {
            if (itemCountsMap.get(segment.getId()) == null) {
                itemCountsMap.put(segment.getId(), new LinkedHashMap<BlueprintElement, ItemCountSummary>());
            }

            final List<Item> items = this.itemRepository.findAllBySegmentId(segment.getId());

            for (final BlueprintElement blueprintElement : blueprintElements) {
                if (blueprintElement.isActive()) {
                    final ItemCountSummary itemCount = new ItemCountSummary();
                    itemCount.setOpMin(blueprintElement.getBlueprintElementValueMap().get(segment.getId()).getOperationalItemMinValue());
                    itemCount.setOpMax(blueprintElement.getBlueprintElementValueMap().get(segment.getId()).getOperationalItemMaxValue());
                    itemCount.setOpCount(0);
                    itemCount.setFtMin(blueprintElement.getBlueprintElementValueMap().get(segment.getId()).getFieldTestItemMinValue());
                    itemCount.setFtMax(blueprintElement.getBlueprintElementValueMap().get(segment.getId()).getFieldTestItemMaxValue());
                    itemCount.setFtCount(0);

                    for (final Item alignedItem : Iterables.filter(items, ItemHelper.ITEM_STANDARD_KEY_AND_GRADE_FILTER.getInstance(blueprintElement.getStandardKey(), blueprintElement.getGrade()))) {
                        for (final ItemLocation itemLocation : alignedItem.getAdaptiveAndFixedItemLocations()) {
                            if (segment.getId().equals(itemLocation.getSegmentId())) {
                                if (itemLocation.isFieldTestItem()) {
                                    itemCount.setFtCount(itemCount.getFtCount() + 1);
                                } else {
                                    itemCount.setOpCount(itemCount.getOpCount() + 1);
                                }
                            }
                        }
                    }

                    itemCountsMap.get(segment.getId()).put(blueprintElement, itemCount);
                }
            }
        }
        return itemCountsMap;
    }

    protected Map<String, Map<BlueprintElement, ItemCountSummary>> getFormPartitionStandardItemCounts(final String assessmentId) {
        final Map<String, Map<BlueprintElement, ItemCountSummary>> itemCountsMap = Maps.newLinkedHashMap();

        final List<FormPartition> formPartitions = this.formPartitionService.getFormPartitionsByAssessmentId(assessmentId);
        final List<BlueprintElement> blueprintElements = this.blueprintElementService.getBlueprintElementsByAssessmentId(assessmentId);

        for (final FormPartition formPartition : formPartitions) {
            if (itemCountsMap.get(formPartition.getId()) == null) {
                itemCountsMap.put(formPartition.getId(), new LinkedHashMap<BlueprintElement, ItemCountSummary>());
            }

            final List<Item> items = this.itemRepository.findAllByFormPartitionId(formPartition.getId());

            for (final BlueprintElement blueprintElement : blueprintElements) {
                if (blueprintElement.isActive()) {
                    final ItemCountSummary itemCount = new ItemCountSummary();
                    itemCount.setOpMin(blueprintElement.getBlueprintElementValueMap().get(formPartition.getSegmentId()).getOperationalItemMinValue());
                    itemCount.setOpMax(blueprintElement.getBlueprintElementValueMap().get(formPartition.getSegmentId()).getOperationalItemMaxValue());
                    itemCount.setOpCount(0);
                    itemCount.setFtMin(blueprintElement.getBlueprintElementValueMap().get(formPartition.getSegmentId()).getFieldTestItemMinValue());
                    itemCount.setFtMax(blueprintElement.getBlueprintElementValueMap().get(formPartition.getSegmentId()).getFieldTestItemMaxValue());
                    itemCount.setFtCount(0);

                    for (final Item alignedItem : Iterables.filter(items, ItemHelper.ITEM_STANDARD_KEY_AND_GRADE_FILTER.getInstance(blueprintElement.getStandardKey(), blueprintElement.getGrade()))) {
                        for (final ItemLocation itemLocation : alignedItem.getAdaptiveAndFixedItemLocations()) {
                            if (formPartition.getId().equals(itemLocation.getFormPartitionId())) {
                                if (itemLocation.isFieldTestItem()) {
                                    itemCount.setFtCount(itemCount.getFtCount() + 1);
                                } else {
                                    itemCount.setOpCount(itemCount.getOpCount() + 1);
                                }
                            }
                        }
                    }

                    itemCountsMap.get(formPartition.getId()).put(blueprintElement, itemCount);
                }
            }
        }
        return itemCountsMap;
    }

    protected Map<String, ItemCountSummary> getAffinityGroupItemCounts(final String assessmentId) {
        final Map<String, ItemCountSummary> affinityGroupIdToItemCountMap = Maps.newHashMap();

        final Map<String, String[]> opItemParams = Maps.newHashMap();
        opItemParams.put("assessmentId", new String[] { assessmentId });
        opItemParams.put("status", new String[] { "OP" });

        final Map<String, String[]> ftItemParams = Maps.newHashMap();
        ftItemParams.put("assessmentId", new String[] { assessmentId });
        ftItemParams.put("status", new String[] { "FT" });

        final List<AffinityGroup> affinityGroups = this.affinityGroupService.getAffinityGroupsByAssessment(assessmentId);
        for (final AffinityGroup affinityGroup : affinityGroups) {
            opItemParams.put("affinityGroupId", new String[] { affinityGroup.getId() });
            final int opItems = Long.valueOf(searchItems(new ItemSearchRequest(opItemParams)).getTotalCount()).intValue();

            ftItemParams.put("affinityGroupId", new String[] { affinityGroup.getId() });
            final int ftItems = Long.valueOf(searchItems(new ItemSearchRequest(ftItemParams)).getTotalCount()).intValue();

            final ItemCountSummary itemCount = new ItemCountSummary();
            itemCount.setOpMin(affinityGroup.getMasterAffinityGroupValue().getOperationalItemMinValue());
            itemCount.setOpMax(affinityGroup.getMasterAffinityGroupValue().getOperationalItemMaxValue());
            itemCount.setOpCount(opItems);
            itemCount.setFtMin(affinityGroup.getMasterAffinityGroupValue().getFieldTestItemMinValue());
            itemCount.setFtMax(affinityGroup.getMasterAffinityGroupValue().getFieldTestItemMaxValue());
            itemCount.setFtCount(ftItems);
            affinityGroupIdToItemCountMap.put(affinityGroup.getId(), itemCount);
        }

        return affinityGroupIdToItemCountMap;
    }
}
