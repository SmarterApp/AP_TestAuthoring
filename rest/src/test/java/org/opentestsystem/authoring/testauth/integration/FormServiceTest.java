/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.integration;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.notNullValue;
import static org.hamcrest.CoreMatchers.nullValue;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.Assert.fail;

import java.util.List;

import javax.validation.ConstraintViolationException;

import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.authoring.testauth.domain.Assessment;
import org.opentestsystem.authoring.testauth.domain.BlueprintElement;
import org.opentestsystem.authoring.testauth.domain.DomainFactory;
import org.opentestsystem.authoring.testauth.domain.FixedFormItemLocation;
import org.opentestsystem.authoring.testauth.domain.Form;
import org.opentestsystem.authoring.testauth.domain.FormPartition;
import org.opentestsystem.authoring.testauth.domain.Item;
import org.opentestsystem.authoring.testauth.domain.ItemLocation;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionAlgorithm;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionAlgorithmType;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionPurpose;
import org.opentestsystem.authoring.testauth.domain.ItemSelectionType;
import org.opentestsystem.authoring.testauth.domain.Publication;
import org.opentestsystem.authoring.testauth.domain.Segment;
import org.opentestsystem.authoring.testauth.domain.Subject;
import org.opentestsystem.authoring.testauth.domain.ValidationResult;
import org.opentestsystem.authoring.testauth.persistence.AssessmentRepository;
import org.opentestsystem.authoring.testauth.rest.AbstractRestEmbeddedMongoTest;
import org.opentestsystem.authoring.testauth.service.BlueprintElementService;
import org.opentestsystem.authoring.testauth.service.FormPartitionService;
import org.opentestsystem.authoring.testauth.service.FormService;
import org.opentestsystem.authoring.testauth.service.ItemSelectionAlgorithmService;
import org.opentestsystem.authoring.testauth.service.ItemService;
import org.opentestsystem.authoring.testauth.service.PublicationService;
import org.opentestsystem.authoring.testauth.service.SegmentService;
import org.opentestsystem.authoring.testauth.service.SubjectService;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.springframework.beans.factory.annotation.Autowired;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;

public class FormServiceTest extends AbstractRestEmbeddedMongoTest {

    @Autowired
    private FormPartitionService formPartitionService;

    @Autowired
    private SubjectService subjectService;

    @Autowired
    private PublicationService publicationService;

    @Autowired
    private AssessmentRepository assessmentRepository;

    @Autowired
    private FormService formService;

    @Autowired
    private ItemSelectionAlgorithmService itemSelectionAlgorithmService;

    @Autowired
    private SegmentService segmentService;

    @Autowired
    private ItemService itemService;

    @Autowired
    private BlueprintElementService blueprintElementService;

    private Assessment savedAssessment;

    @Before
    public void setupTestData() {
        final Subject savedSubject = this.subjectService.saveSubject(DomainFactory.manufactureValidSubject("abb"));
        final Publication savedPublication = this.publicationService.savePublication(DomainFactory.manufactureValidPublication(savedSubject.getTenantId(), ImmutableSet.of(savedSubject)));
        this.savedAssessment = this.assessmentRepository.save(DomainFactory.manufactureValidAssessment(savedSubject, savedPublication));
    }

    @Test
    public void saveNewFormTest() {
        final Form formToSave = buildValidForm();

        final Form savedForm = this.formService.saveForm(null, formToSave);
        assertThat(savedForm, is(notNullValue()));

        final Form retrievedForm = this.formService.getForm(savedForm.getId());
        assertThat(retrievedForm, is(notNullValue()));
    }

    @Test
    public void saveNewFormWithInvalidDataTest() {
        final Form formToSave = buildValidForm();
        formToSave.setName(null);
        formToSave.setLanguage(null);

        try {
            this.formService.saveForm(null, formToSave);
            fail("exception should be thrown when trying to add a new form w/ missing data");
        } catch (final ConstraintViolationException e) {
            assertThat(e.getConstraintViolations().size(), is(2));
            assertThat(getConstraintViolation(e, "form.name.required").size(), is(1));
            assertThat(getConstraintViolation(e, "form.language.required").size(), is(1));
        }
    }

    @Test
    public void saveNewFormAssessmentAlreadyLockedTest() {
        this.savedAssessment.setLocked(true);
        this.assessmentRepository.save(this.savedAssessment);

        final Form formToSave = buildValidForm();
        try {
            this.formService.saveForm(null, formToSave);
            fail("exception should be thrown when trying to save a new form after assessment is locked");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("cannot.be.altered.assessment.locked"));
        }
    }

    @Test
    public void saveExistingFormTest() {
        final Form formToSave = buildValidForm();
        final Form savedForm = this.formService.saveForm(null, formToSave);

        savedForm.setLanguage("different-language");
        final Form resavedForm = this.formService.saveForm(savedForm.getId(), savedForm);
        assertThat(resavedForm, is(notNullValue()));
        assertThat(resavedForm.getLanguage(), is(equalTo("different-language")));
    }

    @Test
    public void saveDuplicateFormTest() {
        final Form formToSave = buildValidForm();
        final Form savedForm = this.formService.saveForm(null, formToSave);

        final Form duplicateForm = this.formService.getForm(savedForm.getId());
        duplicateForm.setId(null);

        try {
            this.formService.saveForm(null, duplicateForm);
            fail("should thow duplicate key exception");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("form.already.exists"));
        }
    }

    @Test
    public void saveExistingFormAssessmentAlreadyLockedTest() {
        final Form formToSave = buildValidForm();
        final Form savedForm = this.formService.saveForm(null, formToSave);

        this.savedAssessment.setLocked(true);
        this.assessmentRepository.save(this.savedAssessment);

        savedForm.setLanguage("new-language");
        try {
            this.formService.saveForm(savedForm.getId(), savedForm);
            fail("exception should be thrown when trying to save an existing form after assessment is locked");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("cannot.be.altered.assessment.locked"));
        }
    }

    @Test
    public void deleteFormTest() {
        final Form formToSave = buildValidForm();
        final Form savedForm = this.formService.saveForm(null, formToSave);
        // create a formPartition with this form
        final FormPartition partition = buildValidFormPartition("TESTPARTITION", savedForm.getId());
        final FormPartition savedFormPartition = this.formPartitionService.saveFormPartition(null, partition);
        final FormPartition foundPartition = this.formPartitionService.getFormPartition(savedFormPartition.getId());
        assertThat(foundPartition, is(notNullValue()));
        this.formService.removeForm(savedForm.getId());
        final Form retreivedForm = this.formService.getForm(savedForm.getId());
        assertThat(retreivedForm, is(nullValue()));
        final FormPartition deletedPartition = this.formPartitionService.getFormPartition(savedFormPartition.getId());
        assertThat(deletedPartition, is(nullValue()));
    }

    @Test
    public void deleteFormAssessmentAlreadyLockedTest() {
        final Form formToSave = buildValidForm();
        final Form savedForm = this.formService.saveForm(null, formToSave);

        this.savedAssessment.setLocked(true);
        this.assessmentRepository.save(this.savedAssessment);

        try {
            this.formService.removeForm(savedForm.getId());
            fail("exception should be thrown when trying to delete an form after assessment is locked");
        } catch (final LocalizedException e) {
            assertThat(e.getMessage(), is("cannot.be.altered.assessment.locked"));
        }

        final Form retreivedForm = this.formService.getForm(savedForm.getId());
        assertThat(retreivedForm, is(notNullValue()));
    }

    @Test
    public void removeFormByAssessmentIdTest() {
        final Form formToSave1 = buildValidForm("name1");
        final Form formToSave2 = buildValidForm("name2");
        final Form formToSave3 = buildValidForm("name3");
        final Form savedForm1 = this.formService.saveForm(null, formToSave1);
        final Form savedForm2 = this.formService.saveForm(null, formToSave2);
        final Form savedForm3 = this.formService.saveForm(null, formToSave3);

        this.formService.removeFormsByAssessmentId(this.savedAssessment.getId());

        final Form retrievedForm1 = this.formService.getForm(savedForm1.getId());
        assertThat(retrievedForm1, is(nullValue()));

        final Form retrievedForm2 = this.formService.getForm(savedForm2.getId());
        assertThat(retrievedForm2, is(nullValue()));

        final Form retrievedForm3 = this.formService.getForm(savedForm3.getId());
        assertThat(retrievedForm3, is(nullValue()));
    }

    @Test
    public void searchForms() {
        final Form formToSave1 = buildValidForm("name1");
        final Form formToSave2 = buildValidForm("name2");
        final Form savedForm1 = this.formService.saveForm(null, formToSave1);
        final Form savedForm2 = this.formService.saveForm(null, formToSave2);

        SearchResponse<Form> searchResponse = this.formService.searchForms(ImmutableMap.of("assessmentId", new String[] { "invalid-assessment-id" }));
        assertThat(searchResponse.getSearchResults().size(), is(0));

        searchResponse = this.formService.searchForms(ImmutableMap.of("assessmentId", new String[] { this.savedAssessment.getId() }));
        assertThat(searchResponse.getSearchResults().size(), is(2));

        searchResponse = this.formService.searchForms(ImmutableMap.of("name", new String[] { savedForm1.getName() }));
        assertThat(searchResponse.getSearchResults().size(), is(1));

        searchResponse = this.formService.searchForms(ImmutableMap.of("name", new String[] { savedForm2.getName() }));
        assertThat(searchResponse.getSearchResults().size(), is(1));
    }

    @Test
    public void validateFormsWithNoErrors() {
        // setup data
        final Segment segment1 = buildValidSegment(1, 0, 999, 0, 999);
        final Segment segment2 = buildValidSegment(2, 0, 999, 0, 999);

        final Form form1 = this.formService.saveForm(null, buildValidForm("form1"));
        final Form form2 = this.formService.saveForm(null, buildValidForm("form2"));

        final FormPartition partition1 = DomainFactory.manufactureValidFormPartition(this.savedAssessment.getId(), "partition1", form1.getId(), segment1.getId());
        final FormPartition partition2 = DomainFactory.manufactureValidFormPartition(this.savedAssessment.getId(), "partition2", form1.getId(), segment2.getId());
        final FormPartition partitionA = DomainFactory.manufactureValidFormPartition(this.savedAssessment.getId(), "partitionA", form2.getId(), segment1.getId());
        final FormPartition partitionB = DomainFactory.manufactureValidFormPartition(this.savedAssessment.getId(), "partitionB", form2.getId(), segment2.getId());
        this.formPartitionService.saveFormPartitionList(ImmutableList.of(partition1, partition2, partitionA, partitionB));

        // execute tests
        final List<ValidationResult<FormPartition>> errors = this.formService.validateForms(this.savedAssessment.getId());
        assertThat(errors.size(), is(0));
    }

    @Test
    public void validateFormsWith1PartitionErrors() {
        // setup data
        final Segment segment1 = buildValidSegment(1, 0, 999, 0, 999);
        final Segment segment2 = buildValidSegment(2, 1, 999, 1, 999);

        final Form form1 = this.formService.saveForm(null, buildValidForm("form1"));
        final Form form2 = this.formService.saveForm(null, buildValidForm("form2"));

        final FormPartition partition1 = DomainFactory.manufactureValidFormPartition(this.savedAssessment.getId(), "partition1", form1.getId(), segment1.getId());
        final FormPartition partition2 = DomainFactory.manufactureValidFormPartition(this.savedAssessment.getId(), "partition2", form1.getId(), segment2.getId());
        final FormPartition partitionA = DomainFactory.manufactureValidFormPartition(this.savedAssessment.getId(), "partitionA", form2.getId(), segment1.getId());
        final FormPartition partitionB = DomainFactory.manufactureValidFormPartition(this.savedAssessment.getId(), "partitionB", form2.getId(), segment2.getId());
        this.formPartitionService.saveFormPartitionList(ImmutableList.of(partition1, partition2, partitionA, partitionB));

        addItemToPartition(partitionB.getId(), false);
        addItemToPartition(partitionB.getId(), true);

        // execute tests
        final List<ValidationResult<FormPartition>> errors = this.formService.validateForms(this.savedAssessment.getId());
        assertThat(errors.size(), is(2));

        assertThat(findResultsForPartitionId(errors, partition1.getId()).size(), is(0));
        assertThat(findResultsForPartitionId(errors, partition2.getId()).size(), is(2));
        assertThat(findResultsForPartitionId(errors, partitionA.getId()).size(), is(0));
        assertThat(findResultsForPartitionId(errors, partitionB.getId()).size(), is(0));

        final ValidationResult<FormPartition> part2Error1 = findResultsForPartitionId(errors, partition2.getId()).get(0);
        assertThat(part2Error1.getValidatedObject().getId(), is(partition2.getId()));
        assertThat(part2Error1.getMessage(), is("Partition: form1 - partition2 contains too few OP items (0).  The minimum defined by the segment is 1."));

        final ValidationResult<FormPartition> part2Error2 = findResultsForPartitionId(errors, partition2.getId()).get(1);
        assertThat(part2Error2.getValidatedObject().getId(), is(partition2.getId()));
        assertThat(part2Error2.getMessage(), is("Partition: form1 - partition2 contains too few FT items (0).  The minimum defined by the segment is 1."));
    }

    @Test
    public void validateFormsWithMultiplePartitionErrors() {
        // setup data
        final Segment segment1 = buildValidSegment(1, 2, 2, 0, 4);
        final Segment segment2 = buildValidSegment(2, 1, 3, 1, 1);

        final Form form1 = this.formService.saveForm(null, buildValidForm("form1"));
        final Form form2 = this.formService.saveForm(null, buildValidForm("form2"));

        final FormPartition partition1 = DomainFactory.manufactureValidFormPartition(this.savedAssessment.getId(), "partition1", form1.getId(), segment1.getId());
        final FormPartition partition2 = DomainFactory.manufactureValidFormPartition(this.savedAssessment.getId(), "partition2", form1.getId(), segment2.getId());
        final FormPartition partitionA = DomainFactory.manufactureValidFormPartition(this.savedAssessment.getId(), "partitionA", form2.getId(), segment1.getId());
        final FormPartition partitionB = DomainFactory.manufactureValidFormPartition(this.savedAssessment.getId(), "partitionB", form2.getId(), segment2.getId());
        this.formPartitionService.saveFormPartitionList(ImmutableList.of(partition1, partition2, partitionA, partitionB));

        // partition1 = 3 OP, 0 FT (segment: 2,2,0,4)
        addItemToPartition(partition1.getId(), false);
        addItemToPartition(partition1.getId(), false);
        addItemToPartition(partition1.getId(), false);

        // partition2 = 0 OP, 1 FT (segment: 1,3,1,1)
        addItemToPartition(partition2.getId(), true);

        // partitionA = 2 OP, 5 FT (segment: 2,2,0,4)
        addItemToPartition(partitionA.getId(), false);
        addItemToPartition(partitionA.getId(), false);
        addItemToPartition(partitionA.getId(), true);
        addItemToPartition(partitionA.getId(), true);
        addItemToPartition(partitionA.getId(), true);
        addItemToPartition(partitionA.getId(), true);
        addItemToPartition(partitionA.getId(), true);

        // partitionB = 4 OP, 0 FT (segment: 1,3,1,1)
        addItemToPartition(partitionB.getId(), false);
        addItemToPartition(partitionB.getId(), false);
        addItemToPartition(partitionB.getId(), false);
        addItemToPartition(partitionB.getId(), false);

        // execute tests
        final List<ValidationResult<FormPartition>> errors = this.formService.validateForms(this.savedAssessment.getId());
        assertThat(errors.size(), is(5));

        assertThat(findResultsForPartitionId(errors, partition1.getId()).size(), is(1));
        assertThat(findResultsForPartitionId(errors, partition2.getId()).size(), is(1));
        assertThat(findResultsForPartitionId(errors, partitionA.getId()).size(), is(1));
        assertThat(findResultsForPartitionId(errors, partitionB.getId()).size(), is(2));

        final ValidationResult<FormPartition> part1Error1 = findResultsForPartitionId(errors, partition1.getId()).get(0);
        assertThat(part1Error1.getValidatedObject().getId(), is(partition1.getId()));
        assertThat(part1Error1.getMessage(), is("Partition: form1 - partition1 contains too many OP items (3).  The maximum defined by the segment is 2."));

        final ValidationResult<FormPartition> part2Error1 = findResultsForPartitionId(errors, partition2.getId()).get(0);
        assertThat(part2Error1.getValidatedObject().getId(), is(partition2.getId()));
        assertThat(part2Error1.getMessage(), is("Partition: form1 - partition2 contains too few OP items (0).  The minimum defined by the segment is 1."));

        final ValidationResult<FormPartition> partAError1 = findResultsForPartitionId(errors, partitionA.getId()).get(0);
        assertThat(partAError1.getValidatedObject().getId(), is(partitionA.getId()));
        assertThat(partAError1.getMessage(), is("Partition: form2 - partitionA contains too many FT items (5).  The maximum defined by the segment is 4."));

        final ValidationResult<FormPartition> partBError1 = findResultsForPartitionId(errors, partitionB.getId()).get(0);
        assertThat(partBError1.getValidatedObject().getId(), is(partitionB.getId()));
        assertThat(partBError1.getMessage(), is("Partition: form2 - partitionB contains too many OP items (4).  The maximum defined by the segment is 3."));

        final ValidationResult<FormPartition> partBError2 = findResultsForPartitionId(errors, partitionB.getId()).get(1);
        assertThat(partBError2.getValidatedObject().getId(), is(partitionB.getId()));
        assertThat(partBError2.getMessage(), is("Partition: form2 - partitionB contains too few FT items (0).  The minimum defined by the segment is 1."));
    }

    @Test
    public void validateFormsWithBlueprintStandardCountErrors() {
        // setup blueprints
        final Segment segment1 = buildValidSegment(1, 2, 2, 0, 4);
        final Form form1 = this.formService.saveForm(null, buildValidForm("form1"));
        final FormPartition partition1 = DomainFactory.manufactureValidFormPartition(this.savedAssessment.getId(), "partition1", form1.getId(), segment1.getId());
        this.formPartitionService.saveFormPartitionList(ImmutableList.of(partition1));

        final BlueprintElement bpElement = DomainFactory.manufactureValidBlueprintElement(savedAssessment.getId(), ImmutableList.of(segment1));
        final BlueprintElement bpElement2 = DomainFactory.manufactureValidBlueprintElement(savedAssessment.getId(), ImmutableList.of(segment1));
        final BlueprintElement bpElement3 = DomainFactory.manufactureValidBlueprintElement(savedAssessment.getId(), ImmutableList.of(segment1));
        bpElement.setGrade("5");
        bpElement.setStandardKey("key1");
        bpElement.getBlueprintElementValueMap().get(segment1.getId()).setOperationalItemMinValue(1);
        bpElement.getBlueprintElementValueMap().get(segment1.getId()).setOperationalItemMaxValue(1);
        bpElement2.setGrade("5");
        bpElement2.setStandardKey("key1|abc");
        bpElement2.getBlueprintElementValueMap().get(segment1.getId()).setOperationalItemMinValue(1);
        bpElement2.getBlueprintElementValueMap().get(segment1.getId()).setOperationalItemMaxValue(1);
        bpElement3.setGrade("5");
        bpElement3.setStandardKey("key1|abc|xyz");

        bpElement3.getBlueprintElementValueMap().get(segment1.getId()).setOperationalItemMinValue(1);
        bpElement3.getBlueprintElementValueMap().get(segment1.getId()).setOperationalItemMaxValue(1);
        this.blueprintElementService.saveBlueprintElementList(ImmutableList.of(bpElement, bpElement2, bpElement3));

        // setup items
        final Item itemToSave = DomainFactory.manufactureValidItem(this.savedAssessment.getId());
        itemToSave.setIntendedGrade("5");
        itemToSave.setPrimaryStandard("key1|abc");

        final FixedFormItemLocation location = new FixedFormItemLocation();
        location.setFormPartitionId(partition1.getId());
        location.setFieldTestItem(false);
        location.setItemGroupId(Item.NO_GROUP_KEY);
        itemToSave.getItemLocation().clear();
        itemToSave.addItemLocation(location);
        this.itemService.saveItem(itemToSave);

        final Item itemToSave2 = DomainFactory.manufactureValidItem(this.savedAssessment.getId());
        itemToSave2.setIntendedGrade("5");
        itemToSave2.setPrimaryStandard("key1|abc");

        final FixedFormItemLocation location2 = new FixedFormItemLocation();
        location2.setFormPartitionId(partition1.getId());
        location2.setFieldTestItem(false);
        location2.setItemGroupId(Item.NO_GROUP_KEY);
        itemToSave2.getItemLocation().clear();
        itemToSave2.addItemLocation(location2);
        this.itemService.saveItem(itemToSave2);

        // execute tests
        final List<ValidationResult<FormPartition>> errors = this.formService.validateForms(this.savedAssessment.getId());
        assertThat(errors.size(), is(3));
        assertThat(findResultsForPartitionId(errors, partition1.getId()).size(), is(3));

        final ValidationResult<FormPartition> partition1Error1 = findResultsForPartitionId(errors, partition1.getId()).get(0);
        assertThat(partition1Error1.getValidatedObject().getId(), is(partition1.getId()));
        assertThat(partition1Error1.getMessage(), is("Partition: " + form1.getName() + " - " + partition1.getName()
                + " contains too many OP items (2) for standard key1 (grade 5).  The maximum defined by the blueprint is 1."));
        assertThat(partition1Error1.getValidationLevel(), is(ValidationResult.WARNING_LEVEL));

        final ValidationResult<FormPartition> partition1Error2 = findResultsForPartitionId(errors, partition1.getId()).get(1);
        assertThat(partition1Error2.getValidatedObject().getId(), is(partition1.getId()));
        assertThat(partition1Error2.getMessage(), is("Partition: " + form1.getName() + " - " + partition1.getName()
                + " contains too many OP items (2) for standard key1|abc (grade 5).  The maximum defined by the blueprint is 1."));
        assertThat(partition1Error2.getValidationLevel(), is(ValidationResult.WARNING_LEVEL));

        final ValidationResult<FormPartition> partition1Error3 = findResultsForPartitionId(errors, partition1.getId()).get(2);
        assertThat(partition1Error3.getValidatedObject().getId(), is(partition1.getId()));
        assertThat(partition1Error3.getMessage(), is("Partition: " + form1.getName() + " - " + partition1.getName()
                + " contains too few OP items (0) for standard key1|abc|xyz (grade 5).  The minimum defined by the blueprint is 1."));
        assertThat(partition1Error3.getValidationLevel(), is(ValidationResult.WARNING_LEVEL));
    }

    private Form buildValidForm() {
        return buildValidForm("name");
    }

    private Form buildValidForm(final String name) {
        final Form form = new Form();
        form.setId(null);
        form.setAssessmentId(this.savedAssessment.getId());
        form.setName(name);
        form.setLanguage("en");
        return form;
    }

    private Segment buildValidSegment(final int posititon, final int opMin, final int opMax, final int ftMin, final int ftMax) {
        final ItemSelectionAlgorithm algorithm = DomainFactory.manufactureValidItemSelectionAlgorithm(ItemSelectionPurpose.SCALAR, ItemSelectionType.BOOLEAN);
        algorithm.setItemSelectionAlgorithmType(ItemSelectionAlgorithmType.FIXEDFORM);
        final ItemSelectionAlgorithm savedAlgorithm = this.itemSelectionAlgorithmService.createItemSelectionAlgorithm(algorithm);

        final Segment segmentToSave = DomainFactory.manufactureValidSegment(this.savedAssessment.getId(), savedAlgorithm, posititon);
        segmentToSave.setMinOpItems(opMin);
        segmentToSave.setMaxOpItems(opMax);
        segmentToSave.setMinFtItems(ftMin);
        segmentToSave.setMaxFtItems(ftMax);
        return this.segmentService.createSegment(segmentToSave);
    }

    private FormPartition buildValidFormPartition(final String partitionName, final String formId) {
        final Segment savedSegment = buildValidSegment(1, 0, 999, 0, 999);
        return DomainFactory.manufactureValidFormPartition(this.savedAssessment.getId(), partitionName, formId, savedSegment.getId());
    }

    private void addItemToPartition(final String partitionId, final boolean isFieldTestItem) {
        final Item item = DomainFactory.manufactureValidItem(this.savedAssessment.getId());
        final ItemLocation itemLocation = new FixedFormItemLocation(partitionId, null, 0, 0);
        itemLocation.setFieldTestItem(isFieldTestItem);
        item.addItemLocation(itemLocation);
        this.itemService.saveItem(item);
    }

    private static List<ValidationResult<FormPartition>> findResultsForPartitionId(final List<ValidationResult<FormPartition>> results, final String partitionId) {
        final List<ValidationResult<FormPartition>> foundResults = Lists.newArrayList();
        for (final ValidationResult<FormPartition> result : results) {
            if (result.getValidatedObject().getId().equals(partitionId)) {
                foundResults.add(result);
            }
        }
        return foundResults;
    }
}
