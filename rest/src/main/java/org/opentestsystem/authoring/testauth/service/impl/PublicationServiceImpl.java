/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.service.impl;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.authoring.testauth.domain.Assessment;
import org.opentestsystem.authoring.testauth.domain.Publication;
import org.opentestsystem.authoring.testauth.domain.Subject;
import org.opentestsystem.authoring.testauth.domain.search.AssessmentSearchRequest;
import org.opentestsystem.authoring.testauth.domain.search.PublicationSearchRequest;
import org.opentestsystem.authoring.testauth.persistence.AssessmentRepository;
import org.opentestsystem.authoring.testauth.persistence.PublicationRepository;
import org.opentestsystem.authoring.testauth.service.PublicationService;
import org.opentestsystem.authoring.testauth.service.SubjectService;
import org.opentestsystem.authoring.testauth.validation.PublicationValidator;
import org.opentestsystem.authoring.testauth.validation.ValidationHelper;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.progman.client.domain.Tenant;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;
import org.springframework.validation.BeanPropertyBindingResult;
import org.springframework.validation.BindingResult;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Sets;

@Service
public class PublicationServiceImpl implements PublicationService {

    @Autowired
    private transient PublicationRepository publicationRepository;

    @Autowired
    private transient SubjectService subjectService;

    @Autowired
    private transient AssessmentRepository assessmentRepository;

    @Autowired
    private PublicationValidator publicationValidator;

    @Autowired
    private TenantHelper tenantHelper;

    @Override
    public Publication savePublication(final Publication publication) {
        Publication savedPublication = null;
        try {
            if (publication.getId() != null) {
                verifyUpdateAllowed(publication);
            }

            final BindingResult bindingResult = new BeanPropertyBindingResult(publication, "publication");
            validatePublication(bindingResult, publication);

            savedPublication = this.publicationRepository.save(publication);
            loadReferenceData(savedPublication);
        } catch (final DuplicateKeyException dke) {
            throw new LocalizedException("publication.already.exists", new String[] { publication.getCoreStandardsPublicationKey() }, dke);
        }
        return savedPublication;
    }

    @Override
    public Publication getPublication(final String publicationId) {
        final Publication publication = this.publicationRepository.findOne(publicationId);
        loadReferenceData(publication);
        verifyUpdateAllowed(publication);
        return publication;
    }

    @Override
    public Publication getPublicationWithoutReferences(final String publicationId) {
        final Publication publication = this.publicationRepository.findOne(publicationId);
        return publication;
    }

    @Override
    public void removePublication(final String publicationId) {
        if (publicationId != null) {
            final Publication publication = this.publicationRepository.findOne(publicationId);
            verifyUpdateAllowed(publication);
            if (publication.isInUse()) {
                throw new LocalizedException("publication.cannot.be.altered");
            }
        }
        this.publicationRepository.delete(publicationId);
    }

    @Override
    public List<Publication> getPublications() {
        final List<Publication> publications = this.publicationRepository.findAll();
        for (final Publication publication : publications) {
            loadReferenceData(publication);
            verifyUpdateAllowed(publication);
        }
        return publications;
    }

    @Override
    public SearchResponse<Publication> searchPublications(final PublicationSearchRequest searchRequest) {
        final SearchResponse<Publication> publications = this.publicationRepository.search(searchRequest);
        for (final Publication publication : publications.getSearchResults()) {
            loadReferenceData(publication);
            verifyUpdateAllowed(publication);
        }
        return publications;
    }

    @Override
    public List<Subject> getSubjectsAssignedToPublications(final String tenantId) {
        final Set<Subject> subjects = new HashSet<Subject>();
        final List<Publication> publications = this.publicationRepository.findByTenantId(tenantId);
        for (final Publication publication : publications) {
            loadReferenceData(publication);
            for (final Subject subject : publication.getSubjects()) {
                if (!subject.isInactive()) {
                    subjects.add(subject);
                }
            }
        }

        return Subject.BY_NAME_ORDERING.sortedCopy(subjects);
    }

    private void loadReferenceData(final Publication publication) {
        if (publication != null) {
            if (!CollectionUtils.isEmpty(publication.getSubjectIds())) {
                final Set<Subject> hydratedSubjects = new HashSet<Subject>();
                for (final String subjectId : publication.getSubjectIds()) {
                    hydratedSubjects.add(this.subjectService.getSubject(subjectId));
                }
                publication.setSubjects(hydratedSubjects);
            }
            if (StringUtils.isNotBlank(publication.getTenantId())) {
                final Tenant tenant = this.tenantHelper.loadTenant(publication.getTenantId());
                if (tenant != null) {
                    final String tenantName = tenant.getName() + (StringUtils.isNotBlank(tenant.getDescription()) ? " - " + tenant.getDescription() : "");
                    publication.setTenantName(tenantName);
                }
            }
        }
    }

    private void verifyUpdateAllowed(final Publication publication) {
        final AssessmentSearchRequest searchRequest = new AssessmentSearchRequest(ImmutableMap.of("publicationId", new String[] { publication.getId() }));
        final SearchResponse<Assessment> searchResponse = this.assessmentRepository.search(searchRequest);
        if (!CollectionUtils.isEmpty(searchResponse.getSearchResults())) {
            publication.setInUse(true);
            // publication association is in use, for updates verify that the change is only to add subject(s)
            if (publication != null) {
                final Publication originalPublication = this.publicationRepository.findOne(publication.getId());
                if (StringUtils.equals(originalPublication.getTenantId(), publication.getTenantId())) {
                    final Set<String> subjectIdsInUse = Sets.newHashSet();
                    for (final Assessment assessment : searchResponse.getSearchResults()) {
                        subjectIdsInUse.add(assessment.getSubjectId());
                    }
                    if (!publication.getSubjectIds().containsAll(subjectIdsInUse)) {
                        throw new LocalizedException("publication.cannot.be.altered");
                    }
                }
            }
        }
    }

    private void validatePublication(final BindingResult bindingResult, final Publication publication) {
        this.publicationValidator.validate(publication, bindingResult);
        if (bindingResult.hasErrors()) {
            throw ValidationHelper.convertErrorsToConstraintException(publication, bindingResult);
        }
    }
}
