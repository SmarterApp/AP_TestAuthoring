/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.service.impl;

import java.util.List;
import java.util.Map;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.authoring.testauth.domain.Enemy;
import org.opentestsystem.authoring.testauth.domain.EnemyType;
import org.opentestsystem.authoring.testauth.domain.search.EnemySearchRequest;
import org.opentestsystem.authoring.testauth.persistence.EnemyRepository;
import org.opentestsystem.authoring.testauth.service.EnemyService;
import org.opentestsystem.authoring.testauth.service.ItemGroupService;
import org.opentestsystem.authoring.testauth.service.ItemService;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.exception.RestException;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.stereotype.Service;

@Service
public class EnemyServiceImpl extends AssessmentChildHelper implements EnemyService {

    @Autowired
    private transient EnemyRepository enemyRepository;

    @Autowired
    private transient ItemService itemService;

    @Autowired
    private transient ItemGroupService itemGroupService;

    @Override
    public Enemy saveEnemy(final String enemyId, final Enemy enemy) {
        // updating correct enemy?
        if (enemyId != null && (enemy == null || StringUtils.isEmpty(enemy.getId()) || !enemyId.equals(enemy.getId()))) {
            throw new LocalizedException("enemy.invalid.id");
        }

        checkForLockedAssessment(enemy.getAssessmentId());
        checkForInvalidObjectIds(enemy);
        checkForDuplicateEnemy(enemy);

        // save enemy
        Enemy savedEnemy = null;
        try {
            enemy.setObjectIdSearch(new String[] { enemy.getObjectId1(), enemy.getObjectId2() });
            savedEnemy = this.enemyRepository.save(enemy);
            loadReferenceData(savedEnemy);
        } catch (final DuplicateKeyException dke) {
            throw new LocalizedException("enemy.already.exists", new String[] { enemy.getObjectId1(), enemy.getObjectId2() }, dke);
        }
        return savedEnemy;
    }

    @Override
    public void removeEnemy(final String enemyId) {
        final Enemy enemy = this.enemyRepository.findOne(enemyId);
        checkForLockedAssessment(enemy.getAssessmentId());
        this.enemyRepository.delete(enemyId);
    }

    @Override
    public void removeEnemiesByAssessmentId(final String assessmentId) {
        this.enemyRepository.delete(this.enemyRepository.findAllByAssessmentId(assessmentId));
    }

    @Override
    public Enemy getEnemy(final String enemyId) {
        final Enemy enemy = this.enemyRepository.findOne(enemyId);
        loadReferenceData(enemy);
        return enemy;
    }

    @Override
    public List<Enemy> getEnemies() {
        final List<Enemy> enemies = this.enemyRepository.findAll();
        for (final Enemy enemy : enemies) {
            loadReferenceData(enemy);
        }
        return enemies;
    }

    @Override
    public List<Enemy> getEnemiesByAssessmentId(final String assessmentId) {
        final List<Enemy> enemies = this.enemyRepository.findAllByAssessmentId(assessmentId);
        return enemies;
    }

    @Override
    public List<Enemy> getEnemiesByAssessmentIdAndObjectId1(final String assessmentId, final String objectId1) {
        final List<Enemy> enemies = this.enemyRepository.findByAssessmentIdAndObjectId1(assessmentId, objectId1);
        for (final Enemy enemy : enemies) {
            loadReferenceData(enemy);
        }
        return enemies;
    }

    @Override
    public List<Enemy> getEnemiesByAssessmentIdAndObjectId2(final String assessmentId, final String objectId2) {
        final List<Enemy> enemies = this.enemyRepository.findByAssessmentIdAndObjectId2(assessmentId, objectId2);
        for (final Enemy enemy : enemies) {
            loadReferenceData(enemy);
        }
        return enemies;
    }

    @Override
    public SearchResponse<Enemy> searchEnemies(final Map<String, String[]> requestMap) {
        final EnemySearchRequest searchRequest = new EnemySearchRequest(requestMap);
        if (searchRequest.isValid()) {
            final SearchResponse<Enemy> enemies = this.enemyRepository.search(searchRequest);
            for (final Enemy enemy : enemies.getSearchResults()) {
                loadReferenceData(enemy);
            }
            return enemies;
        } else {
            throw new RestException("enemy.search.invalidSearchCriteria");
        }
    }

    @Override
    public boolean isDuplicateOfExistingEnemy(final Enemy enemy) {
        final Enemy foundEnemy = this.enemyRepository.findByAssessmentIdAndObjectId1AndObjectId2(enemy.getAssessmentId(), enemy.getObjectId1(), enemy.getObjectId2());
        if (foundEnemy != null) {
            return enemy.getId() == null ? true : !enemy.getId().equals(foundEnemy.getId());
        }

        final Enemy foundEnemy2 = this.enemyRepository.findByAssessmentIdAndObjectId1AndObjectId2(enemy.getAssessmentId(), enemy.getObjectId2(), enemy.getObjectId1());
        if (foundEnemy2 != null) {
            return enemy.getId() == null ? true : !enemy.getId().equals(foundEnemy2.getId());
        }

        return false;
    }

    private void loadReferenceData(final Enemy enemy) {
        if (enemy != null) {
            if (!StringUtils.isEmpty(enemy.getObjectId1()) && enemy.getObjectType1() != null) {
                enemy.setObject1(getObjectForType(enemy.getAssessmentId(), enemy.getObjectType1(), enemy.getObjectId1()));
            }

            if (!StringUtils.isEmpty(enemy.getObjectId2()) && enemy.getObjectType2() != null) {
                enemy.setObject2(getObjectForType(enemy.getAssessmentId(), enemy.getObjectType2(), enemy.getObjectId2()));
            }
        }
    }

    private void checkForDuplicateEnemy(final Enemy enemy) {
        if (isDuplicateOfExistingEnemy(enemy)) {
            throw new LocalizedException("enemy.already.exists");
        }
    }

    private void checkForInvalidObjectIds(final Enemy enemy) {
        if (!StringUtils.isEmpty(enemy.getObjectId1()) && !StringUtils.isEmpty(enemy.getObjectId2())) {
            if (enemy.getObjectId1().equals(enemy.getObjectId2())) {
                if(enemy.getObjectType1().equals(EnemyType.ITEM_GROUP)) {
                    throw new LocalizedException("enemy.group.cannot.be.enemy.of.self");
                } else {
                    throw new LocalizedException("enemy.cannot.be.enemy.of.self");
                }
            }
            if (null == getObjectForType(enemy.getAssessmentId(), enemy.getObjectType1(), enemy.getObjectId1())) {
                throw new LocalizedException("enemy.objectId1.invalid");
            }

            if (null == getObjectForType(enemy.getAssessmentId(), enemy.getObjectType2(), enemy.getObjectId2())) {
                throw new LocalizedException("enemy.objectId2.invalid");
            }
        }
    }

    private Object getObjectForType(final String assessmentId, final EnemyType enemyType, final String objectId) {
        switch (enemyType) {
        case ITEM:
            return this.itemService.getItemByAssessmentIdAndTibIdentifier(assessmentId, objectId);
        case ITEM_GROUP:
            return this.itemGroupService.getItemGroup(objectId);
        }

        return null;
    }

    @Override
    public List<Enemy> saveEnemyList(final List<Enemy> enemyList) {
        return this.enemyRepository.save(enemyList);
    }
}
