/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.validation;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.authoring.testauth.domain.ComputationRuleMultiplicityType;
import org.opentestsystem.authoring.testauth.domain.ComputationRuleParameter;
import org.opentestsystem.authoring.testauth.domain.ComputationRuleType;
import org.opentestsystem.authoring.testauth.domain.DictionaryIndexType;
import org.opentestsystem.authoring.testauth.domain.ScoringRuleDictionaryElement;
import org.opentestsystem.authoring.testauth.domain.ScoringRuleParameter;
import org.opentestsystem.shared.exception.LocalizedException;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;
import org.springframework.validation.Errors;
import org.springframework.validation.SmartValidator;

import com.google.common.base.Function;
import com.google.common.base.Predicate;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Multimaps;
import com.google.common.collect.Range;

@Component
public class ScoringRuleParameterValidator extends AbstractDomainValidator implements SmartValidator {
    private static final int MAX_STRING_LENGTH = 60;
    private static final String COMPUTATION_RULE_PARAMETER_ROOT = "scoringRule.parameters.";
    private static final String PARAMETER_NAME = "computationRuleParameterName";
    private static final String MSG_RANGE = ".number.outofrange";
    private static final String SCALAR = "scalarValue";
    private static final String DICTIONARY = "dictionaryValue";
    private static final String KEY = "key";
    private static final String VALUE = "value";
    private static final String DICTIONARY_KEY = DICTIONARY + "." + KEY;
    private static final String DICTIONARY_VALUE = DICTIONARY + "." + VALUE;
    private static final String MSG_FUNCTION_PARAM = "scoringRule.validation.requires.function.param";
    private static final String EMPTY_VALUE = "";
    private static final List<ComputationRuleType> NUMERIC_TYPES = Lists.newArrayList(ComputationRuleType.FLOAT, ComputationRuleType.INTEGER);

    private static final Function<ScoringRuleDictionaryElement, String> DICTIONARY_ELEMENT_TO_KEY_TRANSFORMER = new Function<ScoringRuleDictionaryElement, String>() {
        @Override
        public String apply(final ScoringRuleDictionaryElement element) {
            return StringUtils.isEmpty(element.getKey()) ? EMPTY_VALUE : element.getKey();
        }
    };

    private static final Predicate<Entry<String, Collection<ScoringRuleDictionaryElement>>> KEY_DUPLICATE_FILTER = new Predicate<Entry<String, Collection<ScoringRuleDictionaryElement>>>() {
        @Override
        public boolean apply(final Entry<String, Collection<ScoringRuleDictionaryElement>> entry) {
            return !EMPTY_VALUE.equals(entry.getKey()) && entry.getValue().size() > 1;
        }
    };

    @Override
    public boolean supports(final Class<?> clazz) {
        return ScoringRuleParameter.class.equals(clazz);
    }

    @Override
    public void validate(final Object target, final Errors errors) {
        throw new LocalizedException(MSG_FUNCTION_PARAM);
    }

    /**
     * when a ComputationRuleParameter is defined as a numeric type (FLOAT or INTEGER), every instantiation as a rule parameter,
     * whether a single SCALAR or a DICTIONARY list value, must be of that numeric type, as well as fall within the range boundary
     * of the ComputationRuleParameter MIN & MAX values; DICTIONARY keys also are constrained by the ComputationRuleParameter's
     * dictionary index type
     */
    @Override
    public void validate(final Object target, final Errors errors, final Object... validationHints) {
        final ScoringRuleParameter scoringRuleParameter = (ScoringRuleParameter) target;
        final ComputationRuleParameter computationRuleParameter = (ComputationRuleParameter) validationHints[0];
        if (computationRuleParameter == null) {
            throw new LocalizedException(MSG_FUNCTION_PARAM);
        }

        if (!rejectIfEmpty(scoringRuleParameter.getComputationRuleParameterName(), errors, PARAMETER_NAME,
                getErrorMessageRoot() + PARAMETER_NAME, MAX_STRING_LENGTH, computationRuleParameter.getParameterName())) {
            if (scoringRuleParameter.getComputationRuleParameterMultiplicity() == ComputationRuleMultiplicityType.SCALAR) {
                validateScalarValue(computationRuleParameter, scoringRuleParameter.getScalarValue(), errors);
            } else {
                validateDictionaryValues(computationRuleParameter, scoringRuleParameter.getDictionaryValue(), errors);
            }
        }
    }

    /**
     * validate scalar value
     */
    private <N extends Number> void validateScalarValue(final ComputationRuleParameter computationRuleParameter, final String scalarValue, final Errors errors) {
        final ComputationRuleType fieldType = computationRuleParameter.getComputationRuleType();
        final String paramName = computationRuleParameter.getParameterName();
        final boolean valueIsNumeric = NUMERIC_TYPES.contains(fieldType);
        if (!rejectIfEmpty(scalarValue, errors, SCALAR, getErrorMessageRoot() + SCALAR, valueIsNumeric ? MAX_PARSEABLE_LENGTH : MAX_STRING_LENGTH, fieldType, paramName, scalarValue)
                && valueIsNumeric) {
            try {
                final String min = computationRuleParameter.getMinimumValue();
                final String max = computationRuleParameter.getMaximumValue();
                if (fieldType == ComputationRuleType.FLOAT) {
                    final Float floatValue = Float.parseFloat(scalarValue);
                    final Range<Float> floatRange = buildFloatRange(min, max);
                    if (floatRange != null && !floatRange.contains(floatValue)) {
                        rejectValue(errors, SCALAR, getErrorMessageRoot() + SCALAR + MSG_RANGE, fieldType, paramName, scalarValue, min, max);
                    }
                } else {
                    final Long longValue = Long.parseLong(scalarValue);
                    final Range<Long> longRange = buildLongRange(min, max);
                    if (longRange != null && !longRange.contains(longValue)) {
                        rejectValue(errors, SCALAR, getErrorMessageRoot() + SCALAR + MSG_RANGE, fieldType, paramName, scalarValue, min, max);
                    }
                }
            } catch (final NumberFormatException e) {
                rejectValue(errors, SCALAR, getErrorMessageRoot() + SCALAR + MSG_PARSEABLE_NUMBER, fieldType, paramName, scalarValue);
            }
        } else if (ComputationRuleType.BOOLEAN.equals(fieldType) && !Boolean.FALSE.toString().equals(scalarValue.toString()) && !Boolean.TRUE.toString().equals(scalarValue.toString())) {
            rejectValue(errors, SCALAR, getErrorMessageRoot() + SCALAR + MSG_PARSEABLE_BOOLEAN, fieldType, paramName, scalarValue);
        }
    }

    /**
     * validate dictionary values
     */
    private <N extends Number> void validateDictionaryValues(final ComputationRuleParameter computationRuleParameter, final List<ScoringRuleDictionaryElement> dictionaryValues,
            final Errors errors) {
        final ComputationRuleType fieldType = computationRuleParameter.getComputationRuleType();
        final String paramName = computationRuleParameter.getParameterName();
        if (CollectionUtils.isEmpty(dictionaryValues)) {
            rejectValue(errors, DICTIONARY, getErrorMessageRoot() + DICTIONARY + MSG_REQUIRED, fieldType, paramName);
        }

        final Map<String, Collection<ScoringRuleDictionaryElement>> duplicates =
                Maps.filterEntries(Multimaps.index(dictionaryValues, DICTIONARY_ELEMENT_TO_KEY_TRANSFORMER).asMap(), KEY_DUPLICATE_FILTER);
        if (!duplicates.isEmpty()) {
            rejectValue(errors, DICTIONARY, getErrorMessageRoot() + DICTIONARY + MSG_DUPLICATES, paramName, duplicates.keySet().toString());
        }

        for (int i = 0; i < dictionaryValues.size(); i++) {
            final ScoringRuleDictionaryElement scoringRuleDictionaryElement = dictionaryValues.get(i);
            String key = scoringRuleDictionaryElement.getKey();
            final String value = scoringRuleDictionaryElement.getValue();
            try {
                errors.pushNestedPath(DICTIONARY + "[" + i + "]");

                final DictionaryIndexType dictionaryIndex = computationRuleParameter.getDictionaryIndexType();

                final boolean indexIsInteger = dictionaryIndex == DictionaryIndexType.INTEGER;
                if (!rejectIfEmpty(key, errors, KEY, getErrorMessageRoot() + DICTIONARY_KEY, indexIsInteger ? MAX_PARSEABLE_LENGTH : MAX_STRING_LENGTH, fieldType, paramName, i + 1)
                        && indexIsInteger) {
                    if (!StringUtils.isNumeric(key)) {
                        rejectValue(errors, KEY, getErrorMessageRoot() + DICTIONARY_KEY + MSG_INVALID, fieldType, paramName, key, dictionaryIndex);
                    }
                }

                key = StringUtils.defaultIfBlank(key, String.valueOf(i + 1));

                final boolean valueIsNumeric = NUMERIC_TYPES.contains(fieldType);
                if (!rejectIfEmpty(value, errors, VALUE, getErrorMessageRoot() + DICTIONARY_VALUE, valueIsNumeric ? MAX_PARSEABLE_LENGTH : MAX_STRING_LENGTH, fieldType, paramName, key)
                        && valueIsNumeric) {
                    final String min = computationRuleParameter.getMinimumValue();
                    final String max = computationRuleParameter.getMaximumValue();
                    try {
                        if (fieldType == ComputationRuleType.FLOAT) {
                            final Float floatValue = Float.parseFloat(value);
                            final Range<Float> floatRange = buildFloatRange(min, max);
                            if (floatRange != null && !floatRange.contains(floatValue)) {
                                rejectValue(errors, VALUE, getErrorMessageRoot() + DICTIONARY_VALUE + MSG_RANGE, fieldType, paramName, key, min, max);
                            }
                        } else {
                            final Long longValue = Long.parseLong(value);
                            final Range<Long> longRange = buildLongRange(min, max);
                            if (longRange != null && !longRange.contains(longValue)) {
                                rejectValue(errors, VALUE, getErrorMessageRoot() + DICTIONARY_VALUE + MSG_RANGE, fieldType, paramName, key, min, max);
                            }
                        }
                    } catch (final NumberFormatException e) {
                        rejectValue(errors, VALUE, getErrorMessageRoot() + DICTIONARY_VALUE + MSG_PARSEABLE_NUMBER, fieldType, paramName, key, value);
                    }
                } else if (ComputationRuleType.BOOLEAN.equals(fieldType) && !Boolean.FALSE.toString().equals(value.toString()) && !Boolean.TRUE.toString().equals(value.toString())) {
                    rejectValue(errors, VALUE, getErrorMessageRoot() + DICTIONARY_VALUE + MSG_PARSEABLE_BOOLEAN, fieldType, paramName, key, value);
                }
            } finally {
                errors.popNestedPath();
            }
        }
    }

    private boolean rejectIfEmpty(final String fieldToEval, final Errors errors, final String fieldName, final String errorCodePrefix, final int maxLength, final Object... errorArgs) {
        if (StringUtils.isBlank(fieldToEval)) {
            rejectValue(errors, fieldName, errorCodePrefix + MSG_REQUIRED, errorArgs);
            return true;
        } else if (fieldToEval.length() > maxLength) {
            rejectValue(errors, fieldName, errorCodePrefix + MSG_LENGTH_MAX, flattenArgs(errorArgs, maxLength));
            return true;
        }
        return false;
    }

    @Override
    protected String getErrorMessageRoot() {
        return COMPUTATION_RULE_PARAMETER_ROOT;
    }
}
