/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.service.impl;

import static org.opentestsystem.authoring.testauth.config.TestAuthUtil.paramArray;

import java.util.List;
import java.util.Map;

import org.opentestsystem.authoring.testauth.domain.Enemy;
import org.opentestsystem.authoring.testauth.domain.Item;
import org.opentestsystem.authoring.testauth.domain.ItemGroup;
import org.opentestsystem.authoring.testauth.domain.ItemGroupLocationType;
import org.opentestsystem.authoring.testauth.domain.ItemLocation;
import org.opentestsystem.authoring.testauth.domain.search.ItemGroupSearchRequest;
import org.opentestsystem.authoring.testauth.persistence.ItemGroupRepository;
import org.opentestsystem.authoring.testauth.service.EnemyService;
import org.opentestsystem.authoring.testauth.service.FormPartitionService;
import org.opentestsystem.authoring.testauth.service.ItemGroupService;
import org.opentestsystem.authoring.testauth.service.ItemService;
import org.opentestsystem.authoring.testauth.service.SegmentService;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.exception.RestException;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.stereotype.Service;

import com.google.common.collect.ImmutableMap;

@Service
public class ItemGroupServiceImpl extends AssessmentChildHelper implements ItemGroupService {

    @Autowired
    private transient ItemGroupRepository itemGroupRepository;

    @Autowired
    private transient ItemService itemService;

    @Autowired
    private transient EnemyService enemyService;

    @Autowired
    private transient SegmentService segmentService;

    @Autowired
    private transient FormPartitionService formPartitionService;

    @Override
    public ItemGroup getItemGroup(final String itemGroupId) {
        final ItemGroup itemGroup = this.itemGroupRepository.findOne(itemGroupId);
        loadReferenceData(itemGroup);
        return itemGroup;
    }

    @Override
    public List<ItemGroup> getItemGroupsByAssessment(final String assessmentId) {
        return this.itemGroupRepository.findAllByAssessmentId(assessmentId);
    }

    @Override
    public List<ItemGroup> getItemGroupsBySegment(final String segmentId) {
        final List<ItemGroup> itemGroups = this.itemGroupRepository.findAllByLocationTypeAndLocationId(ItemGroupLocationType.SEGMENT, segmentId);
        for (final ItemGroup itemGroup : itemGroups) {
            loadReferenceData(itemGroup);
        }
        return itemGroups;
    }

    @Override
    public List<ItemGroup> getItemGroupsFormPartition(final String partitionId) {
        final List<ItemGroup> itemGroups = this.itemGroupRepository.findAllByLocationTypeAndLocationId(ItemGroupLocationType.FORM_PARTITION, partitionId);
        for (final ItemGroup itemGroup : itemGroups) {
            loadReferenceData(itemGroup);
        }
        return itemGroups;
    }

    @Override
    public SearchResponse<ItemGroup> search(final Map<String, String[]> parameterMap) {
        final ItemGroupSearchRequest searchRequest = new ItemGroupSearchRequest(parameterMap);
        if (searchRequest.isValid()) {
            final SearchResponse<ItemGroup> itemGroups = this.itemGroupRepository.search(searchRequest);
            for (final ItemGroup itemGroup : itemGroups.getSearchResults()) {
                loadReferenceData(itemGroup);
            }
            return itemGroups;
        }
        throw new RestException("itemGroup.search.invalidsearchcriteria");
    }

    @Override
    public ItemGroup saveItemGroup(final ItemGroup group) {
        ItemGroup savedGroup = null;
        String oldLocationId = null;
        if (group != null) {
            checkForLockedAssessment(group.getAssessmentId());
            if (group.getId() != null) {
                final ItemGroup existingGroup = getItemGroup(group.getId());
                if (existingGroup != null) {
                    oldLocationId = existingGroup.getLocationId();
                }
            }
            try {
                savedGroup = this.itemGroupRepository.save(group);
                if (oldLocationId != null && !oldLocationId.equals(group.getLocationId())) {
                    moveItemsInGroup(savedGroup.getId(), savedGroup.getLocationId(), savedGroup.getLocationType());
                }
            } catch (final DuplicateKeyException dke) {
                throw new LocalizedException("itemGroup.already.exists", new String[] { }, dke);
            }
        }
        return savedGroup;
    }

    @Override
    public void removeItemGroup(final String groupId) {
        final ItemGroup existingGroup = getItemGroup(groupId);
        checkForLockedAssessment(existingGroup.getAssessmentId());

        this.itemService.removeByItemGroupId(groupId);
        final ItemGroup itemGroup = this.itemGroupRepository.findOne(groupId);
        removeEnemiesByItemGroup(itemGroup.getAssessmentId(), groupId);
        this.itemGroupRepository.delete(itemGroup);
    }

    private void moveItemsInGroup(final String groupId, final String targetLocationId, final ItemGroupLocationType targetLocationType) {
        final List<Item> itemsInGroup = this.itemService.getItemsByItemGroupId(groupId);
        for (final Item item : itemsInGroup) {
            for (final ItemLocation location : item.getItemLocation()) {
                if (groupId.equals(location.getItemGroupId())) {
                    if (ItemGroupLocationType.SEGMENT.equals(targetLocationType)) {
                        location.setSegmentId(targetLocationId);
                    } else if (ItemGroupLocationType.FORM_PARTITION.equals(targetLocationType)) {
                        location.setFormPartitionId(targetLocationId);
                    }
                }
            }
        }
        this.itemService.saveItemList(itemsInGroup);
    }

    private void loadReferenceData(final ItemGroup itemGroup) {
        if (itemGroup != null) {
            if (ItemGroupLocationType.SEGMENT.equals(itemGroup.getLocationType())) {
                itemGroup.setSegment(this.segmentService.getSegment(itemGroup.getLocationId()));
            } else if (ItemGroupLocationType.FORM_PARTITION.equals(itemGroup.getLocationType())) {
                itemGroup.setFormPartition(this.formPartitionService.getFormPartition(itemGroup.getLocationId()));
            }
        }
    }

    private void removeEnemiesByItemGroup(final String assessmentId, final String groupId) {
        final Map<String, String[]> params = ImmutableMap.of("assessmentId", paramArray(assessmentId), "objectIdSearch", paramArray(groupId));
        final SearchResponse<Enemy> searchResponse = this.enemyService.searchEnemies(params);
        if (searchResponse.getTotalCount() > 0) {
            for (final Enemy enemy : searchResponse.getSearchResults()) {
                this.enemyService.removeEnemy(enemy.getId());
            }
        }
    }

    @Override
    public void removeItemGroupsByAssessment(final String assessmentId) {
        checkForLockedAssessment(assessmentId);
        this.itemGroupRepository.delete(this.itemGroupRepository.findAllByAssessmentId(assessmentId));
    }

    @Override
    public List<ItemGroup> saveItemGroupList(final List<ItemGroup> itemGroupList) {
        return this.itemGroupRepository.save(itemGroupList);
    }
}
