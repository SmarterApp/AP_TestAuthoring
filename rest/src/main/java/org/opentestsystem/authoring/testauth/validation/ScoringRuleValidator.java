/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.validation;

import java.util.Collection;
import java.util.Map;
import java.util.Map.Entry;
import java.util.NoSuchElementException;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.authoring.testauth.domain.ComputationRuleParameter;
import org.opentestsystem.authoring.testauth.domain.ScoringRule;
import org.opentestsystem.authoring.testauth.domain.ScoringRuleParameter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;
import org.springframework.validation.Errors;
import org.springframework.validation.ValidationUtils;
import org.springframework.validation.Validator;

import com.google.common.base.Function;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.google.common.collect.Maps;
import com.google.common.collect.Multimaps;

@Component
public class ScoringRuleValidator extends AbstractDomainValidator {
    private static final String ERROR_MSG_ROOT = "scoringRule.";
    private static final String VALUE_CONVERSION_TABLE = "valueConversionTableGridFsId";
    private static final String STDERROR_CONVERSION_TABLE = "standardErrorConversionTableGridFsId";
    private static final String PARAMETERS = "parameters";
    private static final String PARAMETER_NAME = "computationRuleParameterName";
    private static final String MSG_PARAMETER_NAME = "." + PARAMETER_NAME;

    private static final String MSG_NOT_FOUND = ".not.found";
    private static final String MSG_MISSING = ".missing";

    private static final String EMPTY_VALUE = "";

    private static final Function<ScoringRuleParameter, String> RULE_PARAMETER_TO_NAME_TRANSFORMER = new Function<ScoringRuleParameter, String>() {
        @Override
        public String apply(final ScoringRuleParameter parameter) {
            return StringUtils.isEmpty(parameter.getComputationRuleParameterName()) ? EMPTY_VALUE : parameter.getComputationRuleParameterName();
        }
    };

    private static final Predicate<Entry<String, Collection<ScoringRuleParameter>>> PARAMETER_DUPLICATE_FILTER = new Predicate<Entry<String, Collection<ScoringRuleParameter>>>() {
        @Override
        public boolean apply(final Entry<String, Collection<ScoringRuleParameter>> entry) {
            return !EMPTY_VALUE.equals(entry.getKey()) && entry.getValue().size() > 1;
        }
    };

    private static class FUNCTION_PARAMETER_FINDER implements Predicate<ComputationRuleParameter> {
        private final String nameToFind;

        private FUNCTION_PARAMETER_FINDER(final String nameToFind) {
            this.nameToFind = nameToFind;
        }

        public static final FUNCTION_PARAMETER_FINDER getInstance(final String nameToFind) {
            return new FUNCTION_PARAMETER_FINDER(nameToFind);
        }

        @Override
        public boolean apply(final ComputationRuleParameter computationRuleParameter) {
            return computationRuleParameter != null && computationRuleParameter.getParameterName() != null && computationRuleParameter.getParameterName().equals(this.nameToFind);
        }
    }

    private static class RULE_PARAMETER_FINDER implements Predicate<ScoringRuleParameter> {
        private final String nameToFind;

        private RULE_PARAMETER_FINDER(final String nameToFind) {
            this.nameToFind = nameToFind;
        }

        public static final RULE_PARAMETER_FINDER getInstance(final String nameToFind) {
            return new RULE_PARAMETER_FINDER(nameToFind);
        }

        @Override
        public boolean apply(final ScoringRuleParameter scoringRuleParameter) {
            return scoringRuleParameter != null && scoringRuleParameter.getComputationRuleParameterName() != null && scoringRuleParameter.getComputationRuleParameterName().equals(this.nameToFind);
        }
    }

    @Autowired
    private ScoringRuleParameterValidator scoringRuleParameterValidator;

    @Autowired
    @Qualifier("jsr303Validator")
    private Validator jsrValidator;

    @Override
    public boolean supports(final Class<?> clazz) {
        return ScoringRule.class.equals(clazz);
    }

    @Override
    public void validate(final Object obj, final Errors errors) {
        // execute JSR-303 validations (annotations)
        this.jsrValidator.validate(obj, errors);

        final ScoringRule scoringRule = (ScoringRule) obj;

        // parameterDataMap can only be evaluated if corresponding ComputationRule is passed along
        if (StringUtils.isNotBlank(scoringRule.getComputationRuleId()) && scoringRule.getComputationRule() != null) {
            validateFileUploads(errors, scoringRule);

            if (!CollectionUtils.isEmpty(scoringRule.getParameters())) {
                // check for duplicate parameter names
                final Map<String, Collection<ScoringRuleParameter>> duplicates =
                        Maps.filterEntries(Multimaps.index(scoringRule.getParameters(), RULE_PARAMETER_TO_NAME_TRANSFORMER).asMap(), PARAMETER_DUPLICATE_FILTER);
                if (!duplicates.isEmpty()) {
                    rejectValue(errors, PARAMETERS, getErrorMessageRoot() + PARAMETERS + MSG_PARAMETER_NAME + MSG_DUPLICATES, duplicates.keySet().toString());
                }

                for (int i = 0; i < scoringRule.getParameters().size(); i++) {
                    final ScoringRuleParameter scoringRuleParameter = scoringRule.getParameters().get(i);
                    try {
                        errors.pushNestedPath(PARAMETERS + "[" + i + "]");
                        final ComputationRuleParameter computationRuleParameter = Iterables.find(scoringRule.getComputationRule().getParameters(),
                                FUNCTION_PARAMETER_FINDER.getInstance(scoringRuleParameter.getComputationRuleParameterName()));
                        if (computationRuleParameter == null) {
                            rejectValue(errors, PARAMETER_NAME, getErrorMessageRoot() + PARAMETERS + MSG_PARAMETER_NAME + MSG_NOT_FOUND, scoringRuleParameter.getComputationRuleParameterName());
                        } else {
                            // evaluate every value within the rule parameter to ensure it adheres to the constraints of the ComputationRuleParameter
                            ValidationUtils.invokeValidator(this.scoringRuleParameterValidator, scoringRuleParameter, errors, computationRuleParameter);
                        }
                    } catch (final NoSuchElementException e) {
                        rejectValue(errors, PARAMETER_NAME, getErrorMessageRoot() + PARAMETERS + MSG_PARAMETER_NAME + MSG_NOT_FOUND, scoringRuleParameter.getComputationRuleParameterName());
                    } finally {
                        errors.popNestedPath();
                    }
                }

                for (final ComputationRuleParameter computationRuleParameter : scoringRule.getComputationRule().getParameters()) {
                    if (!Iterables.any(scoringRule.getParameters(), RULE_PARAMETER_FINDER.getInstance(computationRuleParameter.getParameterName()))) {
                        rejectValue(errors, PARAMETERS, getErrorMessageRoot() + PARAMETERS + MSG_PARAMETER_NAME + MSG_MISSING, computationRuleParameter.getParameterName());
                    }
                }
            }
        }
    }

    private void validateFileUploads(final Errors errors, final ScoringRule scoringRule) {
        final boolean hasValueId = StringUtils.isNotBlank(scoringRule.getValueConversionTableGridFsId());
        final boolean hasStdErrorId = StringUtils.isNotBlank(scoringRule.getStandardErrorConversionTableGridFsId());
        switch (scoringRule.getComputationRule().getConversionTableType()) {
        case VALUE:
            if (!hasValueId) {
                rejectValue(errors, VALUE_CONVERSION_TABLE, getErrorMessageRoot() + VALUE_CONVERSION_TABLE + MSG_REQUIRED);
            }
            if (hasStdErrorId) {
                rejectValue(errors, STDERROR_CONVERSION_TABLE, getErrorMessageRoot() + STDERROR_CONVERSION_TABLE + MSG_REQUIRED_EMPTY);
            }
            break;
        case VALUE_STANDARD_ERROR:
            if (!hasValueId) {
                rejectValue(errors, VALUE_CONVERSION_TABLE, getErrorMessageRoot() + VALUE_CONVERSION_TABLE + MSG_REQUIRED);
            }
            if (!hasStdErrorId) {
                rejectValue(errors, STDERROR_CONVERSION_TABLE, getErrorMessageRoot() + STDERROR_CONVERSION_TABLE + MSG_REQUIRED);
            }
            break;
        case NONE:
            if (hasValueId) {
                rejectValue(errors, VALUE_CONVERSION_TABLE, getErrorMessageRoot() + VALUE_CONVERSION_TABLE + MSG_REQUIRED_EMPTY);
            }
            if (hasStdErrorId) {
                rejectValue(errors, STDERROR_CONVERSION_TABLE, getErrorMessageRoot() + STDERROR_CONVERSION_TABLE + MSG_REQUIRED_EMPTY);
            }
            break;

        default:
            break;
        }
    }

    @Override
    protected String getErrorMessageRoot() {
        return ERROR_MSG_ROOT;
    }
}
