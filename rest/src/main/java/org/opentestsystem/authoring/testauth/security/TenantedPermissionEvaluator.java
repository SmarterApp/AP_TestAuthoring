/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testauth.security;

import java.io.Serializable;
import java.util.Map;

import javax.annotation.PostConstruct;

import org.opentestsystem.authoring.testauth.persistence.AffinityGroupRepository;
import org.opentestsystem.authoring.testauth.persistence.AssessmentRepository;
import org.opentestsystem.authoring.testauth.persistence.BlueprintElementRepository;
import org.opentestsystem.authoring.testauth.persistence.EnemyRepository;
import org.opentestsystem.authoring.testauth.persistence.FormPartitionRepository;
import org.opentestsystem.authoring.testauth.persistence.FormRepository;
import org.opentestsystem.authoring.testauth.persistence.ItemGroupRepository;
import org.opentestsystem.authoring.testauth.persistence.PerformanceLevelRepository;
import org.opentestsystem.authoring.testauth.persistence.PublishingRecordRepository;
import org.opentestsystem.authoring.testauth.persistence.ReportingMeasureRepository;
import org.opentestsystem.authoring.testauth.persistence.ScoringRuleRepository;
import org.opentestsystem.authoring.testauth.persistence.SegmentRepository;
import org.opentestsystem.authoring.testauth.persistence.SubjectRepository;
import org.opentestsystem.authoring.testauth.service.TenantEnforcementService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.repository.CrudRepository;
import org.springframework.security.access.PermissionEvaluator;
import org.springframework.security.core.Authentication;

import com.google.common.collect.Maps;

public class TenantedPermissionEvaluator implements PermissionEvaluator {

    private static final Logger LOGGER = LoggerFactory.getLogger(TenantedPermissionEvaluator.class);

    @Autowired
    private TenantEnforcementService tenantEnforcementService;

    @Autowired
    private SubjectRepository subjectRepo;
    @Autowired
    private AssessmentRepository assessmentRepo;
    @Autowired
    private SegmentRepository segmentRepo;
    @Autowired
    private BlueprintElementRepository blueprintElementRepo;
    @Autowired
    private AffinityGroupRepository affinityGroupRepo;
    @Autowired
    private ItemGroupRepository itemGroupRepo;
    @Autowired
    private FormRepository formRepo;
    @Autowired
    private FormPartitionRepository formPartitionRepo;
    @Autowired
    private EnemyRepository enemyRepo;
    @Autowired
    private ScoringRuleRepository scoringRuleRepo;
    @Autowired
    private PerformanceLevelRepository performanceLevelRepo;
    @Autowired
    private ReportingMeasureRepository reportingMeasureRepo;
    @Autowired
    private PublishingRecordRepository publishingRecordRepo;
    private static final Map<String, CrudRepository<?, String>> REPO_MAP = Maps.newHashMap();

    @PostConstruct
    public void setupRepoMap() {
        REPO_MAP.put("subject", this.subjectRepo);
        REPO_MAP.put("assessment", this.assessmentRepo);
        REPO_MAP.put("segment", this.segmentRepo);
        REPO_MAP.put("blueprintElement", this.blueprintElementRepo);
        REPO_MAP.put("affinityGroup", this.affinityGroupRepo);
        REPO_MAP.put("itemGroup", this.itemGroupRepo);
        REPO_MAP.put("enemy", this.enemyRepo);
        REPO_MAP.put("form", this.formRepo);
        REPO_MAP.put("formPartition", this.formPartitionRepo);
        REPO_MAP.put("scoringRule", this.scoringRuleRepo);
        REPO_MAP.put("performanceLevel", this.performanceLevelRepo);
        REPO_MAP.put("reportingMeasure", this.reportingMeasureRepo);
        REPO_MAP.put("publishingRecord", this.publishingRecordRepo);
    }

    @Override
    public boolean hasPermission(final Authentication inAuthentication, final Serializable inTargetId, final String inTargetType, final Object inPermission) {
        try {
            Object targetObject;
            if ("tenantId".equals(inTargetType)) {
                targetObject = inTargetId;
            } else {
                targetObject = REPO_MAP.get(inTargetType).findOne(inTargetId.toString());
            }
            return hasPermission(inAuthentication, targetObject, inPermission);
        } catch (final IllegalArgumentException e) {
            // in the case the inTargetType doesn't match any DomainTypes
            LOGGER.error("there was an issue finding a domain of type: " + inTargetType + " please confirm TenantedPermisionEvaluator.DomainType and @PreAuthorize annotation bindings", e);
            return false;
        }
    }

    @Override
    public boolean hasPermission(final Authentication inAuthentication, final Object inTargetDomainObject, final Object inPermission) {
        return this.tenantEnforcementService.enforceTenancyForObject(inTargetDomainObject, new String[] { (String) inPermission });
    }
}
